/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Ccomponents%5C%5COverlayScrollbarsClientComponent.tsx%22%2C%22ids%22%3A%5B%22*%22%2C%22OverlayScrollbarsClientComponent%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Ccomponents%5C%5COverlayScrollbarsClientComponent.tsx%22%2C%22ids%22%3A%5B%22*%22%2C%22OverlayScrollbarsClientComponent%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/OverlayScrollbarsClientComponent.tsx */ \"(app-pages-browser)/./components/OverlayScrollbarsClientComponent.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/link.js */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q0dpdGh1YiU1QyU1Q092ZXJsYXlTY3JvbGxiYXJzJTVDJTVDd2Vic2l0ZSU1QyU1Q2NvbXBvbmVudHMlNUMlNUNPdmVybGF5U2Nyb2xsYmFyc0NsaWVudENvbXBvbmVudC50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjIqJTIyJTJDJTIyT3ZlcmxheVNjcm9sbGJhcnNDbGllbnRDb21wb25lbnQlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q0dpdGh1YiU1QyU1Q092ZXJsYXlTY3JvbGxiYXJzJTVDJTVDd2Vic2l0ZSU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Q25leHQlNUMlNUNkaXN0JTVDJTVDY2xpZW50JTVDJTVDbGluay5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMiolMjIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw0TkFBNkg7QUFDN0g7QUFDQSw4TUFBc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8yMjVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcR2l0aHViXFxcXE92ZXJsYXlTY3JvbGxiYXJzXFxcXHdlYnNpdGVcXFxcY29tcG9uZW50c1xcXFxPdmVybGF5U2Nyb2xsYmFyc0NsaWVudENvbXBvbmVudC50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXEdpdGh1YlxcXFxPdmVybGF5U2Nyb2xsYmFyc1xcXFx3ZWJzaXRlXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGxpbmsuanNcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Ccomponents%5C%5COverlayScrollbarsClientComponent.tsx%22%2C%22ids%22%3A%5B%22*%22%2C%22OverlayScrollbarsClientComponent%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/OverlayScrollbarsClientComponent.tsx":
/*!*********************************************************!*\
  !*** ./components/OverlayScrollbarsClientComponent.tsx ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OverlayScrollbarsClientComponent: function() { return /* reexport safe */ overlayscrollbars_react__WEBPACK_IMPORTED_MODULE_0__.OverlayScrollbarsComponent; }\n/* harmony export */ });\n/* harmony import */ var overlayscrollbars_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! overlayscrollbars-react */ \"(app-pages-browser)/../packages/overlayscrollbars-react/dist/overlayscrollbars-react.mjs\");\n/* __next_internal_client_entry_do_not_use__ OverlayScrollbarsClientComponent auto */ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvT3ZlcmxheVNjcm9sbGJhcnNDbGllbnRDb21wb25lbnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7O3NGQUN5RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL092ZXJsYXlTY3JvbGxiYXJzQ2xpZW50Q29tcG9uZW50LnRzeD9iNDdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuZXhwb3J0IHsgT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnQgYXMgT3ZlcmxheVNjcm9sbGJhcnNDbGllbnRDb21wb25lbnQgfSBmcm9tICdvdmVybGF5c2Nyb2xsYmFycy1yZWFjdCc7XHJcbiJdLCJuYW1lcyI6WyJPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudCIsIk92ZXJsYXlTY3JvbGxiYXJzQ2xpZW50Q29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/OverlayScrollbarsClientComponent.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs2Q0FHYUE7OztlQUFBQTs7O29EQUY4QjtBQUVwQyxNQUFNQSxZQUF1QixTQUFDQyxJQUFBQTtxQ0FBU0MsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsSUFBQUEsT0FBQUEsSUFBQUEsSUFBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7UUFBQUEsSUFBQUEsQ0FBQUEsT0FBQUEsRUFBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O0lBQzVDLElBQUlDLEtBQStCLEVBQUUsRUFJckM7SUFDQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2FkZC1sb2NhbGUudHM/ZmFhZSJdLCJuYW1lcyI6WyJhZGRMb2NhbGUiLCJwYXRoIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath = \"/OverlayScrollbars\" || 0;\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBT2dCQTs7O2VBQUFBOzs7b0RBSjJCO0FBRTNDLE1BQU1DLFdBQVdDLG9CQUFtQyxJQUFlO0FBRTVELFNBQVNGLGdCQUNkSyxJQUFZLEVBQ1pDLE1BQXVCLEVBQ3ZCQyxPQUFrQixFQUNsQkMsYUFBOEI7SUFFOUIsSUFBSU4sS0FBK0IsRUFBRSxFQWdCckMsTUFBTztRQUNMLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLnRzPzFkNGUiXSwibmFtZXMiOlsiZ2V0RG9tYWluTG9jYWxlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsImRldGVjdERvbWFpbkxvY2FsZSIsInRhcmdldCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwidW5kZWZpbmVkIiwicHJvdG8iLCJodHRwIiwiZmluYWxMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (typeof window === \"undefined\") {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const doPrefetch = async ()=>{\n        if (isAppRouter) {\n            // note that `appRouter.prefetch()` is currently sync,\n            // so we have to wrap this call in an async function to be able to catch() errors below.\n            return router.prefetch(href, appOptions);\n        } else {\n            return router.prefetch(href, as, options);\n        }\n    };\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browserâ€™s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== \"undefined\" ? \"\\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== \"undefined\" ? \" \\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7NkJBUzRCQSx5QkFBQUMsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTt5Q0FDRDt3Q0FDRDt1Q0FDSTs7Ozt1Q0FRRUEsbUJBQUFBLENBQUE7NkNBQ0E7NkNBQ0o7O0FBMkY1QixNQUFNQyxzQkFBaUJDLG1CQUFBQSxDQUFBQSwrSkFBQUE7QUFVdkIsTUFBQUQsYUFDRUUsSUFBQUE7U0FPSUMsU0FBT0MsTUFBQUEsRUFBV0MsSUFBQSxFQUFBQyxFQUFBLEVBQUFDLE9BQWEsRUFBQUMsVUFBQSxFQUFBQyxXQUFBO1FBQ2pDLE9BQUFMLFdBQUE7UUFDRjtJQUVBO0lBQ0EsZ0pBQXVDO1FBQ3JDLENBQUFLLGVBQUEsS0FBQUMsWUFBQUMsVUFBQSxFQUFBTixPQUFBO1FBQ0Y7SUFFQTtJQUNBLDRFQUFZO0lBQ1osWUFBS0U7UUFDSCxDQUFBQSxRQUFNSyxxQkFDSjtRQUNBLE1BQUFBLFNBT0YsT0FBTUMsUUFBQUEsTUFBQUEsS0FBZ0JSLGNBQWtCRSxRQUFNSyxNQUFBQSxHQUFBQSxZQUFBQSxTQUFBQSxPQUFBQSxNQUFBQSxHQUFBQTtRQUU5QyxNQUFBQyxnQkFBQVIsT0FBQSxNQUFBQyxLQUFBLE1BQUFNO1FBQ0Esa0VBQW1DO1lBQ2pDWixXQUFBYyxHQUFBLENBQUFELGdCQUFBO1lBQ0Y7UUFFQTtRQUNBYiwrQkFBZWE7UUFDakJiLFdBQUFlLEdBQUEsQ0FBQUY7SUFFQTtVQUNFRyxhQUFJUDtZQUNGQSxhQUFBO1lBQ0E7WUFDQSx3RkFBb0REO1lBQ3RELE9BQU9OLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUc7ZUFDTDtZQUNGLE9BQUFOLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUMsSUFBQUM7UUFDRjtJQUVBO0lBQ0E7SUFDQSwwREFBc0Q7SUFDdEQ7SUFDQVMseURBQW9CQztpQkFDZEMsS0FBUUMsQ0FBRyxDQUFDQztZ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Y0FBQTVGLE9BQUFDLE9BQUEsQ0FBQTRGLFlBQUEsQ0FBQXJDLE9BQUF3QixjQUFBLGtCQUFBYyxZQUFBQyxHQUFBO1FBQUcsR0FBR2YsU0FBQUE7cUJBQ25CekU7O0lBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvbGluay50c3g/YWNmMCJdLCJuYW1lcyI6WyJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfIiwicmVxdWlyZSIsInByZWZldGNoZWQiLCJTZXQiLCJyb3V0ZXIiLCJwcmVmZXRjaCIsIndpbmRvdyIsImhyZWYiLCJhcyIsIm9wdGlvbnMiLCJhcHBPcHRpb25zIiwiaXNBcHBSb3V0ZXIiLCJfaXNsb2NhbHVybCIsImlzTG9jYWxVUkwiLCJsb2NhbGUiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwiZG9QcmVmZXRjaCIsImVyciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImV2ZW50VGFyZ2V0IiwibmF0aXZlRXZlbnQiLCJ3aGljaCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJsaW5rQ2xpY2tlZCIsImUiLCJyZXBsYWNlIiwic2hhbGxvdyIsInNjcm9sbCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJyb3V0ZXJTY3JvbGwiLCJSZWFjdCIsIl9yZWFjdCIsImRlZmF1bHQiLCJzdGFydFRyYW5zaXRpb24iLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiX2Zvcm1hdHVybCIsImZvcm1hdFVybCIsImNoaWxkcmVuIiwiY2hpbGRyZW5Qcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJhIiwiYXBwUm91dGVyIiwidXNlQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJwYWdlc1JvdXRlciIsInByZWZldGNoRW5hYmxlZCIsInByZWZldGNoUHJvcCIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiRlVMTCIsImFyZ3MiLCJjcmVhdGVQcm9wRXJyb3IiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsInByb3BzIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Ub3VjaFN0YXJ0Iiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJhc1Byb3AiLCJocmVmUHJvcCIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJfcmVzb2x2ZWhyZWYiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzQXMiLCJ1c2VSZWYiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJjaGlsZFJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJfdXNlaW50ZXJzZWN0aW9uIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInByZXZpb3VzSHJlZiIsInVzZUVmZmVjdCIsImFwcFByZWZldGNoS2luZCIsInJlZiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbk1vdXNlRW50ZXJQcm9wIiwicHJpb3JpdHkiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJvblRvdWNoU3RhcnRQcm9wIiwidW5kZWZpbmVkIiwiY2hpbGRQcm9wcyIsImN1ckxvY2FsZSIsImlzTG9jYWxlRG9tYWluIiwibG9jYWxlRG9tYWluIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJfZ2V0ZG9tYWlubG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX2FkZGJhc2VwYXRoIiwiX2FkZGxvY2FsZSIsInJlc3RQcm9wcyIsImNsb25lRWxlbWVudCIsIl9qc3hydW50aW1lIiwianN4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLG9CQUFrQjtlQUFsQkE7O0lBaEJBQyxxQkFBbUI7ZUFBbkJBOzs7QUFBTixNQUFNQSxzQkFDWCxPQUFRQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlO2dCQUNiLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUE7WUFDeEM7UUFDRjtJQUNGLEdBQUc7QUFDTDtBQUVLLE1BQU1OLHFCQUNYLE9BQVFFLFNBQVMsZUFDZkEsS0FBS0Ysa0JBQWtCLElBQ3ZCRSxLQUFLRixrQkFBa0IsQ0FBQ0csSUFBSSxDQUFDQyxXQUMvQixTQUFVVSxFQUFVO0lBQ2xCLE9BQU9DLGFBQWFEO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cz8wNWY0Il0sIm5hbWVzIjpbImNhbmNlbElkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQXlCZ0JBOzs7ZUFBQUE7Ozt5Q0F2QnVCO3VDQUNGO2tDQUNoQjttQ0FDb0I7b0RBQ0U7d0NBQ2hCO29DQUNJOzJDQUNEO0FBZ0J2QixTQUFTQSxZQUNkQyxNQUFrQixFQUNsQkMsSUFBUyxFQUNUQyxTQUFtQjtJQUVuQiw0Q0FBNEM7SUFDNUMsSUFBSUM7SUFDSixJQUFJQyxjQUFjLE9BQU9ILFNBQVMsV0FBV0EsT0FBT0ksQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CLEVBQUNKO0lBRXpFLDZEQUE2RDtJQUM3RCxtREFBbUQ7SUFDbkQsTUFBTUssZ0JBQWdCRixZQUFZRyxLQUFLLENBQUM7SUFDeEMsTUFBTUMscUJBQXFCRixnQkFDdkJGLFlBQVlLLEtBQUssQ0FBQ0gsYUFBYSxDQUFDLEVBQUUsQ0FBQ0ksTUFBTSxJQUN6Q047SUFFSixNQUFNTyxXQUFXSCxtQkFBbUJJLEtBQUssQ0FBQyxLQUFLO0lBRS9DLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJSixLQUFLLENBQUMsY0FBYztRQUMxQ00sUUFBUUMsS0FBSyxDQUNYLG1CQUFpQlYsY0FBWSx1Q0FBb0NKLE9BQU9lLFFBQVEsR0FBQztRQUVuRixNQUFNQyxnQkFBZ0JDLENBQUFBLEdBQUFBLE9BQUFBLHdCQUF3QixFQUFDVDtRQUMvQ0osY0FBYyxDQUFDRSxnQkFBZ0JBLGFBQWEsQ0FBQyxFQUFFLEdBQUcsTUFBTVU7SUFDMUQ7SUFFQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDRSxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNkLGNBQWM7UUFDNUIsT0FBUUYsWUFBWTtZQUFDRTtTQUFZLEdBQUdBO0lBQ3RDO0lBRUEsSUFBSTtRQUNGRCxPQUFPLElBQUlnQixJQUNUZixZQUFZZ0IsVUFBVSxDQUFDLE9BQU9wQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT2UsUUFBUSxFQUM3RDtJQUVKLEVBQUUsT0FBT08sR0FBRztRQUNWLGtEQUFrRDtRQUNsRG5CLE9BQU8sSUFBSWdCLElBQUksS0FBSztJQUN0QjtJQUVBLElBQUk7UUFDRixNQUFNSSxXQUFXLElBQUlKLElBQUlmLGFBQWFEO1FBQ3RDb0IsU0FBU1IsUUFBUSxHQUFHUyxDQUFBQSxHQUFBQSx3QkFBQUEsMEJBQTBCLEVBQUNELFNBQVNSLFFBQVE7UUFDaEUsSUFBSVUsaUJBQWlCO1FBRXJCLElBQ0VDLENBQUFBLEdBQUFBLFFBQUFBLGNBQWMsRUFBQ0gsU0FBU1IsUUFBUSxLQUNoQ1EsU0FBU0ksWUFBWSxJQUNyQnpCLFdBQ0E7WUFDQSxNQUFNMEIsUUFBUUMsQ0FBQUEsR0FBQUEsYUFBQUEsc0JBQXNCLEVBQUNOLFNBQVNJLFlBQVk7WUFFMUQsTUFBTSxFQUFFRyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQ3RDVCxTQUFTUixRQUFRLEVBQ2pCUSxTQUFTUixRQUFRLEVBQ2pCYTtZQUdGLElBQUlFLFFBQVE7Z0JBQ1ZMLGlCQUFpQnBCLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFvQixFQUFDO29CQUNwQ1UsVUFBVWU7b0JBQ1ZHLE1BQU1WLFNBQVNVLElBQUk7b0JBQ25CTCxPQUFPTSxDQUFBQSxHQUFBQSxNQUFBQSxJQUFJLEVBQUNOLE9BQU9HO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxvRUFBb0U7UUFDcEUsTUFBTUksZUFDSlosU0FBU2EsTUFBTSxLQUFLakMsS0FBS2lDLE1BQU0sR0FDM0JiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUMxQ2EsU0FBU3RCLElBQUk7UUFFbkIsT0FBT0MsWUFDSDtZQUFDaUM7WUFBY1Ysa0JBQWtCVTtTQUFhLEdBQzlDQTtJQUNOLEVBQUUsT0FBT2IsR0FBRztRQUNWLE9BQU9wQixZQUFZO1lBQUNFO1NBQVksR0FBR0E7SUFDckM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9yZXNvbHZlLWhyZWYudHM/ZTZkMiJdLCJuYW1lcyI6WyJyZXNvbHZlSHJlZiIsInJvdXRlciIsImhyZWYiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInNsaWNlIiwibGVuZ3RoIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsInBhdGhuYW1lIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImlzTG9jYWxVUkwiLCJVUkwiLCJzdGFydHNXaXRoIiwiYXNQYXRoIiwiXyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwicmVzdWx0IiwicGFyYW1zIiwiaW50ZXJwb2xhdGVBcyIsImhhc2giLCJvbWl0IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OzttREErRmdCQTs7O2VBQUFBOzs7bUNBL0Z5QztpREFJbEQ7QUFxQlAsTUFBTUMsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUVoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQXVCLEVBQUU7QUFFL0IsU0FBU0MsZUFBZUMsT0FBb0M7SUFDMUQsTUFBTUMsS0FBSztRQUNUQyxNQUFNRixRQUFRRSxJQUFJLElBQUk7UUFDdEJDLFFBQVFILFFBQVFJLFVBQVUsSUFBSTtJQUNoQztJQUNBLE1BQU1DLFdBQVdQLE9BQU9RLElBQUksQ0FDMUIsQ0FBQ0MsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtJQUUzRCxJQUFJSztJQUVKLElBQUlILFVBQVU7UUFDWkcsV0FBV1osVUFBVWEsR0FBRyxDQUFDSjtRQUN6QixJQUFJRyxVQUFVO1lBQ1osT0FBT0E7UUFDVDtJQUNGO0lBRUEsTUFBTUUsV0FBVyxJQUFJYjtJQUNyQixNQUFNYyxXQUFXLElBQUloQixxQkFBcUIsQ0FBQ2lCO1FBQ3pDQSxRQUFRQyxPQUFPLENBQUMsQ0FBQ0M7WUFDZixNQUFNQyxXQUFXTCxTQUFTRCxHQUFHLENBQUNLLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN6QkYsU0FBU0U7WUFDWDtRQUNGO0lBQ0YsR0FBR2pCO0lBQ0hRLFdBQVc7UUFDVFA7UUFDQVU7UUFDQUQ7SUFDRjtJQUVBWixPQUFPc0IsSUFBSSxDQUFDbkI7SUFDWkwsVUFBVXlCLEdBQUcsQ0FBQ3BCLElBQUlPO0lBQ2xCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTYyxRQUNQQyxPQUFnQixFQUNoQlIsUUFBeUIsRUFDekJmLE9BQW9DO0lBRXBDLE1BQU0sRUFBRUMsRUFBRSxFQUFFVSxRQUFRLEVBQUVELFFBQVEsRUFBRSxHQUFHWCxlQUFlQztJQUNsRFUsU0FBU1csR0FBRyxDQUFDRSxTQUFTUjtJQUV0QkosU0FBU1csT0FBTyxDQUFDQztJQUNqQixPQUFPLFNBQVNDO1FBQ2RkLFNBQVNlLE1BQU0sQ0FBQ0Y7UUFDaEJaLFNBQVNhLFNBQVMsQ0FBQ0Q7UUFFbkIsdURBQXVEO1FBQ3ZELElBQUliLFNBQVNnQixJQUFJLEtBQUssR0FBRztZQUN2QmYsU0FBU2dCLFVBQVU7WUFDbkIvQixVQUFVNkIsTUFBTSxDQUFDeEI7WUFDakIsTUFBTTJCLFFBQVE5QixPQUFPK0IsU0FBUyxDQUM1QixDQUFDdEIsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtZQUUzRCxJQUFJeUIsUUFBUSxDQUFDLEdBQUc7Z0JBQ2Q5QixPQUFPZ0MsTUFBTSxDQUFDRixPQUFPO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGO0FBRU8sU0FBU25DLGdCQUFtQ3NDLEtBSWpDO0lBSmlDLE1BQ2pEQyxPQUFPLEVBQ1A1QixVQUFVLEVBQ1Y2QixRQUFRLEVBQ1EsR0FKaUNGO0lBS2pELE1BQU1HLGFBQXNCRCxZQUFZLENBQUN2QztJQUV6QyxNQUFNLENBQUN5QyxTQUFTQyxXQUFXLEdBQUdDLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFBQztJQUN2QyxNQUFNQyxhQUFhQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBQVc7SUFDcEMsTUFBTUMsYUFBYUMsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBVyxFQUFDLENBQUNsQjtRQUM5QmUsV0FBV0ksT0FBTyxHQUFHbkI7SUFDdkIsR0FBRyxFQUFFO0lBRUxvQixDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUixJQUFJakQseUJBQXlCO1lBQzNCLElBQUl3QyxjQUFjQyxTQUFTO1lBRTNCLE1BQU1aLFVBQVVlLFdBQVdJLE9BQU87WUFDbEMsSUFBSW5CLFdBQVdBLFFBQVFxQixPQUFPLEVBQUU7Z0JBQzlCLE1BQU1wQixZQUFZRixRQUNoQkMsU0FDQSxDQUFDTixZQUFjQSxhQUFhbUIsV0FBV25CLFlBQ3ZDO29CQUFFZixNQUFNOEIsV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU1UsT0FBTztvQkFBRXRDO2dCQUFXO2dCQUd2QyxPQUFPb0I7WUFDVDtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNXLFNBQVM7Z0JBQ1osTUFBTVUsZUFBZUMsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDLElBQU1WLFdBQVc7Z0JBQzFELE9BQU8sSUFBTVcsQ0FBQUEsR0FBQUEscUJBQUFBLGtCQUFrQixFQUFDRjtZQUNsQztRQUNGO0lBQ0EsdURBQXVEO0lBQ3pELEdBQUc7UUFBQ1g7UUFBWTlCO1FBQVk0QjtRQUFTRztRQUFTRyxXQUFXSSxPQUFPO0tBQUM7SUFFakUsTUFBTU0sZUFBZVAsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBVyxFQUFDO1FBQy9CTCxXQUFXO0lBQ2IsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUFDSTtRQUFZTDtRQUFTYTtLQUFhO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24udHN4PzU3ZWUiXSwibmFtZXMiOlsidXNlSW50ZXJzZWN0aW9uIiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVycyIsIk1hcCIsImlkTGlzdCIsImNyZWF0ZU9ic2VydmVyIiwib3B0aW9ucyIsImlkIiwicm9vdCIsIm1hcmdpbiIsInJvb3RNYXJnaW4iLCJleGlzdGluZyIsImZpbmQiLCJvYmoiLCJpbnN0YW5jZSIsImdldCIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwicHVzaCIsInNldCIsIm9ic2VydmUiLCJlbGVtZW50IiwidW5vYnNlcnZlIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInBhcmFtIiwicm9vdFJlZiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwidXNlU3RhdGUiLCJlbGVtZW50UmVmIiwidXNlUmVmIiwic2V0RWxlbWVudCIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInRhZ05hbWUiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVzZXRWaXNpYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTs7Ozs7c0RBSTFEQTs7O2VBQUFBOzs7QUFIaEIsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFFakIsU0FBU0YsbUJBQW1CRyxHQUFXO0lBQzVDLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDekIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDdEM7SUFDQSxPQUFPQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLnRzP2RjYjEiXSwibmFtZXMiOlsiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0gsY0FBY0ksV0FBVyxHQUFHO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cz82MzZjIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsV0FBUztlQUFUQTs7SUE2REFDLHNCQUFvQjtlQUFwQkE7O0lBZkhDLGVBQWE7ZUFBYkE7Ozs7bUZBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBTyxNQUFJUixXQUFTLE1BQUtBLFFBQUFBO1FBQzFELElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNmSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDM0I7SUFDRjtJQUVBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3RDQSxRQUFRTSxPQUFPQyxhQUFZQyxzQkFBc0IsQ0FBQ1I7SUFDcEQ7SUFFQSxJQUFJUyxTQUFTZixPQUFPZSxNQUFNLElBQUtULFNBQVMsTUFBSUEsU0FBWTtJQUV4RCxJQUFJSCxZQUFZLENBQUNBLFNBQVNhLFFBQVEsQ0FBQyxNQUFNYixZQUFZO0lBRXJELElBQ0VILE9BQU9pQixPQUFPLElBQ2IsQ0FBQyxDQUFDZCxZQUFZSixpQkFBaUJtQixJQUFJLENBQUNmLFNBQUFBLEtBQWNJLFNBQVMsT0FDNUQ7UUFDQUEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRO1FBQ3ZCLElBQUlILFlBQVlBLFFBQVEsQ0FBQyxFQUFFLEtBQUssS0FBS0EsV0FBVyxNQUFNQTtJQUN4RCxPQUFPLElBQUksQ0FBQ0csTUFBTTtRQUNoQkEsT0FBTztJQUNUO0lBRUEsSUFBSUYsUUFBUUEsSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxPQUFPLE1BQU1BO0lBQzFDLElBQUlVLFVBQVVBLE1BQU0sQ0FBQyxFQUFFLEtBQUssS0FBS0EsU0FBUyxNQUFNQTtJQUVoRFgsV0FBV0EsU0FBU0ssT0FBTyxDQUFDLFNBQVNEO0lBQ3JDTyxTQUFTQSxPQUFPTixPQUFPLENBQUMsS0FBSztJQUU3QixPQUFPLEtBQUdOLFdBQVdJLE9BQU9ILFdBQVdXLFNBQVNWO0FBQ2xEO0FBRU8sTUFBTVAsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRU0sU0FBU0QscUJBQXFCc0IsR0FBYztJQUNqRCxJQUFJQyxJQUF5QixFQUFlO1FBQzFDLElBQUlELFFBQVEsUUFBUSxPQUFPQSxRQUFRLFVBQVU7WUFDM0NFLE9BQU9DLElBQUksQ0FBQ0gsS0FBS0ksT0FBTyxDQUFDLENBQUNDO2dCQUN4QixJQUFJLENBQUMxQixjQUFjMkIsUUFBUSxDQUFDRCxNQUFNO29CQUNoQ0UsUUFBUUMsSUFBSSxDQUNWLHVEQUFxREg7Z0JBRXpEO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBTzVCLFVBQVV1QjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHM/YTBiMyJdLCJuYW1lcyI6WyJmb3JtYXRVcmwiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybE9iamVjdEtleXMiLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJlbmRzV2l0aCIsInNsYXNoZXMiLCJ0ZXN0IiwidXJsIiwicHJvY2VzcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQVNBLGlCQUFlO2VBQWZBLGNBQUFBLGVBQWU7O0lBQ2ZDLGdCQUFjO2VBQWRBLFdBQUFBLGNBQWM7OzswQ0FEUzt1Q0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LnRzPzg3YmIiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6Ijs7OztpREFLZ0JBOzs7ZUFBQUE7OzswQ0FIZ0I7d0NBQ0Y7QUFFdkIsU0FBU0EsY0FDZEMsS0FBYSxFQUNiQyxVQUFrQixFQUNsQkMsS0FBcUI7SUFFckIsSUFBSUMsb0JBQW9CO0lBRXhCLE1BQU1DLGVBQWVDLENBQUFBLEdBQUFBLFlBQUFBLGFBQWEsRUFBQ0w7SUFDbkMsTUFBTU0sZ0JBQWdCRixhQUFhRyxNQUFNO0lBQ3pDLE1BQU1DLGlCQUVIUCxDQUFBQSxlQUFlRCxRQUFRUyxDQUFBQSxHQUFBQSxjQUFBQSxlQUFlLEVBQUNMLGNBQWNILGNBQWMsT0FDcEUsZ0RBQWdEO0lBQ2hELHNFQUFzRTtJQUN0RUM7SUFFRkMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTQyxPQUFPQyxJQUFJLENBQUNOO0lBRTNCLElBQ0UsQ0FBQ0ksT0FBT0csS0FBSyxDQUFDLENBQUNDO1FBQ2IsSUFBSUMsUUFBUVAsY0FBYyxDQUFDTSxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFRSxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHWCxhQUFhLENBQUNRLE1BQU07UUFFakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJSSxXQUFXLE1BQUlGLENBQUFBLFNBQVMsUUFBUSxNQUFLRixRQUFNO1FBQy9DLElBQUlHLFVBQVU7WUFDWkMsV0FBVyxDQUFHLENBQUNILFFBQVEsTUFBTSxNQUFHLE1BQUdHLFdBQVM7UUFDOUM7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUUEsUUFBUTtZQUFDQTtTQUFNO1FBRXBELE9BQ0UsQ0FBQ0UsWUFBWUgsU0FBU04sY0FBQUEsS0FDdEIsNkNBQTZDO1FBQzVDTCxDQUFBQSxvQkFDQ0Esa0JBQW1Ca0IsT0FBTyxDQUN4QkgsVUFDQUYsU0FDSUQsTUFDR08sR0FBRyxDQUVGLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVlDLG1CQUFtQkQsVUFFakNFLElBQUksQ0FBQyxPQUNSRCxtQkFBbUJULFdBQ3BCO0lBRVgsSUFDQTtRQUNBWixvQkFBb0IsR0FBRyxtQ0FBbUM7O0lBRTFELHVFQUF1RTtJQUN2RSxrREFBa0Q7SUFDcEQ7SUFDQSxPQUFPO1FBQ0xPO1FBQ0FnQixRQUFRdkI7SUFDVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMudHM/NGYzYiJdLCJuYW1lcyI6WyJpbnRlcnBvbGF0ZUFzIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInZhbHVlIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQVFnQkE7OztlQUFBQTs7O2dEQUxUO0FBRVAscUNBQXFDO0FBQ3JDLE1BQU1DLGFBQWE7QUFFWixTQUFTRCxlQUFlRSxLQUFhO0lBQzFDLElBQUlDLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBMEIsRUFBQ0QsUUFBUTtRQUNyQ0EsUUFBUUUsQ0FBQUEsR0FBQUEsb0JBQUFBLG1DQUFtQyxFQUFDRixPQUFPRyxnQkFBZ0I7SUFDckU7SUFFQSxPQUFPSixXQUFXSyxJQUFJLENBQUNKO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cz85ZTM1Il0sIm5hbWVzIjpbImlzRHluYW1pY1JvdXRlIiwiVEVTVF9ST1VURSIsInJvdXRlIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbiIsImludGVyY2VwdGVkUm91dGUiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7bUNBTmlDO3lDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBQ0QsTUFBTSxPQUFPO0lBQ2hDLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsTUFBTUUsaUJBQWlCQyxDQUFBQSxHQUFBQSxPQUFBQSxpQkFBaUI7UUFDeEMsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQkssQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDSCxTQUFTSSxRQUFRO0lBQzVFLEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzPzZmYTUiXSwibmFtZXMiOlsiaXNMb2NhbFVSTCIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJoYXNCYXNlUGF0aCIsInBhdGhuYW1lIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiOzs7O3dDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsS0FDZEMsTUFBUyxFQUNUQyxJQUFTO0lBRVQsTUFBTUMsVUFBc0MsQ0FBQztJQUM3Q0MsT0FBT0YsSUFBSSxDQUFDRCxRQUFRSSxPQUFPLENBQUMsQ0FBQ0M7UUFDM0IsSUFBSSxDQUFDSixLQUFLSyxRQUFRLENBQUNELE1BQVc7WUFDNUJILE9BQU8sQ0FBQ0csSUFBSSxHQUFHTCxNQUFNLENBQUNLLElBQUk7UUFDNUI7SUFDRjtJQUNBLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LnRzP2Y2ZDUiXSwibmFtZXMiOlsib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNENnQkEsUUFBTTtlQUFOQTs7SUExQ0FDLHdCQUFzQjtlQUF0QkE7O0lBNEJBQyx3QkFBc0I7ZUFBdEJBOzs7QUE1QlQsU0FBU0QsdUJBQ2RFLFlBQTZCO0lBRTdCLE1BQU1DLFFBQXdCLENBQUM7SUFDL0JELGFBQWFFLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUMzQixJQUFJLE9BQU9ILEtBQUssQ0FBQ0csSUFBSSxLQUFLLGFBQWE7WUFDckNILEtBQUssQ0FBQ0csSUFBSSxHQUFHRDtRQUNmLE9BQU8sSUFBSUUsTUFBTUMsT0FBTyxDQUFDTCxLQUFLLENBQUNHLElBQUksR0FBRztZQUNsQ0gsS0FBSyxDQUFDRyxJQUFJLENBQWNHLElBQUksQ0FBQ0o7UUFDakMsT0FBTztZQUNMRixLQUFLLENBQUNHLElBQUksR0FBRztnQkFBQ0gsS0FBSyxDQUFDRyxJQUFJO2dCQUFZRDthQUFNO1FBQzVDO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsU0FBU08sdUJBQXVCQyxLQUFjO0lBQzVDLElBQ0UsT0FBT0EsVUFBVSxZQUNoQixPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFDckMsT0FBT0EsVUFBVSxXQUNqQjtRQUNBLE9BQU9FLE9BQU9GO0lBQ2hCLE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVPLFNBQVNWLHVCQUNkYSxRQUF3QjtJQUV4QixNQUFNQyxTQUFTLElBQUlDO0lBQ25CQyxPQUFPQyxPQUFPLENBQUNKLFVBQVVWLE9BQU8sQ0FBQyxDQUFBTztZQUFDLENBQUNMLEtBQUtELE1BQU0sR0FBQU07UUFDNUMsSUFBSUosTUFBTUMsT0FBTyxDQUFDSCxRQUFRO1lBQ3hCQSxNQUFNRCxPQUFPLENBQUMsQ0FBQ2UsT0FBU0osT0FBT0ssTUFBTSxDQUFDZCxLQUFLSSx1QkFBdUJTO1FBQ3BFLE9BQU87WUFDTEosT0FBT00sR0FBRyxDQUFDZixLQUFLSSx1QkFBdUJMO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPVTtBQUNUO0FBRU8sU0FBU2hCLE9BQ2R1QixNQUF1QjtJQUN2QixRQUFBQyxPQUFBQyxVQUFBQyxNQUFBLEVBQUFDLG1CQUFBLElBQUFuQixNQUFBZ0IsT0FBQSxJQUFBQSxPQUFBLFFBQUFJLE9BQUEsR0FBQUEsT0FBQUosTUFBQUksT0FBQTtRQUFHRCxnQkFBQUEsQ0FBSEMsT0FBQSxLQUFBSCxTQUFBLENBQUFHLEtBQXNDOztJQUV0Q0QsaUJBQWlCdEIsT0FBTyxDQUFDLENBQUNGO1FBQ3hCSyxNQUFNcUIsSUFBSSxDQUFDMUIsYUFBYTJCLElBQUksSUFBSXpCLE9BQU8sQ0FBQyxDQUFDRSxNQUFRZ0IsT0FBT1EsTUFBTSxDQUFDeEI7UUFDL0RKLGFBQWFFLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQyxNQUFRZ0IsT0FBT0YsTUFBTSxDQUFDZCxLQUFLRDtJQUMxRDtJQUNBLE9BQU9pQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHM/NzRkMyJdLCJuYW1lcyI6WyJhc3NpZ24iLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsInRhcmdldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQVdnQkE7OztlQUFBQTs7O21DQVZZO0FBVXJCLFNBQVNBLGdCQUFnQkMsS0FBMEI7SUFBMUIsTUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQWMsR0FBMUJGO0lBQzlCLE9BQU8sQ0FBQ0c7UUFDTixNQUFNQyxhQUFhSCxHQUFHSSxJQUFJLENBQUNGO1FBQzNCLElBQUksQ0FBQ0MsWUFBWTtZQUNmLE9BQU87UUFDVDtRQUVBLE1BQU1FLFNBQVMsQ0FBQ047WUFDZCxJQUFJO2dCQUNGLE9BQU9PLG1CQUFtQlA7WUFDNUIsRUFBRSxPQUFPUSxHQUFHO2dCQUNWLE1BQU0sSUFBSUMsT0FBQUEsV0FBVyxDQUFDO1lBQ3hCO1FBQ0Y7UUFDQSxNQUFNQyxTQUFxRCxDQUFDO1FBRTVEQyxPQUFPQyxJQUFJLENBQUNWLFFBQVFXLE9BQU8sQ0FBQyxDQUFDQztZQUMzQixNQUFNQyxJQUFJYixNQUFNLENBQUNZLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVosVUFBVSxDQUFDVyxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDbkJSLE1BQU0sQ0FBQ0ksU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUMxQkgsRUFBRUksS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQyxDQUFDQyxRQUFVaEIsT0FBT2dCLFVBQ25DUCxFQUFFUSxNQUFNLEdBQ1I7b0JBQUNqQixPQUFPVTtpQkFBRyxHQUNYVixPQUFPVTtZQUNiO1FBQ0Y7UUFDQSxPQUFPTjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzP2M1MDIiXSwibmFtZXMiOlsiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW0iLCJyZSIsImdyb3VwcyIsInBhdGhuYW1lIiwicm91dGVNYXRjaCIsImV4ZWMiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJfIiwiRGVjb2RlRXJyb3IiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInNsdWdOYW1lIiwiZyIsIm0iLCJwb3MiLCJ1bmRlZmluZWQiLCJpbmRleE9mIiwic3BsaXQiLCJtYXAiLCJlbnRyeSIsInJlcGVhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getRouteRegex: function() {\n        return getRouteRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBMk5nQkEseUJBQXVCO2VBQXZCQTs7SUFoQkFDLG9CQUFrQjtlQUFsQkE7O0lBbklBQyxlQUFhO2VBQWJBOzs7Z0RBeEUyQjswQ0FDUjtpREFDQztBQUVwQyxNQUFNQywwQkFBMEI7QUFDaEMsTUFBTUMsa0NBQWtDO0FBYXhDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxlQUFlQyxLQUFhO0lBQ25DLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNaRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzFCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDVkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3RCO0lBQ0EsT0FBTztRQUFFRSxLQUFLTjtRQUFPSztRQUFRSjtJQUFTO0FBQ3hDO0FBRUEsU0FBU00scUJBQXFCQyxLQUFhO0lBQ3pDLE1BQU1DLFdBQVdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQ0YsT0FBT0osS0FBSyxDQUFDLEdBQUdPLEtBQUssQ0FBQztJQUMzRCxNQUFNQyxTQUF5QyxDQUFDO0lBQ2hELElBQUlDLGFBQWE7SUFDakIsT0FBTztRQUNMQyxvQkFBb0JMLFNBQ2pCTSxHQUFHLENBQUMsQ0FBQ0M7WUFDSixNQUFNQyxjQUFjQyxvQkFBQUEsMEJBQTBCLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUNuREosUUFBUWQsVUFBVSxDQUFDa0I7WUFFckIsTUFBTUMsZUFBZUwsUUFBUU0sS0FBSyxDQUFDLHVCQUF1Qix1QkFBdUI7O1lBRWpGLElBQUlMLGVBQWVJLGNBQWM7Z0JBQy9CLE1BQU0sRUFBRWYs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TSxFQUFFN0Msa0JBQWtCLEVBQUUsR0FBR1AscUJBQXFCbUI7SUFDcEQsTUFBTSxFQUFFa0MsV0FBVyxJQUFJLEVBQUUsR0FBR0Q7SUFDNUIsSUFBSTdDLHVCQUF1QixLQUFLO1FBQzlCLElBQUkrQyxnQkFBZ0JELFdBQVcsT0FBTztRQUN0QyxPQUFPO1lBQ0xGLFlBQVksT0FBS0csZ0JBQWM7UUFDakM7SUFDRjtJQUVBLE1BQU0sRUFBRVYsdUJBQXVCLEVBQUUsR0FBR0YsMEJBQ2xDdkIsaUJBQ0E7SUFFRixJQUFJb0MsdUJBQXVCRixXQUFXLGVBQWU7SUFDckQsT0FBTztRQUNMRixZQUFZLE1BQUlQLDBCQUEwQlcsdUJBQXFCO0lBQ2pFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC50cz8yZDNhIl0sIm5hbWVzIjpbImdldE5hbWVkTWlkZGxld2FyZVJlZ2V4IiwiZ2V0TmFtZWRSb3V0ZVJlZ2V4IiwiZ2V0Um91dGVSZWdleCIsIk5FWFRfUVVFUllfUEFSQU1fUFJFRklYIiwiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsInBhcnNlUGFyYW1ldGVyIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJtYXJrZXJNYXRjaCIsIklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIiwiZmluZCIsIm0iLCJwYXJhbU1hdGNoZXMiLCJtYXRjaCIsInBvcyIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsImpvaW4iLCJub3JtYWxpemVkUm91dGUiLCJyZSIsIlJlZ0V4cCIsImJ1aWxkR2V0U2FmZVJvdXRlS2V5IiwiaSIsInJvdXRlS2V5IiwiaiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIk1hdGgiLCJmbG9vciIsImdldFNhZmVLZXlGcm9tU2VnbWVudCIsImludGVyY2VwdGlvbk1hcmtlciIsImdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5cyIsImtleVByZWZpeCIsImNsZWFuZWRLZXkiLCJyZXBsYWNlIiwiaW52YWxpZEtleSIsImxlbmd0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnRlcmNlcHRpb25QcmVmaXgiLCJnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlIiwicHJlZml4Um91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJoYXNJbnRlcmNlcHRpb25NYXJrZXIiLCJzb21lIiwidXNlZE1hcmtlciIsInVuZGVmaW5lZCIsInByZWZpeFJvdXRlS2V5IiwicmVzdWx0IiwibmFtZWRSZWdleCIsIm9wdGlvbnMiLCJjYXRjaEFsbCIsImNhdGNoQWxsUmVnZXgiLCJjYXRjaEFsbEdyb3VwZWRSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQXFNZ0JBOzs7ZUFBQUE7OztBQXJNaEIsTUFBTUM7SUFPSkMsT0FBT0MsT0FBZSxFQUFRO1FBQzVCLElBQUksQ0FBQ0MsT0FBTyxDQUFDRCxRQUFRRSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDQyxVQUFVLEVBQUUsRUFBRTtJQUN2RDtJQUVBQyxTQUFtQjtRQUNqQixPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUNyQjtJQUVRQSxRQUFRQyxNQUFvQixFQUFZO1FBQWhDQSxJQUFBQSxXQUFBQSxLQUFBQSxHQUFBQSxTQUFpQjtRQUMvQixNQUFNQyxnQkFBZ0I7ZUFBSSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUFHLENBQUNDLElBQUk7UUFDcEQsSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQzFCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3BEO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzlCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3ZEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDdENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDekQ7UUFFQSxNQUFNRyxTQUFTVCxjQUNaVSxHQUFHLENBQUMsQ0FBQ0MsSUFBTSxJQUFJLENBQUNWLFFBQVEsQ0FBQ1csR0FBRyxDQUFDRCxHQUFJYixPQUFPLENBQUMsS0FBR0MsU0FBU1ksSUFBRSxNQUN2REUsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE9BQVM7bUJBQUlEO21CQUFTQzthQUFLLEVBQUUsRUFBRTtRQUVoRCxJQUFJLElBQUksQ0FBQ1gsUUFBUSxLQUFL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Q0FBQ3pCLFFBQVEsQ0FBQ3NDLEdBQUcsQ0FBQ2IsYUFBYSxJQUFJcEM7UUFDckM7UUFFQSxJQUFJLENBQUNXLFFBQVEsQ0FDVlcsR0FBRyxDQUFDYyxhQUNKakMsT0FBTyxDQUFDNkIsU0FBU0gsS0FBSyxDQUFDLElBQUlJLFdBQVdDO0lBQzNDOzthQWpNQVAsV0FBQUEsR0FBdUI7YUFDdkJoQixRQUFBQSxHQUFpQyxJQUFJdUM7YUFDckNwQyxRQUFBQSxHQUEwQjthQUMxQkcsWUFBQUEsR0FBOEI7YUFDOUJDLG9CQUFBQSxHQUFzQzs7QUE4THhDO0FBRU8sU0FBU25CLGdCQUNkb0QsZUFBc0M7SUFFdEMsa0ZBQWtGO0lBQ2xGLDRFQUE0RTtJQUM1RSwyQ0FBMkM7SUFFM0MseUVBQXlFO0lBQ3pFLDJCQUEyQjtJQUMzQixvQ0FBb0M7SUFDcEMsOEVBQThFO0lBQzlFLHdFQUF3RTtJQUN4RSxnSEFBZ0g7SUFDaEgsNEVBQTRFO0lBQzVFLE1BQU1DLE9BQU8sSUFBSXBEO0lBRWpCLDZGQUE2RjtJQUM3Rm1ELGdCQUFnQk4sT0FBTyxDQUFDLENBQUNRLFdBQWFELEtBQUtuRCxNQUFNLENBQUNvRDtJQUNsRCw0R0FBNEc7SUFDNUcsT0FBT0QsS0FBSzdDLE1BQU07QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLnRzPzg3YTUiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiVXJsTm9kZSIsImluc2VydCIsInVybFBhdGgiLCJfaW5zZXJ0Iiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwic21vb3NoIiwiX3Ntb29zaCIsInByZWZpeCIsImNoaWxkcmVuUGF0aHMiLCJjaGlsZHJlbiIsImtleXMiLCJzb3J0Iiwic2x1Z05hbWUiLCJzcGxpY2UiLCJpbmRleE9mIiwicmVzdFNsdWdOYW1lIiwib3B0aW9uYWxSZXN0U2x1Z05hbWUiLCJyb3V0ZXMiLCJtYXAiLCJjIiwiZ2V0IiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJwdXNoIiwicGxhY2Vob2xkZXIiLCJyIiwic2xpY2UiLCJFcnJvciIsInVuc2hpZnQiLCJ1cmxQYXRocyIsInNsdWdOYW1lcyIsImlzQ2F0Y2hBbGwiLCJsZW5ndGgiLCJuZXh0U2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNlZ21lbnROYW1lIiwiaXNPcHRpb25hbCIsInN1YnN0cmluZyIsImhhbmRsZVNsdWciLCJwcmV2aW91c1NsdWciLCJuZXh0U2x1ZyIsImZvckVhY2giLCJzbHVnIiwicmVwbGFjZSIsImhhcyIsInNldCIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvYWFBLGFBQVc7ZUFBWEE7O0lBb0JBQyx5QkFBdUI7ZUFBdkJBOztJQVBBQyxtQkFBaUI7ZUFBakJBOztJQVpBQyxnQkFBYztlQUFkQTs7SUFDQUMsbUJBQWlCO2VBQWpCQTs7SUFUQUMsSUFBRTtlQUFGQTs7SUFDQUMsSUFBRTtlQUFGQTs7SUFsWEFDLFlBQVU7ZUFBVkE7O0lBc1FHQyxVQUFRO2VBQVJBOztJQStCQUMsZ0JBQWM7ZUFBZEE7O0lBWEFDLG1CQUFpQjtlQUFqQkE7O0lBS0FDLFFBQU07ZUFBTkE7O0lBUEhDLGVBQWE7ZUFBYkE7O0lBbUJHQyxXQUFTO2VBQVRBOztJQWtCTUMscUJBQW1CO2VBQW5CQTs7SUFkTkMsMEJBQXdCO2VBQXhCQTs7SUErR0FDLGdCQUFjO2VBQWRBOzs7QUE5WlQsTUFBTVQsYUFBYTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFPO0FBc1E5RCxTQUFTQyxTQUNkUyxFQUFLO0lBRUwsSUFBSUMsT0FBTztJQUNYLElBQUlDO0lBRUosT0FBUTt5Q0FBSUMsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O1FBQ1YsSUFBSSxDQUFDRixNQUFNO1lBQ1RBLE9BQU87WUFDUEMsU0FBU0YsTUFBTUc7UUFDakI7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLE1BQU1FLHFCQUFxQjtBQUNwQixNQUFNVCxnQkFBZ0IsQ0FBQ1UsTUFBZ0JELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUUvRCxTQUFTWjtJQUNkLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFB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O0lBQ3JDVSxZQUFZQyxJQUFZLEVBQUVaLE9BQWUsQ0FBRTtRQUN6QyxLQUFLO1FBQ0wsSUFBSSxDQUFDQSxPQUFPLEdBQUcsMENBQXdDWSxPQUFLLE1BQUdaO0lBQ2pFO0FBQ0Y7QUFFTyxNQUFNakQsZ0NBQWdDa0Q7SUFFM0NVLGFBQWM7UUFDWixLQUFLO1FBQ0wsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNiLE9BQU8sR0FBSTtJQUNsQjtBQUNGO0FBV08sU0FBU2xDLGVBQWVnRCxLQUFZO0lBQ3pDLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQztRQUFFaEIsU0FBU2MsTUFBTWQsT0FBTztRQUFFaUIsT0FBT0gsTUFBTUcsS0FBSztJQUFDO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi91dGlscy50cz8xYmQ1Il0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../packages/overlayscrollbars-react/dist/overlayscrollbars-react.mjs":
/*!****************************************************************************!*\
  !*** ../packages/overlayscrollbars-react/dist/overlayscrollbars-react.mjs ***!
  \****************************************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OverlayScrollbarsComponent: function() { return /* binding */ g; },\n/* harmony export */   useOverlayScrollbars: function() { return /* binding */ F; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! overlayscrollbars */ \"(app-pages-browser)/../packages/overlayscrollbars/dist/overlayscrollbars.mjs\");\n\n\nconst S = ()=>{\n    if (false) {}\n    let l, o;\n    const t = window, c = typeof t.requestIdleCallback == \"function\", a = t.requestAnimationFrame, i = t.cancelAnimationFrame, r = c ? t.requestIdleCallback : a, u = c ? t.cancelIdleCallback : i, s = ()=>{\n        u(l), i(o);\n    };\n    return [\n        (n, e)=>{\n            s(), l = r(c ? ()=>{\n                s(), o = a(n);\n            } : n, typeof e == \"object\" ? e : {\n                timeout: 2233\n            });\n        },\n        s\n    ];\n}, F = (l)=>{\n    const { options: o, events: t, defer: c } = l || {}, [a, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(S, []), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(c), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(o), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        u.current = c;\n    }, [\n        c\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current: e } = r;\n        s.current = o, overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__.OverlayScrollbars.valid(e) && e.options(o || {}, !0);\n    }, [\n        o\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current: e } = r;\n        n.current = t, overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__.OverlayScrollbars.valid(e) && e.on(t || {}, !0);\n    }, [\n        t\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>()=>{\n            var e;\n            i(), (e = r.current) == null || e.destroy();\n        }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            (e)=>{\n                const y = r.current;\n                if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__.OverlayScrollbars.valid(y)) return;\n                const d = s.current, b = n.current, m = u.current, p = ()=>r.current = (0,overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__.OverlayScrollbars)(e, d || {}, b || {});\n                m ? a(p, m) : p();\n            },\n            ()=>r.current\n        ], []);\n}, q = (l, o)=>{\n    const { element: t = \"div\", options: c, events: a, defer: i, children: r, ...u } = l, s = t, n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [y, d] = F({\n        options: c,\n        events: a,\n        defer: i\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current: b } = n, { current: m } = e;\n        if (!b) return;\n        const p = b;\n        return y(t === \"body\" ? {\n            target: p,\n            cancel: {\n                body: null\n            }\n        } : {\n            target: p,\n            elements: {\n                viewport: m,\n                content: m\n            }\n        }), ()=>{\n            var R;\n            return (R = d()) == null ? void 0 : R.destroy();\n        };\n    }, [\n        y,\n        d,\n        t\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(o, ()=>({\n            osInstance: d,\n            getElement: ()=>n.current\n        }), [\n        d\n    ]), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(s, {\n        \"data-overlayscrollbars-initialize\": \"\",\n        ref: n,\n        ...u\n    }, t === \"body\" ? r : /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        \"data-overlayscrollbars-contents\": \"\",\n        ref: e\n    }, r));\n}, g = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(q);\n //# sourceMappingURL=overlayscrollbars-react.mjs.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9wYWNrYWdlcy9vdmVybGF5c2Nyb2xsYmFycy1yZWFjdC9kaXN0L292ZXJsYXlzY3JvbGxiYXJzLXJlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUE2QkEsTUFBTUEsSUFBYztJQUVkLFNBQWtCLEVBQWEsRUFJZjtJQUloQixJQUFBRSxHQUNBQztJQUNKLE1BQU1DLElBQU1DLFFBQ05DLElBQWdCLE9BQU9GLEVBQUlHLG1CQUFBLElBQXdCLFlBQ25EQyxJQUFNSixFQUFJSyxxQkFBQSxFQUNWQyxJQUFNTixFQUFJTyxvQkFBQSxFQUNWQyxJQUFRTixJQUFnQkYsRUFBSUcsbUJBQUEsR0FBc0JDLEdBQ2xESyxJQUFRUCxJQUFnQkYsRUFBSVUsa0JBQUEsR0FBcUJKLEdBQ2pESyxJQUFRO1FBQ1pGLEVBQU1YLElBQ05RLEVBQUlQO0lBQ047SUFFTztRQUNMLENBQUNhLEdBQVVDO1lBQ0hGLEtBQ0diLElBQUFVLEVBQ1BOLElBQ0k7Z0JBQ1FTLEtBRU5aLElBQVFLLEVBQUlRO1lBQVEsSUFFdEJBLEdBQ0osT0FBT0MsS0FBWSxXQUFXQSxJQUFVO2dCQUFFQyxTQUFTO1lBQUs7UUFFNUQ7UUFDQUg7S0FDRjtBQUNGLEdBU2FJLElBQXVCLENBQ2xDQztJQUVBLE1BQU0sRUFBRUgsU0FBQUEsQ0FBQUEsRUFBU0ksUUFBQUEsQ0FBQUEsRUFBUUMsT0FBQUEsQ0FBQUEsRUFBTSxHQUFJRixLQUFVLENBQUMsR0FDeEMsQ0FBQ0csR0FBY0MsRUFBVyxHQUFJQyw4Q0FBQUEsQ0FBZXpCLEdBQWEsRUFBRSxHQUM1RDBCLElBQWNDLDZDQUFBQSxDQUFpRCxPQUMvREMsSUFBV0QsNkNBQUFBLENBQU9MLElBQ2xCTyxJQUFhRiw2Q0FBQUEsQ0FBT1YsSUFDcEJhLElBQVlILDZDQUFBQSxDQUFPTjtJQUV6QixPQUFBVSxnREFBQUEsQ0FBVTtRQUNSSCxFQUFTSSxPQUFBLEdBQVVWO0lBQUEsR0FDbEI7UUFBQ0E7S0FBTSxHQUVWUyxnREFBQUEsQ0FBVTtRQUNGLFFBQUVDLFNBQVNDLENBQUFBLEVBQUEsR0FBYVA7UUFFOUJHLEVBQVdHLE9BQUEsR0FBVWYsR0FFakJpQixnRUFBQUEsQ0FBa0JDLEtBQUEsQ0FBTUYsTUFDMUJBLEVBQVNoQixPQUFBLENBQVFBLEtBQVcsSUFBSTtJQUNsQyxHQUNDO1FBQUNBO0tBQVEsR0FFWmMsZ0RBQUFBLENBQVU7UUFDRixRQUFFQyxTQUFTQyxDQUFBQSxFQUFBLEdBQWFQO1FBRTlCSSxFQUFVRSxPQUFBLEdBQVVYLEdBRWhCYSxnRUFBQUEsQ0FBa0JDLEtBQUEsQ0FBTUYsTUFDMUJBLEVBQVNHLEVBQUEsQ0FBR2YsS0FBVSxJQUFJO0lBQzVCLEdBQ0M7UUFBQ0E7S0FBTyxHQUVYVSxnREFBQUEsQ0FDRSxJQUFNOztZQUNRUCxLQUFBLENBQ1phLElBQUFYLEVBQVlNLE9BQUEsS0FBWixRQUFBSyxFQUFxQkMsT0FBQTtRQUN2QixHQUNBLEtBR0tiLDhDQUFBQSxDQUNMLElBQU07WUFDSixDQUFDYztnQkFFQyxNQUFNQyxJQUFrQmQsRUFBWU0sT0FBQTtnQkFDaEMsSUFBQUUsZ0VBQUFBLENBQWtCQyxLQUFBLENBQU1LLElBQzFCO2dCQUdGLE1BQU1DLElBQWNaLEVBQVdHLE9BQUEsRUFDekJVLElBQWFaLEVBQVVFLE9BQUEsRUFDdkJXLElBQVlmLEVBQVNJLE9BQUEsRUFDckJZLElBQU8sSUFDVmxCLEVBQVlNLE9BQUEsR0FBVUUsb0VBQUFBLENBQWtCSyxHQUFRRSxLQUFlLElBQUlDLEtBQWM7Z0JBRWhGQyxJQUNGcEIsRUFBYXFCLEdBQU1ELEtBRWRDO1lBRVQ7WUFDQSxJQUFNbEIsRUFBWU0sT0FBQTtTQUNwQixFQUNBO0FBRUosR0MxR01hLElBQTZCLENBQ2pDQyxHQUNBQztJQUVNLFFBQUVDLFNBQUFBLElBQVUsT0FBTy9CLFNBQUFBLENBQUFBLEVBQVNJLFFBQUFBLENBQUFBLEVBQVFDLE9BQUFBLENBQUFBLEVBQU8yQixVQUFBQSxDQUFBQSxFQUFVLEdBQUdDLEdBQUEsR0FBVUosR0FDbEVLLElBQU1ILEdBQ05JLElBQWF6Qiw2Q0FBQUEsQ0FBc0IsT0FDbkMwQixJQUFjMUIsNkNBQUFBLENBQXVCLE9BQ3JDLENBQUMyQixHQUFZQyxFQUFVLEdBQUlwQyxFQUFxQjtRQUFFRixTQUFBQTtRQUFTSSxRQUFBQTtRQUFRQyxPQUFBQTtJQUFBQTtJQUV6RSxPQUFBUyxnREFBQUEsQ0FBVTtRQUNGLFFBQUVDLFNBQVN3QixDQUFBQSxFQUFBLEdBQVFKLEdBQ25CLEVBQUVwQixTQUFTeUIsQ0FBQUEsRUFBQSxHQUFnQko7UUFHakMsSUFBSSxDQUFDRyxHQUNIO1FBSUYsTUFBTWpCLElBQVNpQjtRQUVmLE9BQUFGLEVBQ0VOLE1BQVksU0FDUjtZQUNFVCxRQUFBQTtZQUNBbUIsUUFBUTtnQkFDTkMsTUFBTTtZQUFBO1FBQ1IsSUFFRjtZQUNFcEIsUUFBQUE7WUFDQXFCLFVBQVU7Z0JBQ1JDLFVBQVVKO2dCQUNWSyxTQUFTTDtZQUFBO1FBQ1gsSUFJRDs7WUFBTSxRQUFBcEIsSUFBQWtCLEdBQVcsS0FBWCxnQkFBQWxCLEVBQWNDLE9BQUE7UUFBQTtJQUMxQjtRQUFDZ0I7UUFBWUM7UUFBWVA7S0FBUSxHQUVwQ2UsMERBQUFBLENBQW9CaEIsR0FBSyxJQUNoQjtZQUNMUSxZQUFBQTtZQUNBUyxZQUFZLElBQU1aLEVBQVdwQixPQUFBO1FBQy9CLElBQ0M7UUFBQ3VCO0tBQVcsaUNBQUFVLGdEQUFBLENBR1pkLEdBQUk7UUFBQSxxQ0FBa0M7UUFBR0osS0FBS0s7UUFBYSxHQUFHRixDQUFBQTtJQUM1RCxHQUFBRixNQUFZLFNBQ1hDLElBQUFBLGFBQUFBLGlCQUFBQSxnREFBQUEsQ0FFQyxPQUFJO1FBQUEsbUNBQWdDO1FBQUdGLEtBQUtNO0lBQUFBLEdBQzFDSjtBQUtYLEdBRU1rQixrQkFBeUNDLGlEQUFBQSxDQUFXdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy91c2VPdmVybGF5U2Nyb2xsYmFycy50cz80NDVlIiwid2VicGFjazovL19OX0UvLi4vc3JjL092ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50LnRzeD82NjM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBPdmVybGF5U2Nyb2xsYmFycyB9IGZyb20gJ292ZXJsYXlzY3JvbGxiYXJzJztcclxuaW1wb3J0IHR5cGUgeyBJbml0aWFsaXphdGlvblRhcmdldCB9IGZyb20gJ292ZXJsYXlzY3JvbGxiYXJzJztcclxuaW1wb3J0IHR5cGUge1xyXG4gIE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50UHJvcHMsXHJcbiAgT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRSZWYsXHJcbn0gZnJvbSAnLi9PdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU92ZXJsYXlTY3JvbGxiYXJzUGFyYW1zIHtcclxuICAvKiogT3ZlcmxheVNjcm9sbGJhcnMgb3B0aW9ucy4gKi9cclxuICBvcHRpb25zPzogT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRQcm9wc1snb3B0aW9ucyddO1xyXG4gIC8qKiBPdmVybGF5U2Nyb2xsYmFycyBldmVudHMuICovXHJcbiAgZXZlbnRzPzogT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRQcm9wc1snZXZlbnRzJ107XHJcbiAgLyoqIFdoZXRoZXIgdG8gZGVmZXIgdGhlIGluaXRpYWxpemF0aW9uIHRvIGEgcG9pbnQgaW4gdGltZSB3aGVuIHRoZSBicm93c2VyIGlzIGlkbGUuIChvciB0byB0aGUgbmV4dCBmcmFtZSBpZiBgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2tgIGlzIG5vdCBzdXBwb3J0ZWQpICovXHJcbiAgZGVmZXI/OiBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudFByb3BzWydkZWZlciddO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VPdmVybGF5U2Nyb2xsYmFyc0luaXRpYWxpemF0aW9uID0gKHRhcmdldDogSW5pdGlhbGl6YXRpb25UYXJnZXQpID0+IHZvaWQ7XHJcblxyXG5leHBvcnQgdHlwZSBVc2VPdmVybGF5U2Nyb2xsYmFyc0luc3RhbmNlID0gKCkgPT4gUmV0dXJuVHlwZTxcclxuICBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudFJlZlsnb3NJbnN0YW5jZSddXHJcbj47XHJcblxyXG50eXBlIERlZmVyID0gW1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgcmVxdWVzdERlZmVyOiAoY2FsbGJhY2s6ICgpID0+IGFueSwgb3B0aW9ucz86IE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50UHJvcHNbJ2RlZmVyJ10pID0+IHZvaWQsXHJcbiAgY2FuY2VsRGVmZXI6ICgpID0+IHZvaWQsXHJcbl07XHJcblxyXG5jb25zdCBjcmVhdGVEZWZlciA9ICgpOiBEZWZlciA9PiB7XHJcbiAgLyogYzggaWdub3JlIHN0YXJ0ICovXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBtb2NrIHNzciBjYWxscyB3aXRoIFwibm9vcFwiXHJcblxyXG4gICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xyXG4gICAgcmV0dXJuIFtub29wLCBub29wXTtcclxuICB9XHJcbiAgLyogYzggaWdub3JlIGVuZCAqL1xyXG5cclxuICBsZXQgaWRsZUlkOiBudW1iZXI7XHJcbiAgbGV0IHJhZklkOiBudW1iZXI7XHJcbiAgY29uc3Qgd25kID0gd2luZG93O1xyXG4gIGNvbnN0IGlkbGVTdXBwb3J0ZWQgPSB0eXBlb2Ygd25kLnJlcXVlc3RJZGxlQ2FsbGJhY2sgPT09ICdmdW5jdGlvbic7XHJcbiAgY29uc3QgckFGID0gd25kLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuICBjb25zdCBjQUYgPSB3bmQuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcbiAgY29uc3QgcklkbGUgPSBpZGxlU3VwcG9ydGVkID8gd25kLnJlcXVlc3RJZGxlQ2FsbGJhY2sgOiByQUY7XHJcbiAgY29uc3QgY0lkbGUgPSBpZGxlU3VwcG9ydGVkID8gd25kLmNhbmNlbElkbGVDYWxsYmFjayA6IGNBRjtcclxuICBjb25zdCBjbGVhciA9ICgpID0+IHtcclxuICAgIGNJZGxlKGlkbGVJZCk7XHJcbiAgICBjQUYocmFmSWQpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBbXHJcbiAgICAoY2FsbGJhY2ssIG9wdGlvbnMpID0+IHtcclxuICAgICAgY2xlYXIoKTtcclxuICAgICAgaWRsZUlkID0gcklkbGUoXHJcbiAgICAgICAgaWRsZVN1cHBvcnRlZFxyXG4gICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICAvLyBpbnNpZGUgaWRsZSBpdHMgYmVzdCBwcmFjdGljZSB0byB1c2UgckFGIHRvIGNoYW5nZSBET00gZm9yIGJlc3QgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICByYWZJZCA9IHJBRihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIDogY2FsbGJhY2ssXHJcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnID8gb3B0aW9ucyA6IHsgdGltZW91dDogMjIzMyB9XHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgY2xlYXIsXHJcbiAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIb29rIGZvciBhZHZhbmNlZCB1c2FnZSBvZiBPdmVybGF5U2Nyb2xsYmFycy4gKFdoZW4gdGhlIE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50IGlzIG5vdCBlbm91Z2gpXHJcbiAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBmb3IgY3VzdG9taXphdGlvbi5cclxuICogQHJldHVybnMgQSB0dXBsZSB3aXRoIHR3byB2YWx1ZXM6XHJcbiAqIFRoZSBmaXJzdCB2YWx1ZSBpcyB0aGUgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24sIGl0IHRha2VzIG9uZSBhcmd1bWVudCB3aGljaCBpcyB0aGUgYEluaXRpYWxpemF0aW9uVGFyZ2V0YC5cclxuICogVGhlIHNlY29uZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIGN1cnJlbnQgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2Ugb3IgYG51bGxgIGlmIG5vdCBpbml0aWFsaXplZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCB1c2VPdmVybGF5U2Nyb2xsYmFycyA9IChcclxuICBwYXJhbXM/OiBVc2VPdmVybGF5U2Nyb2xsYmFyc1BhcmFtc1xyXG4pOiBbVXNlT3ZlcmxheVNjcm9sbGJhcnNJbml0aWFsaXphdGlvbiwgVXNlT3ZlcmxheVNjcm9sbGJhcnNJbnN0YW5jZV0gPT4ge1xyXG4gIGNvbnN0IHsgb3B0aW9ucywgZXZlbnRzLCBkZWZlciB9ID0gcGFyYW1zIHx8IHt9O1xyXG4gIGNvbnN0IFtyZXF1ZXN0RGVmZXIsIGNhbmNlbERlZmVyXSA9IHVzZU1lbW88RGVmZXI+KGNyZWF0ZURlZmVyLCBbXSk7XHJcbiAgY29uc3QgaW5zdGFuY2VSZWYgPSB1c2VSZWY8UmV0dXJuVHlwZTxVc2VPdmVybGF5U2Nyb2xsYmFyc0luc3RhbmNlPj4obnVsbCk7XHJcbiAgY29uc3QgZGVmZXJSZWYgPSB1c2VSZWYoZGVmZXIpO1xyXG4gIGNvbnN0IG9wdGlvbnNSZWYgPSB1c2VSZWYob3B0aW9ucyk7XHJcbiAgY29uc3QgZXZlbnRzUmVmID0gdXNlUmVmKGV2ZW50cyk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBkZWZlclJlZi5jdXJyZW50ID0gZGVmZXI7XHJcbiAgfSwgW2RlZmVyXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB7IGN1cnJlbnQ6IGluc3RhbmNlIH0gPSBpbnN0YW5jZVJlZjtcclxuXHJcbiAgICBvcHRpb25zUmVmLmN1cnJlbnQgPSBvcHRpb25zO1xyXG5cclxuICAgIGlmIChPdmVybGF5U2Nyb2xsYmFycy52YWxpZChpbnN0YW5jZSkpIHtcclxuICAgICAgaW5zdGFuY2Uub3B0aW9ucyhvcHRpb25zIHx8IHt9LCB0cnVlKTtcclxuICAgIH1cclxuICB9LCBbb3B0aW9uc10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgeyBjdXJyZW50OiBpbnN0YW5jZSB9ID0gaW5zdGFuY2VSZWY7XHJcblxyXG4gICAgZXZlbnRzUmVmLmN1cnJlbnQgPSBldmVudHM7XHJcblxyXG4gICAgaWYgKE92ZXJsYXlTY3JvbGxiYXJzLnZhbGlkKGluc3RhbmNlKSkge1xyXG4gICAgICBpbnN0YW5jZS5vbihldmVudHMgfHwge30sIHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIFtldmVudHNdKTtcclxuXHJcbiAgdXNlRWZmZWN0KFxyXG4gICAgKCkgPT4gKCkgPT4ge1xyXG4gICAgICBjYW5jZWxEZWZlcigpO1xyXG4gICAgICBpbnN0YW5jZVJlZi5jdXJyZW50Py5kZXN0cm95KCk7XHJcbiAgICB9LFxyXG4gICAgW11cclxuICApO1xyXG5cclxuICByZXR1cm4gdXNlTWVtbzxbVXNlT3ZlcmxheVNjcm9sbGJhcnNJbml0aWFsaXphdGlvbiwgVXNlT3ZlcmxheVNjcm9sbGJhcnNJbnN0YW5jZV0+KFxyXG4gICAgKCkgPT4gW1xyXG4gICAgICAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBpbml0aWFsaXplZCBkbyBub3RoaW5nXHJcbiAgICAgICAgY29uc3QgcHJlc2VudEluc3RhbmNlID0gaW5zdGFuY2VSZWYuY3VycmVudDtcclxuICAgICAgICBpZiAoT3ZlcmxheVNjcm9sbGJhcnMudmFsaWQocHJlc2VudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY3Vyck9wdGlvbnMgPSBvcHRpb25zUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgY3VyckV2ZW50cyA9IGV2ZW50c1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGN1cnJEZWZlciA9IGRlZmVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgaW5pdCA9ICgpID0+XHJcbiAgICAgICAgICAoaW5zdGFuY2VSZWYuY3VycmVudCA9IE92ZXJsYXlTY3JvbGxiYXJzKHRhcmdldCwgY3Vyck9wdGlvbnMgfHwge30sIGN1cnJFdmVudHMgfHwge30pKTtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJEZWZlcikge1xyXG4gICAgICAgICAgcmVxdWVzdERlZmVyKGluaXQsIGN1cnJEZWZlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgICgpID0+IGluc3RhbmNlUmVmLmN1cnJlbnQsXHJcbiAgICBdLFxyXG4gICAgW11cclxuICApO1xyXG59O1xyXG4iLCIvLyBrZWVwIFJlYWN0IGluIHRoZSBzY29wZSB0byBub3QgYnJlYWsgdXNlcnMgd2hpY2ggYXJlbid0IHVzaW5nIHJlYWN0LWpzeCBydW50aW1lIChyZWFjdCBwcmUgdjE3KVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHR5cGUgeyBPdmVybGF5U2Nyb2xsYmFycywgUGFydGlhbE9wdGlvbnMsIEV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnb3ZlcmxheXNjcm9sbGJhcnMnO1xyXG5cclxuaW1wb3J0IHR5cGUge1xyXG4gIENvbXBvbmVudFByb3BzV2l0aG91dFJlZixcclxuICBFbGVtZW50UmVmLFxyXG4gIEVsZW1lbnRUeXBlLFxyXG4gIEZvcndhcmRlZFJlZixcclxuICBSZWFjdEVsZW1lbnQsXHJcbn0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VPdmVybGF5U2Nyb2xsYmFycyB9IGZyb20gJy4vdXNlT3ZlcmxheVNjcm9sbGJhcnMnO1xyXG5cclxudHlwZSBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudEJhc2VQcm9wczxUIGV4dGVuZHMgRWxlbWVudFR5cGUgPSAnZGl2Jz4gPVxyXG4gIENvbXBvbmVudFByb3BzV2l0aG91dFJlZjxUPiAmIHtcclxuICAgIC8qKiBUYWcgb2YgdGhlIHJvb3QgZWxlbWVudC4gKi9cclxuICAgIGVsZW1lbnQ/OiBUO1xyXG4gICAgLyoqIE92ZXJsYXlTY3JvbGxiYXJzIG9wdGlvbnMuICovXHJcbiAgICBvcHRpb25zPzogUGFydGlhbE9wdGlvbnMgfCBmYWxzZSB8IG51bGw7XHJcbiAgICAvKiogT3ZlcmxheVNjcm9sbGJhcnMgZXZlbnRzLiAqL1xyXG4gICAgZXZlbnRzPzogRXZlbnRMaXN0ZW5lcnMgfCBmYWxzZSB8IG51bGw7XHJcbiAgICAvKiogV2hldGhlciB0byBkZWZlciB0aGUgaW5pdGlhbGl6YXRpb24gdG8gYSBwb2ludCBpbiB0aW1lIHdoZW4gdGhlIGJyb3dzZXIgaXMgaWRsZS4gKG9yIHRvIHRoZSBuZXh0IGZyYW1lIGlmIGB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFja2AgaXMgbm90IHN1cHBvcnRlZCkgKi9cclxuICAgIGRlZmVyPzogYm9vbGVhbiB8IElkbGVSZXF1ZXN0T3B0aW9ucztcclxuICB9O1xyXG5cclxuZXhwb3J0IHR5cGUgT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRQcm9wczxUIGV4dGVuZHMgRWxlbWVudFR5cGUgPSAnZGl2Jz4gPVxyXG4gIE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50QmFzZVByb3BzPFQ+ICYge1xyXG4gICAgcmVmPzogRm9yd2FyZGVkUmVmPE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50UmVmPFQ+PjtcclxuICB9O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudFJlZjxUIGV4dGVuZHMgRWxlbWVudFR5cGUgPSAnZGl2Jz4ge1xyXG4gIC8qKiBSZXR1cm5zIHRoZSBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSBvciBudWxsIGlmIG5vdCBpbml0aWFsaXplZC4gKi9cclxuICBvc0luc3RhbmNlKCk6IE92ZXJsYXlTY3JvbGxiYXJzIHwgbnVsbDtcclxuICAvKiogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50LiAqL1xyXG4gIGdldEVsZW1lbnQoKTogRWxlbWVudFJlZjxUPiB8IG51bGw7XHJcbn1cclxuXHJcbmNvbnN0IE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50ID0gPFQgZXh0ZW5kcyBFbGVtZW50VHlwZSA9ICdkaXYnPihcclxuICBwcm9wczogVCBleHRlbmRzIEVsZW1lbnRUeXBlID8gT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRCYXNlUHJvcHM8VD4gOiBuZXZlcixcclxuICByZWY6IEZvcndhcmRlZFJlZjxPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudFJlZjxUPj5cclxuKTogUmVhY3RFbGVtZW50IHwgbnVsbCA9PiB7XHJcbiAgY29uc3QgeyBlbGVtZW50ID0gJ2RpdicsIG9wdGlvbnMsIGV2ZW50cywgZGVmZXIsIGNoaWxkcmVuLCAuLi5vdGhlciB9ID0gcHJvcHM7XHJcbiAgY29uc3QgVGFnID0gZWxlbWVudDtcclxuICBjb25zdCBlbGVtZW50UmVmID0gdXNlUmVmPEVsZW1lbnRSZWY8VD4+KG51bGwpO1xyXG4gIGNvbnN0IGNoaWxkcmVuUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBbaW5pdGlhbGl6ZSwgb3NJbnN0YW5jZV0gPSB1c2VPdmVybGF5U2Nyb2xsYmFycyh7IG9wdGlvbnMsIGV2ZW50cywgZGVmZXIgfSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB7IGN1cnJlbnQ6IGVsbSB9ID0gZWxlbWVudFJlZjtcclxuICAgIGNvbnN0IHsgY3VycmVudDogY29udGVudHNFbG0gfSA9IGNoaWxkcmVuUmVmO1xyXG5cclxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xyXG4gICAgaWYgKCFlbG0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogYzggaWdub3JlIGVuZCAqL1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGVsbSBhcyB1bmtub3duIGFzIEhUTUxFbGVtZW50O1xyXG5cclxuICAgIGluaXRpYWxpemUoXHJcbiAgICAgIGVsZW1lbnQgPT09ICdib2R5J1xyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgIGNhbmNlbDoge1xyXG4gICAgICAgICAgICAgIGJvZHk6IG51bGwsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgZWxlbWVudHM6IHtcclxuICAgICAgICAgICAgICB2aWV3cG9ydDogY29udGVudHNFbG0sXHJcbiAgICAgICAgICAgICAgY29udGVudDogY29udGVudHNFbG0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiBvc0luc3RhbmNlKCk/LmRlc3Ryb3koKTtcclxuICB9LCBbaW5pdGlhbGl6ZSwgb3NJbnN0YW5jZSwgZWxlbWVudF0pO1xyXG5cclxuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3NJbnN0YW5jZSxcclxuICAgICAgZ2V0RWxlbWVudDogKCkgPT4gZWxlbWVudFJlZi5jdXJyZW50LFxyXG4gICAgfTtcclxuICB9LCBbb3NJbnN0YW5jZV0pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFRhZyBkYXRhLW92ZXJsYXlzY3JvbGxiYXJzLWluaXRpYWxpemU9XCJcIiByZWY9e2VsZW1lbnRSZWZ9IHsuLi5vdGhlcn0+XHJcbiAgICAgIHtlbGVtZW50ID09PSAnYm9keScgPyAoXHJcbiAgICAgICAgY2hpbGRyZW5cclxuICAgICAgKSA6IChcclxuICAgICAgICA8ZGl2IGRhdGEtb3ZlcmxheXNjcm9sbGJhcnMtY29udGVudHM9XCJcIiByZWY9e2NoaWxkcmVuUmVmfT5cclxuICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKX1cclxuICAgIDwvVGFnPlxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudEZvcndhcmRlZFJlZiA9IGZvcndhcmRSZWYoT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnQpIGFzIDxcclxuICBUIGV4dGVuZHMgRWxlbWVudFR5cGUgPSAnZGl2JyxcclxuPihcclxuICBwcm9wczogT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRQcm9wczxUPlxyXG4pID0+IFJldHVyblR5cGU8dHlwZW9mIE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50PjtcclxuXHJcbmV4cG9ydCB7IE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50Rm9yd2FyZGVkUmVmIGFzIE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50IH07XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVEZWZlciIsIm5vb3AiLCJpZGxlSWQiLCJyYWZJZCIsInduZCIsIndpbmRvdyIsImlkbGVTdXBwb3J0ZWQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwickFGIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY0FGIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJySWRsZSIsImNJZGxlIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiY2xlYXIiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJ0aW1lb3V0IiwidXNlT3ZlcmxheVNjcm9sbGJhcnMiLCJwYXJhbXMiLCJldmVudHMiLCJkZWZlciIsInJlcXVlc3REZWZlciIsImNhbmNlbERlZmVyIiwidXNlTWVtbyIsImluc3RhbmNlUmVmIiwidXNlUmVmIiwiZGVmZXJSZWYiLCJvcHRpb25zUmVmIiwiZXZlbnRzUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImluc3RhbmNlIiwiT3ZlcmxheVNjcm9sbGJhcnMiLCJ2YWxpZCIsIm9uIiwiX2EiLCJkZXN0cm95IiwidGFyZ2V0IiwicHJlc2VudEluc3RhbmNlIiwiY3Vyck9wdGlvbnMiLCJjdXJyRXZlbnRzIiwiY3VyckRlZmVyIiwiaW5pdCIsIk92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50IiwicHJvcHMiLCJyZWYiLCJlbGVtZW50IiwiY2hpbGRyZW4iLCJvdGhlciIsIlRhZyIsImVsZW1lbnRSZWYiLCJjaGlsZHJlblJlZiIsImluaXRpYWxpemUiLCJvc0luc3RhbmNlIiwiZWxtIiwiY29udGVudHNFbG0iLCJjYW5jZWwiLCJib2R5IiwiZWxlbWVudHMiLCJ2aWV3cG9ydCIsImNvbnRlbnQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiZ2V0RWxlbWVudCIsInciLCJjcmVhdGVFbGVtZW50IiwiT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRGb3J3YXJkZWRSZWYiLCJmb3J3YXJkUmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../packages/overlayscrollbars-react/dist/overlayscrollbars-react.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../packages/overlayscrollbars/dist/overlayscrollbars.mjs":
/*!****************************************************************!*\
  !*** ../packages/overlayscrollbars/dist/overlayscrollbars.mjs ***!
  \****************************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClickScrollPlugin: function() { return /* binding */ zt; },\n/* harmony export */   OverlayScrollbars: function() { return /* binding */ OverlayScrollbars; },\n/* harmony export */   ScrollbarsHidingPlugin: function() { return /* binding */ Ht; },\n/* harmony export */   SizeObserverPlugin: function() { return /* binding */ $t; }\n/* harmony export */ });\n/*!\n * OverlayScrollbars\n * Version: 2.13.0\n *\n * Copyright (c) Rene Haas | KingSora.\n * https://github.com/KingSora\n *\n * Released under the MIT license.\n */ const createCache = (t, n)=>{\n    const { o: o, i: s, u: e } = t;\n    let c = o;\n    let r;\n    const cacheUpdateContextual = (t, n)=>{\n        const o = c;\n        const i = t;\n        const l = n || (s ? !s(o, i) : o !== i);\n        if (l || e) {\n            c = i;\n            r = o;\n        }\n        return [\n            c,\n            l,\n            r\n        ];\n    };\n    const cacheUpdateIsolated = (t)=>cacheUpdateContextual(n(c, r), t);\n    const getCurrentCache = (t)=>[\n            c,\n            !!t,\n            r\n        ];\n    return [\n        n ? cacheUpdateIsolated : cacheUpdateContextual,\n        getCurrentCache\n    ];\n};\nconst t =  true && typeof HTMLElement !== \"undefined\" && !!window.document;\nconst n = t ? window : {};\nconst o = Math.max;\nconst s = Math.min;\nconst e = Math.round;\nconst c = Math.abs;\nconst r = Math.sign;\nconst i = n.cancelAnimationFrame;\nconst l = n.requestAnimationFrame;\nconst a = n.setTimeout;\nconst u = n.clearTimeout;\nconst getApi = (t)=>typeof n[t] !== \"undefined\" ? n[t] : void 0;\nconst f = getApi(\"MutationObserver\");\nconst _ = getApi(\"IntersectionObserver\");\nconst d = getApi(\"ResizeObserver\");\nconst p = getApi(\"ScrollTimeline\");\nconst isUndefined = (t)=>t === void 0;\nconst isNull = (t)=>t === null;\nconst isNumber = (t)=>typeof t === \"number\";\nconst isString = (t)=>typeof t === \"string\";\nconst isBoolean = (t)=>typeof t === \"boolean\";\nconst isFunction = (t)=>typeof t === \"function\";\nconst isArray = (t)=>Array.isArray(t);\nconst isObject = (t)=>typeof t === \"object\" && !isArray(t) && !isNull(t);\nconst isArrayLike = (t)=>{\n    const n = !!t && t.length;\n    const o = isNumber(n) && n > -1 && n % 1 == 0;\n    return isArray(t) || !isFunction(t) && o ? n > 0 && isObject(t) ? n - 1 in t : true : false;\n};\nconst isPlainObject = (t)=>!!t && t.constructor === Object;\nconst isHTMLElement = (t)=>t instanceof HTMLElement;\nconst isElement = (t)=>t instanceof Element;\nconst animationCurrentTime = ()=>performance.now();\nconst animateNumber = (t, n, s, e, c)=>{\n    let r = 0;\n    const a = animationCurrentTime();\n    const u = o(0, s);\n    const frame = (s)=>{\n        const i = animationCurrentTime();\n        const f = i - a;\n        const _ = f >= u;\n        const d = s ? 1 : 1 - (o(0, a + u - i) / u || 0);\n        const p = (n - t) * (isFunction(c) ? c(d, d * u, 0, 1, u) : d) + t;\n        const v = _ || d === 1;\n        if (e) {\n            e(p, d, v);\n        }\n        r = v ? 0 : l(()=>frame());\n    };\n    frame();\n    return (t)=>{\n        i(r);\n        if (t) {\n            frame(t);\n        }\n    };\n};\nfunction each(t, n) {\n    if (isArrayLike(t)) {\n        for(let o = 0; o < t.length; o++){\n            if (n(t[o], o, t) === false) {\n                break;\n            }\n        }\n    } else if (t) {\n        each(Object.keys(t), (o)=>n(t[o], o, t));\n    }\n    return t;\n}\nconst inArray = (t, n)=>t.indexOf(n) >= 0;\nconst concat = (t, n)=>t.concat(n);\nconst push = (t, n, o)=>{\n    if (!isString(n) && isArrayLike(n)) {\n        Array.prototype.push.apply(t, n);\n    } else {\n        t.push(n);\n    }\n    return t;\n};\nconst from = (t)=>Array.from(t || []);\nconst createOrKeepArray = (t)=>{\n    if (isArray(t)) {\n        return t;\n    }\n    return !isString(t) && isArrayLike(t) ? from(t) : [\n        t\n    ];\n};\nconst isEmptyArray = (t)=>!!t && !t.length;\nconst deduplicateArray = (t)=>from(new Set(t));\nconst runEachAndClear = (t, n, o)=>{\n    const runFn = (t)=>t ? t.apply(void 0, n || []) : true;\n    each(t, runFn);\n    if (!o) {\n        t.length = 0;\n    }\n};\nconst v = \"paddingTop\";\nconst g = \"paddingRight\";\nconst h = \"paddingLeft\";\nconst b = \"paddingBottom\";\nconst w = \"marginLeft\";\nconst y = \"marginRight\";\nconst S = \"marginBottom\";\nconst m = \"overflowX\";\nconst O = \"overflowY\";\nconst C = \"width\";\nconst $ = \"height\";\nconst x = \"visible\";\nconst H = \"hidden\";\nconst E = \"scroll\";\nconst capitalizeFirstLetter = (t)=>{\n    const n = String(t || \"\");\n    return n ? n[0].toUpperCase() + n.slice(1) : \"\";\n};\nconst equal = (t, n, o, s)=>{\n    if (t && n) {\n        let s = true;\n        each(o, (o)=>{\n            const e = t[o];\n            const c = n[o];\n            if (e !== c) {\n                s = false;\n            }\n        });\n        return s;\n    }\n    return false;\n};\nconst equalWH = (t, n)=>equal(t, n, [\n        \"w\",\n        \"h\"\n    ]);\nconst equalXY = (t, n)=>equal(t, n, [\n        \"x\",\n        \"y\"\n    ]);\nconst equalTRBL = (t, n)=>equal(t, n, [\n        \"t\",\n        \"r\",\n        \"b\",\n        \"l\"\n    ]);\nconst bind = function(t) {\n    for(var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        n[_key - 1] = arguments[_key];\n    }\n    return t.bind(0, ...n);\n};\nconst selfClearTimeout = (t)=>{\n    let n;\n    const o = t ? a : l;\n    const s = t ? u : i;\n    return [\n        (e)=>{\n            s(n);\n            n = o(()=>e(), isFunction(t) ? t() : t);\n        },\n        ()=>s(n)\n    ];\n};\nconst getDebouncer = (t)=>{\n    const n = isFunction(t) ? t() : t;\n    if (isNumber(n)) {\n        const t = n ? a : l;\n        const o = n ? u : i;\n        return (s)=>{\n            const e = t(()=>s(), n);\n            return ()=>{\n                o(e);\n            };\n        };\n    }\n    return n && n._;\n};\nconst debounce = (t, n)=>{\n    const { p: o, v: s, S: e, m: c } = n || {};\n    let r;\n    let i;\n    let l;\n    let a;\n    const u = function invokeFunctionToDebounce(n) {\n        if (i) {\n            i();\n        }\n        if (r) {\n            r();\n        }\n        a = i = r = l = void 0;\n        t.apply(this, n);\n    };\n    const mergeParms = (t)=>c && l ? c(l, t) : t;\n    const flush = ()=>{\n        if (i && l) {\n            u(mergeParms(l) || l);\n        }\n    };\n    const f = function debouncedFn() {\n        const t = from(arguments);\n        const n = getDebouncer(o);\n        if (n) {\n            const o = typeof e === \"function\" ? e() : e;\n            const c = getDebouncer(s);\n            const f = mergeParms(t);\n            const _ = f || t;\n            const d = u.bind(0, _);\n            if (i) {\n                i();\n            }\n            if (o && !a) {\n                d();\n                a = true;\n                i = n(()=>a = void 0);\n            } else {\n                i = n(d);\n                if (c && !r) {\n                    r = c(flush);\n                }\n            }\n            l = _;\n        } else {\n            u(t);\n        }\n    };\n    f.O = flush;\n    return f;\n};\nconst hasOwnProperty = (t, n)=>Object.prototype.hasOwnProperty.call(t, n);\nconst keys = (t)=>t ? Object.keys(t) : [];\nconst assignDeep = (t, n, o, s, e, c, r)=>{\n    const i = [\n        n,\n        o,\n        s,\n        e,\n        c,\n        r\n    ];\n    if ((typeof t !== \"object\" || isNull(t)) && !isFunction(t)) {\n        t = {};\n    }\n    each(i, (n)=>{\n        each(n, (o, s)=>{\n            const e = n[s];\n            if (t === e) {\n                return true;\n            }\n            const c = isArray(e);\n            if (e && isPlainObject(e)) {\n                const n = t[s];\n                let o = n;\n                if (c && !isArray(n)) {\n                    o = [];\n                } else if (!c && !isPlainObject(n)) {\n                    o = {};\n                }\n                t[s] = assignDeep(o, e);\n            } else {\n                t[s] = c ? e.slice() : e;\n            }\n        });\n    });\n    return t;\n};\nconst removeUndefinedProperties = (t, n)=>each(assignDeep({}, t), (t, n, o)=>{\n        if (t === void 0) {\n            delete o[n];\n        } else if (t && isPlainObject(t)) {\n            o[n] = removeUndefinedProperties(t);\n        }\n    });\nconst isEmptyObject = (t)=>!keys(t).length;\nconst noop = ()=>{};\nconst capNumber = (t, n, e)=>o(t, s(n, e));\nconst getDomTokensArray = (t)=>deduplicateArray((isArray(t) ? t : (t || \"\").split(\" \")).filter((t)=>t));\nconst getAttr = (t, n)=>t && t.getAttribute(n);\nconst hasAttr = (t, n)=>t && t.hasAttribute(n);\nconst setAttrs = (t, n, o)=>{\n    each(getDomTokensArray(n), (n)=>{\n        if (t) {\n            t.setAttribute(n, String(o || \"\"));\n        }\n    });\n};\nconst removeAttrs = (t, n)=>{\n    each(getDomTokensArray(n), (n)=>t && t.removeAttribute(n));\n};\nconst domTokenListAttr = (t, n)=>{\n    const o = getDomTokensArray(getAttr(t, n));\n    const s = bind(setAttrs, t, n);\n    const domTokenListOperation = (t, n)=>{\n        const s = new Set(o);\n        each(getDomTokensArray(t), (t)=>{\n            s[n](t);\n        });\n        return from(s).join(\" \");\n    };\n    return {\n        C: (t)=>s(domTokenListOperation(t, \"delete\")),\n        $: (t)=>s(domTokenListOperation(t, \"add\")),\n        H: (t)=>{\n            const n = getDomTokensArray(t);\n            return n.reduce((t, n)=>t && o.includes(n), n.length > 0);\n        }\n    };\n};\nconst removeAttrClass = (t, n, o)=>{\n    domTokenListAttr(t, n).C(o);\n    return bind(addAttrClass, t, n, o);\n};\nconst addAttrClass = (t, n, o)=>{\n    domTokenListAttr(t, n).$(o);\n    return bind(removeAttrClass, t, n, o);\n};\nconst addRemoveAttrClass = (t, n, o, s)=>(s ? addAttrClass : removeAttrClass)(t, n, o);\nconst hasAttrClass = (t, n, o)=>domTokenListAttr(t, n).H(o);\nconst createDomTokenListClass = (t)=>domTokenListAttr(t, \"class\");\nconst removeClass = (t, n)=>{\n    createDomTokenListClass(t).C(n);\n};\nconst addClass = (t, n)=>{\n    createDomTokenListClass(t).$(n);\n    return bind(removeClass, t, n);\n};\nconst find = (t, n)=>{\n    const o = n ? isElement(n) && n : document;\n    return o ? from(o.querySelectorAll(t)) : [];\n};\nconst findFirst = (t, n)=>{\n    const o = n ? isElement(n) && n : document;\n    return o && o.querySelector(t);\n};\nconst is = (t, n)=>isElement(t) && t.matches(n);\nconst isBodyElement = (t)=>is(t, \"body\");\nconst contents = (t)=>t ? from(t.childNodes) : [];\nconst parent = (t)=>t && t.parentElement;\nconst closest = (t, n)=>isElement(t) && t.closest(n);\nconst getFocusedElement = (t)=>document.activeElement;\nconst liesBetween = (t, n, o)=>{\n    const s = closest(t, n);\n    const e = t && findFirst(o, s);\n    const c = closest(e, n) === s;\n    return s && e ? s === t || e === t || c && closest(closest(t, o), n) !== s : false;\n};\nconst removeElements = (t)=>{\n    each(createOrKeepArray(t), (t)=>{\n        const n = parent(t);\n        if (t && n) {\n            n.removeChild(t);\n        }\n    });\n};\nconst appendChildren = (t, n)=>bind(removeElements, t && n && each(createOrKeepArray(n), (n)=>{\n        if (n) {\n            t.appendChild(n);\n        }\n    }));\nlet z;\nconst getTrustedTypePolicy = ()=>z;\nconst setTrustedTypePolicy = (t)=>{\n    z = t;\n};\nconst createDiv = (t)=>{\n    const n = document.createElement(\"div\");\n    setAttrs(n, \"class\", t);\n    return n;\n};\nconst createDOM = (t)=>{\n    const n = createDiv();\n    const o = getTrustedTypePolicy();\n    const s = t.trim();\n    n.innerHTML = o ? o.createHTML(s) : s;\n    return each(contents(n), (t)=>removeElements(t));\n};\nconst getCSSVal = (t, n)=>t.getPropertyValue(n) || t[n] || \"\";\nconst validFiniteNumber = (t)=>{\n    const n = t || 0;\n    return isFinite(n) ? n : 0;\n};\nconst parseToZeroOrNumber = (t)=>validFiniteNumber(parseFloat(t || \"\"));\nconst roundCssNumber = (t)=>Math.round(t * 1e4) / 1e4;\nconst numberToCssPx = (t)=>\"\".concat(roundCssNumber(validFiniteNumber(t)), \"px\");\nfunction setStyles(t, n) {\n    t && n && each(n, (n, o)=>{\n        try {\n            const s = t.style;\n            const e = isNull(n) || isBoolean(n) ? \"\" : isNumber(n) ? numberToCssPx(n) : n;\n            if (o.indexOf(\"--\") === 0) {\n                s.setProperty(o, e);\n            } else {\n                s[o] = e;\n            }\n        } catch (s) {}\n    });\n}\nfunction getStyles(t, o, s) {\n    const e = isString(o);\n    let c = e ? \"\" : {};\n    if (t) {\n        const r = n.getComputedStyle(t, s) || t.style;\n        c = e ? getCSSVal(r, o) : from(o).reduce((t, n)=>{\n            t[n] = getCSSVal(r, n);\n            return t;\n        }, c);\n    }\n    return c;\n}\nconst topRightBottomLeft = (t, n, o)=>{\n    const s = n ? \"\".concat(n, \"-\") : \"\";\n    const e = o ? \"-\".concat(o) : \"\";\n    const c = \"\".concat(s, \"top\").concat(e);\n    const r = \"\".concat(s, \"right\").concat(e);\n    const i = \"\".concat(s, \"bottom\").concat(e);\n    const l = \"\".concat(s, \"left\").concat(e);\n    const a = getStyles(t, [\n        c,\n        r,\n        i,\n        l\n    ]);\n    return {\n        t: parseToZeroOrNumber(a[c]),\n        r: parseToZeroOrNumber(a[r]),\n        b: parseToZeroOrNumber(a[i]),\n        l: parseToZeroOrNumber(a[l])\n    };\n};\nconst getTrasformTranslateValue = (t, n)=>\"translate\".concat(isObject(t) ? \"(\".concat(t.x, \",\").concat(t.y, \")\") : \"\".concat(n ? \"X\" : \"Y\", \"(\").concat(t, \")\"));\nconst elementHasDimensions = (t)=>!!(t.offsetWidth || t.offsetHeight || t.getClientRects().length);\nconst I = {\n    w: 0,\n    h: 0\n};\nconst getElmWidthHeightProperty = (t, n)=>n ? {\n        w: n[\"\".concat(t, \"Width\")],\n        h: n[\"\".concat(t, \"Height\")]\n    } : I;\nconst getWindowSize = (t)=>getElmWidthHeightProperty(\"inner\", t || n);\nconst A = bind(getElmWidthHeightProperty, \"offset\");\nconst T = bind(getElmWidthHeightProperty, \"client\");\nconst D = bind(getElmWidthHeightProperty, \"scroll\");\nconst getFractionalSize = (t)=>{\n    const n = parseFloat(getStyles(t, C)) || 0;\n    const o = parseFloat(getStyles(t, $)) || 0;\n    return {\n        w: n - e(n),\n        h: o - e(o)\n    };\n};\nconst getBoundingClientRect = (t)=>t.getBoundingClientRect();\nconst hasDimensions = (t)=>!!t && elementHasDimensions(t);\nconst domRectHasDimensions = (t)=>!!(t && (t[$] || t[C]));\nconst domRectAppeared = (t, n)=>{\n    const o = domRectHasDimensions(t);\n    const s = domRectHasDimensions(n);\n    return !s && o;\n};\nconst removeEventListener = (t, n, o, s)=>{\n    each(getDomTokensArray(n), (n)=>{\n        if (t) {\n            t.removeEventListener(n, o, s);\n        }\n    });\n};\nconst addEventListener = (t, n, o, s)=>{\n    var e;\n    const c = (e = s && s.I) != null ? e : true;\n    const r = s && s.A || false;\n    const i = s && s.T || false;\n    const l = {\n        passive: c,\n        capture: r\n    };\n    return bind(runEachAndClear, getDomTokensArray(n).map((n)=>{\n        const s = i ? (e)=>{\n            removeEventListener(t, n, s, r);\n            if (o) {\n                o(e);\n            }\n        } : o;\n        if (t) {\n            t.addEventListener(n, s, l);\n        }\n        return bind(removeEventListener, t, n, s, r);\n    }));\n};\nconst stopPropagation = (t)=>t.stopPropagation();\nconst preventDefault = (t)=>t.preventDefault();\nconst stopAndPrevent = (t)=>stopPropagation(t) || preventDefault(t);\nconst scrollElementTo = (t, n)=>{\n    const { x: o, y: s } = isNumber(n) ? {\n        x: n,\n        y: n\n    } : n || {};\n    isNumber(o) && (t.scrollLeft = o);\n    isNumber(s) && (t.scrollTop = s);\n};\nconst getElementScroll = (t)=>({\n        x: t.scrollLeft,\n        y: t.scrollTop\n    });\nconst getZeroScrollCoordinates = ()=>({\n        D: {\n            x: 0,\n            y: 0\n        },\n        M: {\n            x: 0,\n            y: 0\n        }\n    });\nconst sanitizeScrollCoordinates = (t, n)=>{\n    const { D: o, M: s } = t;\n    const { w: e, h: i } = n;\n    const sanitizeAxis = (t, n, o)=>{\n        let s = r(t) * o;\n        let e = r(n) * o;\n        if (s === e) {\n            const o = c(t);\n            const r = c(n);\n            e = o > r ? 0 : e;\n            s = o < r ? 0 : s;\n        }\n        s = s === e ? 0 : s;\n        return [\n            s + 0,\n            e + 0\n        ];\n    };\n    const [l, a] = sanitizeAxis(o.x, s.x, e);\n    const [u, f] = sanitizeAxis(o.y, s.y, i);\n    return {\n        D: {\n            x: l,\n            y: u\n        },\n        M: {\n            x: a,\n            y: f\n        }\n    };\n};\nconst isDefaultDirectionScrollCoordinates = (param)=>{\n    let { D: t, M: n } = param;\n    const getAxis = (t, n)=>t === 0 && t <= n;\n    return {\n        x: getAxis(t.x, n.x),\n        y: getAxis(t.y, n.y)\n    };\n};\nconst getScrollCoordinatesPercent = (param, o)=>{\n    let { D: t, M: n } = param;\n    const getAxis = (t, n, o)=>capNumber(0, 1, (t - o) / (t - n) || 0);\n    return {\n        x: getAxis(t.x, n.x, o.x),\n        y: getAxis(t.y, n.y, o.y)\n    };\n};\nconst focusElement = (t)=>{\n    if (t && t.focus) {\n        t.focus({\n            preventScroll: true,\n            focusVisible: false\n        });\n    }\n};\nconst manageListener = (t, n)=>{\n    each(createOrKeepArray(n), t);\n};\nconst createEventListenerHub = (t)=>{\n    const n = new Map;\n    const removeEvent = (t, o)=>{\n        if (t) {\n            const s = n.get(t);\n            manageListener((t)=>{\n                if (s) {\n                    s[t ? \"delete\" : \"clear\"](t);\n                }\n            }, o);\n        } else {\n            n.forEach((t)=>{\n                t.clear();\n            });\n            n.clear();\n        }\n    };\n    const addEvent = (t, o)=>{\n        if (isString(t)) {\n            const s = n.get(t) || new Set;\n            n.set(t, s);\n            manageListener((t)=>{\n                if (isFunction(t)) {\n                    s.add(t);\n                }\n            }, o);\n            return bind(removeEvent, t, o);\n        }\n        if (isBoolean(o) && o) {\n            removeEvent();\n        }\n        const s = keys(t);\n        const e = [];\n        each(s, (n)=>{\n            const o = t[n];\n            if (o) {\n                push(e, addEvent(n, o));\n            }\n        });\n        return bind(runEachAndClear, e);\n    };\n    const triggerEvent = (t, o)=>{\n        each(from(n.get(t)), (t)=>{\n            if (o && !isEmptyArray(o)) {\n                t.apply(0, o);\n            } else {\n                t();\n            }\n        });\n    };\n    addEvent(t || {});\n    return [\n        addEvent,\n        removeEvent,\n        triggerEvent\n    ];\n};\nconst M = {};\nconst k = {};\nconst addPlugins = (t)=>{\n    each(t, (t)=>each(t, (n, o)=>{\n            M[o] = t[o];\n        }));\n};\nconst registerPluginModuleInstances = (t, n, o)=>keys(t).map((s)=>{\n        const { static: e, instance: c } = t[s];\n        const [r, i, l] = o || [];\n        const a = o ? c : e;\n        if (a) {\n            const t = o ? a(r, i, n) : a(n);\n            return (l || k)[s] = t;\n        }\n    });\nconst getStaticPluginModuleInstance = (t)=>k[t];\nconst R = \"__osOptionsValidationPlugin\";\nconst V = \"data-overlayscrollbars\";\nconst L = \"os-environment\";\nconst U = \"\".concat(L, \"-scrollbar-hidden\");\nconst P = \"\".concat(V, \"-initialize\");\nconst N = \"noClipping\";\nconst q = \"\".concat(V, \"-body\");\nconst B = V;\nconst F = \"host\";\nconst j = \"\".concat(V, \"-viewport\");\nconst X = m;\nconst Y = O;\nconst W = \"arrange\";\nconst J = \"measuring\";\nconst G = \"scrolling\";\nconst K = \"scrollbarHidden\";\nconst Q = \"noContent\";\nconst Z = \"\".concat(V, \"-padding\");\nconst tt = \"\".concat(V, \"-content\");\nconst nt = \"os-size-observer\";\nconst ot = \"\".concat(nt, \"-appear\");\nconst st = \"\".concat(nt, \"-listener\");\nconst et = \"\".concat(st, \"-scroll\");\nconst ct = \"\".concat(st, \"-item\");\nconst rt = \"\".concat(ct, \"-final\");\nconst it = \"os-trinsic-observer\";\nconst lt = \"os-theme-none\";\nconst at = \"os-scrollbar\";\nconst ut = \"\".concat(at, \"-rtl\");\nconst ft = \"\".concat(at, \"-horizontal\");\nconst _t = \"\".concat(at, \"-vertical\");\nconst dt = \"\".concat(at, \"-track\");\nconst pt = \"\".concat(at, \"-handle\");\nconst vt = \"\".concat(at, \"-visible\");\nconst gt = \"\".concat(at, \"-cornerless\");\nconst ht = \"\".concat(at, \"-interaction\");\nconst bt = \"\".concat(at, \"-unusable\");\nconst wt = \"\".concat(at, \"-auto-hide\");\nconst yt = \"\".concat(wt, \"-hidden\");\nconst St = \"\".concat(at, \"-wheel\");\nconst mt = \"\".concat(dt, \"-interactive\");\nconst Ot = \"\".concat(pt, \"-interactive\");\nconst Ct = \"__osSizeObserverPlugin\";\nconst $t = /* @__PURE__ */ (()=>({\n        [Ct]: {\n            static: ()=>(t, n, o)=>{\n                    const s = 3333333;\n                    const e = \"scroll\";\n                    const c = createDOM('<div class=\"'.concat(ct, '\" dir=\"ltr\"><div class=\"').concat(ct, '\"><div class=\"').concat(rt, '\"></div></div><div class=\"').concat(ct, '\"><div class=\"').concat(rt, '\" style=\"width: 200%; height: 200%\"></div></div></div>'));\n                    const r = c[0];\n                    const a = r.lastChild;\n                    const u = r.firstChild;\n                    const f = u == null ? void 0 : u.firstChild;\n                    let _ = A(r);\n                    let d = _;\n                    let p = false;\n                    let v;\n                    const reset = ()=>{\n                        scrollElementTo(u, s);\n                        scrollElementTo(a, s);\n                    };\n                    const onResized = (t)=>{\n                        v = 0;\n                        if (p) {\n                            _ = d;\n                            n(t === true);\n                        }\n                    };\n                    const onScroll = (t)=>{\n                        d = A(r);\n                        p = !t || !equalWH(d, _);\n                        if (t) {\n                            stopPropagation(t);\n                            if (p && !v) {\n                                i(v);\n                                v = l(onResized);\n                            }\n                        } else {\n                            onResized(t === false);\n                        }\n                        reset();\n                    };\n                    const g = [\n                        appendChildren(t, c),\n                        addEventListener(u, e, onScroll),\n                        addEventListener(a, e, onScroll)\n                    ];\n                    addClass(t, et);\n                    setStyles(f, {\n                        [C]: s,\n                        [$]: s\n                    });\n                    l(reset);\n                    return [\n                        o ? bind(onScroll, false) : reset,\n                        g\n                    ];\n                }\n        }\n    }))();\nconst getShowNativeOverlaidScrollbars = (t, n)=>{\n    const { k: o } = n;\n    const [s, e] = t(\"showNativeOverlaidScrollbars\");\n    return [\n        s && o.x && o.y,\n        e\n    ];\n};\nconst overflowIsVisible = (t)=>t.indexOf(x) === 0;\nconst overflowBehaviorToOverflowStyle = (t)=>t.replace(\"\".concat(x, \"-\"), \"\");\nconst overflowCssValueToOverflowStyle = (t, n)=>{\n    if (t === \"auto\") {\n        return n ? E : H;\n    }\n    const o = t || H;\n    return [\n        H,\n        E,\n        x\n    ].includes(o) ? o : H;\n};\nconst getElementOverflowStyle = (t, n)=>{\n    const { overflowX: o, overflowY: s } = getStyles(t, [\n        m,\n        O\n    ]);\n    return {\n        x: overflowCssValueToOverflowStyle(o, n.x),\n        y: overflowCssValueToOverflowStyle(s, n.y)\n    };\n};\nconst xt = \"__osScrollbarsHidingPlugin\";\nconst Ht = /* @__PURE__ */ (()=>({\n        [xt]: {\n            static: ()=>({\n                    R: (t, n, o, s, e)=>{\n                        const { V: c, L: r } = t;\n                        const { U: i, k: l, P: a } = s;\n                        const u = !c && !i && (l.x || l.y);\n                        const [f] = getShowNativeOverlaidScrollbars(e, s);\n                        const _getViewportOverflowHideOffset = (t)=>{\n                            const n = i || f ? 0 : 42;\n                            const getHideOffsetPerAxis = (t, o, s)=>{\n                                const e = t ? n : s;\n                                const c = o && !i ? e : 0;\n                                const r = t && !!n;\n                                return [\n                                    c,\n                                    r\n                                ];\n                            };\n                            const [o, s] = getHideOffsetPerAxis(l.x, t.x === E, a.x);\n                            const [e, c] = getHideOffsetPerAxis(l.y, t.y === E, a.y);\n                            return {\n                                N: {\n                                    x: o,\n                                    y: e\n                                },\n                                q: {\n                                    x: s,\n                                    y: c\n                                }\n                            };\n                        };\n                        const _hideNativeScrollbars = (t)=>{\n                            if (!c) {\n                                const { B: s } = o;\n                                const e = assignDeep({}, {\n                                    [y]: 0,\n                                    [S]: 0,\n                                    [w]: 0\n                                });\n                                const { N: c, q: r } = _getViewportOverflowHideOffset(t);\n                                const { x: i, y: l } = r;\n                                const { x: a, y: f } = c;\n                                const { F: _ } = n;\n                                const d = s ? w : y;\n                                const p = s ? h : g;\n                                const v = _[d];\n                                const m = _[S];\n                                const O = _[p];\n                                const $ = _[b];\n                                e[C] = \"calc(100% + \".concat(f + v * -1, \"px)\");\n                                e[d] = -f + v;\n                                e[S] = -a + m;\n                                if (u) {\n                                    e[p] = O + (l ? f : 0);\n                                    e[b] = $ + (i ? a : 0);\n                                }\n                                return e;\n                            }\n                        };\n                        const _arrangeViewport = (t, s, e)=>{\n                            if (u) {\n                                const { F: c } = n;\n                                const { N: i, q: l } = _getViewportOverflowHideOffset(t);\n                                const { x: a, y: u } = l;\n                                const { x: f, y: _ } = i;\n                                const { B: d } = o;\n                                const p = d ? g : h;\n                                const v = c[p];\n                                const b = c.paddingTop;\n                                const w = s.w + e.w;\n                                const y = s.h + e.h;\n                                const S = {\n                                    w: _ && u ? \"\".concat(_ + w - v, \"px\") : \"\",\n                                    h: f && a ? \"\".concat(f + y - b, \"px\") : \"\"\n                                };\n                                setStyles(r, {\n                                    \"--os-vaw\": S.w,\n                                    \"--os-vah\": S.h\n                                });\n                            }\n                            return u;\n                        };\n                        const _undoViewportArrange = ()=>{\n                            if (u) {\n                                const { j: t, F: o } = n;\n                                const s = getElementOverflowStyle(r, t);\n                                const { q: e } = _getViewportOverflowHideOffset(s);\n                                const { x: c, y: i } = e;\n                                const l = {};\n                                const assignProps = (t)=>each(t, (t)=>{\n                                        l[t] = o[t];\n                                    });\n                                if (c) {\n                                    assignProps([\n                                        S,\n                                        v,\n                                        b\n                                    ]);\n                                }\n                                if (i) {\n                                    assignProps([\n                                        w,\n                                        y,\n                                        h,\n                                        g\n                                    ]);\n                                }\n                                const a = getStyles(r, keys(l));\n                                const u = removeAttrClass(r, j, W);\n                                setStyles(r, l);\n                                return ()=>{\n                                    setStyles(r, assignDeep({}, a, _hideNativeScrollbars(s)));\n                                    u();\n                                };\n                            }\n                            return noop;\n                        };\n                        return {\n                            X: _arrangeViewport,\n                            Y: _undoViewportArrange,\n                            W: _hideNativeScrollbars\n                        };\n                    }\n                })\n        }\n    }))();\nconst Et = \"__osClickScrollPlugin\";\nconst zt = /* @__PURE__ */ (()=>({\n        [Et]: {\n            static: ()=>(t, n, o, s)=>{\n                    let e = false;\n                    let c = noop;\n                    const r = 133;\n                    const i = 222;\n                    const [l, a] = selfClearTimeout(r);\n                    const u = Math.sign(n);\n                    const f = o * u;\n                    const _ = f / 2;\n                    const easing = (t)=>1 - (1 - t) * (1 - t);\n                    const easedEndPressAnimation = (n, o)=>animateNumber(n, o, i, t, easing);\n                    const linearPressAnimation = (o, s)=>animateNumber(o, n - f, r * s, (o, s, e)=>{\n                            t(o);\n                            if (e) {\n                                c = easedEndPressAnimation(o, n);\n                            }\n                        });\n                    const d = animateNumber(0, f, i, (r, i, a)=>{\n                        t(r);\n                        if (a) {\n                            s(e);\n                            if (!e) {\n                                const t = n - r;\n                                const s = Math.sign(t - _) === u;\n                                if (s) {\n                                    l(()=>{\n                                        const s = t - f;\n                                        const e = Math.sign(s) === u;\n                                        c = e ? linearPressAnimation(r, Math.abs(s) / o) : easedEndPressAnimation(r, n);\n                                    });\n                                }\n                            }\n                        }\n                    }, easing);\n                    return (t)=>{\n                        e = true;\n                        if (t) {\n                            d();\n                        }\n                        a();\n                        c();\n                    };\n                }\n        }\n    }))();\nconst opsStringify = (t)=>JSON.stringify(t, (t, n)=>{\n        if (isFunction(n)) {\n            throw 0;\n        }\n        return n;\n    });\nconst getPropByPath = (t, n)=>t ? \"\".concat(n).split(\".\").reduce((t, n)=>t && hasOwnProperty(t, n) ? t[n] : void 0, t) : void 0;\nconst It = [\n    0,\n    33\n];\nconst At = [\n    33,\n    99\n];\nconst Tt = [\n    222,\n    666,\n    true\n];\nconst Dt = {\n    paddingAbsolute: false,\n    showNativeOverlaidScrollbars: false,\n    update: {\n        elementEvents: [\n            [\n                \"img\",\n                \"load\"\n            ]\n        ],\n        debounce: {\n            mutation: It,\n            resize: null,\n            event: At,\n            env: Tt\n        },\n        attributes: null,\n        ignoreMutation: null,\n        flowDirectionStyles: null\n    },\n    overflow: {\n        x: \"scroll\",\n        y: \"scroll\"\n    },\n    scrollbars: {\n        theme: \"os-theme-dark\",\n        visibility: \"auto\",\n        autoHide: \"never\",\n        autoHideDelay: 1300,\n        autoHideSuspend: false,\n        dragScroll: true,\n        clickScroll: false,\n        pointers: [\n            \"mouse\",\n            \"touch\",\n            \"pen\"\n        ]\n    }\n};\nconst getOptionsDiff = (t, n)=>{\n    const o = {};\n    const s = concat(keys(n), keys(t));\n    each(s, (s)=>{\n        const e = t[s];\n        const c = n[s];\n        if (isObject(e) && isObject(c)) {\n            assignDeep(o[s] = {}, getOptionsDiff(e, c));\n            if (isEmptyObject(o[s])) {\n                delete o[s];\n            }\n        } else if (hasOwnProperty(n, s) && c !== e) {\n            let t = true;\n            if (isArray(e) || isArray(c)) {\n                try {\n                    if (opsStringify(e) === opsStringify(c)) {\n                        t = false;\n                    }\n                } catch (r) {}\n            }\n            if (t) {\n                o[s] = c;\n            }\n        }\n    });\n    return o;\n};\nconst createOptionCheck = (t, n, o)=>(s)=>[\n            getPropByPath(t, s),\n            o || getPropByPath(n, s) !== void 0\n        ];\nlet Mt;\nconst getNonce = ()=>Mt;\nconst setNonce = (t)=>{\n    Mt = t;\n};\nlet kt;\nconst createEnvironment = ()=>{\n    const getNativeScrollbarSize = (t, n, o)=>{\n        appendChildren(document.body, t);\n        appendChildren(document.body, t);\n        const s = T(t);\n        const e = A(t);\n        const c = getFractionalSize(n);\n        if (o) {\n            removeElements(t);\n        }\n        return {\n            x: e.h - s.h + c.h,\n            y: e.w - s.w + c.w\n        };\n    };\n    const getNativeScrollbarsHiding = (t)=>{\n        let n = false;\n        const o = addClass(t, U);\n        try {\n            n = getStyles(t, \"scrollbar-width\") === \"none\" || getStyles(t, \"display\", \"::-webkit-scrollbar\") === \"none\";\n        } catch (s) {}\n        o();\n        return n;\n    };\n    const t = \".\".concat(L, \"{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.\").concat(L, \" div{width:200%;height:200%;margin:10px 0}.\").concat(U, \"{scrollbar-width:none!important}.\").concat(U, \"::-webkit-scrollbar,.\").concat(U, \"::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}\");\n    const o = createDOM('<div class=\"'.concat(L, '\"><div></div><style>').concat(t, \"</style></div>\"));\n    const s = o[0];\n    const e = s.firstChild;\n    const c = s.lastChild;\n    const r = getNonce();\n    if (r) {\n        c.nonce = r;\n    }\n    const [i, , l] = createEventListenerHub();\n    const [a, u] = createCache({\n        o: getNativeScrollbarSize(s, e),\n        i: equalXY\n    }, bind(getNativeScrollbarSize, s, e, true));\n    const [f] = u();\n    const _ = getNativeScrollbarsHiding(s);\n    const d = {\n        x: f.x === 0,\n        y: f.y === 0\n    };\n    const v = {\n        elements: {\n            host: null,\n            padding: !_,\n            viewport: (t)=>_ && isBodyElement(t) && t,\n            content: false\n        },\n        scrollbars: {\n            slot: true\n        },\n        cancel: {\n            nativeScrollbarsOverlaid: false,\n            body: null\n        }\n    };\n    const g = assignDeep({}, Dt);\n    const h = bind(assignDeep, {}, g);\n    const b = bind(assignDeep, {}, v);\n    const w = {\n        P: f,\n        k: d,\n        U: _,\n        J: !!p,\n        G: bind(i, \"r\"),\n        K: b,\n        Z: (t)=>assignDeep(v, t) && b(),\n        tt: h,\n        nt: (t)=>assignDeep(g, t) && h(),\n        ot: assignDeep({}, v),\n        st: assignDeep({}, g)\n    };\n    removeAttrs(s, \"style\");\n    removeElements(s);\n    addEventListener(n, \"resize\", ()=>{\n        l(\"r\", []);\n    });\n    if (isFunction(n.matchMedia) && !_ && (!d.x || !d.y)) {\n        const addZoomListener = (t)=>{\n            const o = n.matchMedia(\"(resolution: \".concat(n.devicePixelRatio, \"dppx)\"));\n            addEventListener(o, \"change\", ()=>{\n                t();\n                addZoomListener(t);\n            }, {\n                T: true\n            });\n        };\n        addZoomListener(()=>{\n            const [t, n] = a();\n            assignDeep(w.P, t);\n            l(\"r\", [\n                n\n            ]);\n        });\n    }\n    return w;\n};\nconst getEnvironment = ()=>{\n    if (!kt) {\n        kt = createEnvironment();\n    }\n    return kt;\n};\nconst createEventContentChange = (t, n, o)=>{\n    let s = false;\n    const e = o ? new WeakMap : false;\n    const destroy = ()=>{\n        s = true;\n    };\n    const updateElements = (c)=>{\n        if (e && o) {\n            const r = o.map((n)=>{\n                const [o, s] = n || [];\n                const e = s && o ? (c || find)(o, t) : [];\n                return [\n                    e,\n                    s\n                ];\n            });\n            each(r, (o)=>each(o[0], (c)=>{\n                    const r = o[1];\n                    const i = e.get(c) || [];\n                    const l = t.contains(c);\n                    if (l && r) {\n                        const t = addEventListener(c, r, (o)=>{\n                            if (s) {\n                                t();\n                                e.delete(c);\n                            } else {\n                                n(o);\n                            }\n                        });\n                        e.set(c, push(i, t));\n                    } else {\n                        runEachAndClear(i);\n                        e.delete(c);\n                    }\n                }));\n        }\n    };\n    updateElements();\n    return [\n        destroy,\n        updateElements\n    ];\n};\nconst createDOMObserver = (t, n, o, s)=>{\n    let e = false;\n    const { et: c, ct: r, rt: i, it: l, lt: a, ut: u } = s || {};\n    const [_, d] = createEventContentChange(t, ()=>e && o(true), i);\n    const p = c || [];\n    const v = r || [];\n    const g = concat(p, v);\n    const observerCallback = (e, c)=>{\n        if (!isEmptyArray(c)) {\n            const r = a || noop;\n            const i = u || noop;\n            const f = [];\n            const _ = [];\n            let p = false;\n            let g = false;\n            each(c, (o)=>{\n                const { attributeName: e, target: c, type: a, oldValue: u, addedNodes: d, removedNodes: h } = o;\n                const b = a === \"attributes\";\n                const w = a === \"childList\";\n                const y = t === c;\n                const S = b && e;\n                const m = S && getAttr(c, e || \"\");\n                const O = isString(m) ? m : null;\n                const C = S && u !== O;\n                const $ = inArray(v, e) && C;\n                if (n && (w || !y)) {\n                    const n = b && C;\n                    const a = n && l && is(c, l);\n                    const _ = a ? !r(c, e, u, O) : !b || n;\n                    const p = _ && !i(o, !!a, t, s);\n                    each(d, (t)=>push(f, t));\n                    each(h, (t)=>push(f, t));\n                    g = g || p;\n                }\n                if (!n && y && C && !r(c, e, u, O)) {\n                    push(_, e);\n                    p = p || $;\n                }\n            });\n            d((t)=>deduplicateArray(f).reduce((n, o)=>{\n                    push(n, find(t, o));\n                    return is(o, t) ? push(n, o) : n;\n                }, []));\n            if (n) {\n                if (!e && g) {\n                    o(false);\n                }\n                return [\n                    false\n                ];\n            }\n            if (!isEmptyArray(_) || p) {\n                const t = [\n                    deduplicateArray(_),\n                    p\n                ];\n                if (!e) {\n                    o.apply(0, t);\n                }\n                return t;\n            }\n        }\n    };\n    const h = new f(bind(observerCallback, false));\n    return [\n        ()=>{\n            h.observe(t, {\n                attributes: true,\n                attributeOldValue: true,\n                attributeFilter: g,\n                subtree: n,\n                childList: n,\n                characterData: n\n            });\n            e = true;\n            return ()=>{\n                if (e) {\n                    _();\n                    h.disconnect();\n                    e = false;\n                }\n            };\n        },\n        ()=>{\n            if (e) {\n                return observerCallback(true, h.takeRecords());\n            }\n        }\n    ];\n};\nlet Rt = null;\nconst createSizeObserver = (t, n, o)=>{\n    const { ft: s } = o || {};\n    const e = getStaticPluginModuleInstance(Ct);\n    const [c] = createCache({\n        o: false,\n        u: true\n    });\n    return ()=>{\n        const o = [];\n        const r = createDOM('<div class=\"'.concat(nt, '\"><div class=\"').concat(st, '\"></div></div>'));\n        const i = r[0];\n        const l = i.firstChild;\n        const onSizeChangedCallbackProxy = (t)=>{\n            const o = isArray(t) && !isEmptyArray(t);\n            let s = false;\n            let e = false;\n            if (o) {\n                const n = t[0];\n                const [o, , r] = c(n.contentRect);\n                const i = domRectHasDimensions(o);\n                e = domRectAppeared(o, r);\n                s = !e && !i;\n            } else {\n                e = t === true;\n            }\n            if (!s) {\n                n({\n                    _t: true,\n                    ft: e\n                });\n            }\n        };\n        if (d) {\n            if (!isBoolean(Rt)) {\n                const n = new d(noop);\n                n.observe(t, {\n                    get box () {\n                        Rt = true;\n                    }\n                });\n                Rt = Rt || false;\n                n.disconnect();\n            }\n            const n = debounce(onSizeChangedCallbackProxy, {\n                p: 0,\n                v: 0\n            });\n            const resizeObserverCallback = (t)=>n(t);\n            const s = new d(resizeObserverCallback);\n            s.observe(Rt ? t : l);\n            push(o, [\n                ()=>{\n                    s.disconnect();\n                },\n                !Rt && appendChildren(t, i)\n            ]);\n            if (Rt) {\n                const n = new d(resizeObserverCallback);\n                n.observe(t, {\n                    box: \"border-box\"\n                });\n                push(o, ()=>n.disconnect());\n            }\n        } else if (e) {\n            const [n, c] = e(l, onSizeChangedCallbackProxy, s);\n            push(o, concat([\n                addClass(i, ot),\n                addEventListener(i, \"animationstart\", n),\n                appendChildren(t, i)\n            ], c));\n        } else {\n            return noop;\n        }\n        return bind(runEachAndClear, o);\n    };\n};\nconst createTrinsicObserver = (t, n)=>{\n    let o;\n    const isHeightIntrinsic = (t)=>t.h === 0 || t.isIntersecting || t.intersectionRatio > 0;\n    const s = createDiv(it);\n    const [e] = createCache({\n        o: false\n    });\n    const triggerOnTrinsicChangedCallback = (t, o)=>{\n        if (t) {\n            const s = e(isHeightIntrinsic(t));\n            const [, c] = s;\n            return c && !o && n(s) && [\n                s\n            ];\n        }\n    };\n    const intersectionObserverCallback = (t, n)=>triggerOnTrinsicChangedCallback(n.pop(), t);\n    return [\n        ()=>{\n            const n = [];\n            if (_) {\n                o = new _(bind(intersectionObserverCallback, false), {\n                    root: t\n                });\n                o.observe(s);\n                push(n, ()=>{\n                    o.disconnect();\n                });\n            } else {\n                const onSizeChanged = ()=>{\n                    const t = A(s);\n                    triggerOnTrinsicChangedCallback(t);\n                };\n                push(n, createSizeObserver(s, onSizeChanged)());\n                onSizeChanged();\n            }\n            return bind(runEachAndClear, push(n, appendChildren(t, s)));\n        },\n        ()=>o && intersectionObserverCallback(true, o.takeRecords())\n    ];\n};\nconst createObserversSetup = (t, n, o, s)=>{\n    let e;\n    let c;\n    let r;\n    let i;\n    let l;\n    let a;\n    let u;\n    let f;\n    const _ = \"[\".concat(B, \"]\");\n    const p = \"[\".concat(j, \"]\");\n    const v = [\n        \"id\",\n        \"class\",\n        \"style\",\n        \"open\",\n        \"wrap\",\n        \"cols\",\n        \"rows\"\n    ];\n    const { dt: g, vt: h, L: b, gt: w, ht: y, V: S, bt: m, wt: O, yt: C, St: $ } = t;\n    const getDirectionIsRTL = (t)=>getStyles(t, \"direction\") === \"rtl\";\n    const createDebouncedObservesUpdate = ()=>{\n        let t;\n        let n;\n        let o;\n        const e = debounce(s, {\n            p: ()=>t,\n            v: ()=>n,\n            S: ()=>o,\n            m (t, n) {\n                const [o] = t;\n                const [s] = n;\n                return [\n                    concat(keys(o), keys(s)).reduce((t, n)=>{\n                        t[n] = o[n] || s[n];\n                        return t;\n                    }, {})\n                ];\n            }\n        });\n        const fn = (s, c)=>{\n            if (isArray(c)) {\n                const [s, e, r] = c;\n                t = s;\n                n = e;\n                o = r;\n            } else if (isNumber(c)) {\n                t = c;\n                n = false;\n                o = false;\n            } else {\n                t = false;\n                n = false;\n                o = false;\n            }\n            e(s);\n        };\n        fn.O = e.O;\n        return fn;\n    };\n    const x = {\n        Ot: false,\n        B: getDirectionIsRTL(g)\n    };\n    const H = getEnvironment();\n    const E = getStaticPluginModuleInstance(xt);\n    const [z] = createCache({\n        i: equalWH,\n        o: {\n            w: 0,\n            h: 0\n        }\n    }, ()=>{\n        const s = E && E.R(t, n, x, H, o).Y;\n        const e = m && S;\n        const c = !e && hasAttrClass(h, B, N);\n        const r = !S && O(W);\n        const i = r && getElementScroll(w);\n        const l = i && $();\n        const a = C(J, c);\n        const u = r && s && s();\n        const f = D(b);\n        const _ = getFractionalSize(b);\n        if (u) {\n            u();\n        }\n        scrollElementTo(w, i);\n        if (l) {\n            l();\n        }\n        if (c) {\n            a();\n        }\n        return {\n            w: f.w + _.w,\n            h: f.h + _.h\n        };\n    });\n    const I = createDebouncedObservesUpdate();\n    const setDirection = (t)=>{\n        const n = getDirectionIsRTL(g);\n        assignDeep(t, {\n            Ct: f !== n\n        });\n        assignDeep(x, {\n            B: n\n        });\n        f = n;\n    };\n    const onTrinsicChanged = (t, n)=>{\n        const [o, e] = t;\n        const c = {\n            $t: e\n        };\n        assignDeep(x, {\n            Ot: o\n        });\n        if (!n) {\n            s(c);\n        }\n        return c;\n    };\n    const onSizeChanged = (param)=>{\n        let { _t: t, ft: n } = param;\n        const o = n ? s : I;\n        const e = {\n            _t: t || n,\n            ft: n\n        };\n        setDirection(e);\n        o(e, c);\n    };\n    const onContentMutation = (t, n)=>{\n        const [, o] = z();\n        const s = {\n            xt: o\n        };\n        setDirection(s);\n        if (o && !n) {\n            I(s, t ? r : e);\n        }\n        return s;\n    };\n    const onHostMutation = (t, n, o)=>{\n        const s = {\n            Ht: n\n        };\n        setDirection(s);\n        if (n && !o) {\n            I(s, e);\n        }\n        return s;\n    };\n    const [A, T] = y ? createTrinsicObserver(h, onTrinsicChanged) : [];\n    const M = !S && createSizeObserver(h, onSizeChanged, {\n        ft: true\n    });\n    const [k, R] = createDOMObserver(h, false, onHostMutation, {\n        ct: v,\n        et: v\n    });\n    const V = S && d && new d((t)=>{\n        const n = t[t.length - 1].contentRect;\n        onSizeChanged({\n            _t: true,\n            ft: domRectAppeared(n, u)\n        });\n        u = n;\n    });\n    return [\n        ()=>{\n            if (V) {\n                V.observe(h);\n            }\n            const t = M && M();\n            const n = A && A();\n            const o = k();\n            const s = H.G((t)=>{\n                const [, n] = z();\n                I({\n                    Et: t,\n                    xt: n,\n                    _t: m\n                }, i);\n            });\n            return ()=>{\n                if (V) {\n                    V.disconnect();\n                }\n                if (t) {\n                    t();\n                }\n                if (n) {\n                    n();\n                }\n                if (a) {\n                    a();\n                }\n                o();\n                s();\n            };\n        },\n        (param)=>{\n            let { zt: t, It: n, At: o } = param;\n            const s = {};\n            const [u] = t(\"update.ignoreMutation\");\n            const [f, d] = t(\"update.attributes\");\n            const [g, h] = t(\"update.elementEvents\");\n            const [w, m] = t(\"update.debounce\");\n            const O = h || d;\n            const C = n || o;\n            const ignoreMutationFromOptions = (t)=>isFunction(u) && u(t);\n            if (O) {\n                if (l) {\n                    l();\n                }\n                if (a) {\n                    a();\n                }\n                const [t, n] = createDOMObserver(y || b, true, onContentMutation, {\n                    et: concat(v, f || []),\n                    rt: g,\n                    it: _,\n                    ut: (t, n)=>{\n                        const { target: o, attributeName: s } = t;\n                        const e = !n && s && !S ? liesBetween(o, _, p) : false;\n                        return e || !!closest(o, \".\".concat(at)) || !!ignoreMutationFromOptions(t);\n                    }\n                });\n                a = t();\n                l = n;\n            }\n            if (m) {\n                I.O();\n                if (isArray(w) || isNumber(w)) {\n                    e = w;\n                    c = false;\n                    r = At;\n                    i = Tt;\n                } else if (isPlainObject(w)) {\n                    e = w.mutation;\n                    c = w.resize;\n                    r = w.event;\n                    i = w.env;\n                } else {\n                    e = false;\n                    c = false;\n                    r = false;\n                    i = false;\n                }\n            }\n            if (C) {\n                const t = R();\n                const n = T && T();\n                const o = l && l();\n                if (t) {\n                    assignDeep(s, onHostMutation(t[0], t[1], C));\n                }\n                if (n) {\n                    assignDeep(s, onTrinsicChanged(n[0], C));\n                }\n                if (o) {\n                    assignDeep(s, onContentMutation(o[0], C));\n                }\n            }\n            setDirection(s);\n            return s;\n        },\n        x\n    ];\n};\nconst resolveInitialization = (t, n)=>isFunction(n) ? n.apply(0, t) : n;\nconst staticInitializationElement = (t, n, o, s)=>{\n    const e = isUndefined(s) ? o : s;\n    const c = resolveInitialization(t, e);\n    return c || n.apply(0, t);\n};\nconst dynamicInitializationElement = (t, n, o, s)=>{\n    const e = isUndefined(s) ? o : s;\n    const c = resolveInitialization(t, e);\n    return !!c && (isHTMLElement(c) ? c : n.apply(0, t));\n};\nconst cancelInitialization = (t, n)=>{\n    const { nativeScrollbarsOverlaid: o, body: s } = n || {};\n    const { k: e, U: c, K: r } = getEnvironment();\n    const { nativeScrollbarsOverlaid: i, body: l } = r().cancel;\n    const a = o != null ? o : i;\n    const u = isUndefined(s) ? l : s;\n    const f = (e.x || e.y) && a;\n    const _ = t && (isNull(u) ? !c : u);\n    return !!f || !!_;\n};\nconst createScrollbarsSetupElements = (t, n, o, s)=>{\n    const e = \"--os-viewport-percent\";\n    const c = \"--os-scroll-percent\";\n    const r = \"--os-scroll-direction\";\n    const { K: i } = getEnvironment();\n    const { scrollbars: l } = i();\n    const { slot: a } = l;\n    const { dt: u, vt: f, L: _, Tt: d, gt: v, bt: g, V: h } = n;\n    const { scrollbars: b } = d ? {} : t;\n    const { slot: w } = b || {};\n    const y = [];\n    const S = [];\n    const m = [];\n    const O = dynamicInitializationElement([\n        u,\n        f,\n        _\n    ], ()=>h && g ? u : f, a, w);\n    const initScrollTimeline = (t)=>{\n        if (p) {\n            let n = null;\n            let s = [];\n            const e = new p({\n                source: v,\n                axis: t\n            });\n            const cancelAnimation = ()=>{\n                if (n) {\n                    n.cancel();\n                }\n                n = null;\n            };\n            const _setScrollPercentAnimation = (c)=>{\n                const { Dt: r } = o;\n                const i = isDefaultDirectionScrollCoordinates(r)[t];\n                const l = t === \"x\";\n                const a = [\n                    getTrasformTranslateValue(0, l),\n                    getTrasformTranslateValue(\"calc(-100% + 100cq\".concat(l ? \"w\" : \"h\", \")\"), l)\n                ];\n                const u = i ? a : a.reverse();\n                if (s[0] === u[0] && s[1] === u[1]) {\n                    return cancelAnimation;\n                }\n                s = u;\n                cancelAnimation();\n                n = c.Mt.animate({\n                    clear: [\n                        \"left\"\n                    ],\n                    transform: u\n                }, {\n                    timeline: e\n                });\n                return cancelAnimation;\n            };\n            return {\n                kt: _setScrollPercentAnimation\n            };\n        }\n    };\n    const C = {\n        x: initScrollTimeline(\"x\"),\n        y: initScrollTimeline(\"y\")\n    };\n    const getViewportPercent = ()=>{\n        const { Rt: t, Vt: n } = o;\n        const getAxisValue = (t, n)=>capNumber(0, 1, t / (t + n) || 0);\n        return {\n            x: getAxisValue(n.x, t.x),\n            y: getAxisValue(n.y, t.y)\n        };\n    };\n    const scrollbarStructureAddRemoveClass = (t, n, o)=>{\n        const s = o ? addClass : removeClass;\n        each(t, (t)=>{\n            s(t.Lt, n);\n        });\n    };\n    const scrollbarStyle = (t, n)=>{\n        each(t, (t)=>{\n            const [o, s] = n(t);\n            setStyles(o, s);\n        });\n    };\n    const scrollbarsAddRemoveClass = (t, n, o)=>{\n        const s = isBoolean(o);\n        const e = s ? o : true;\n        const c = s ? !o : true;\n        if (e) {\n            scrollbarStructureAddRemoveClass(S, t, n);\n        }\n        if (c) {\n            scrollbarStructureAddRemoveClass(m, t, n);\n        }\n    };\n    const refreshScrollbarsHandleLength = ()=>{\n        const t = getViewportPercent();\n        const createScrollbarStyleFn = (t)=>(n)=>[\n                    n.Lt,\n                    {\n                        [e]: roundCssNumber(t) + \"\"\n                    }\n                ];\n        scrollbarStyle(S, createScrollbarStyleFn(t.x));\n        scrollbarStyle(m, createScrollbarStyleFn(t.y));\n    };\n    const refreshScrollbarsHandleOffset = ()=>{\n        if (!p) {\n            const { Dt: t } = o;\n            const n = getScrollCoordinatesPercent(t, getElementScroll(v));\n            const createScrollbarStyleFn = (t)=>(n)=>[\n                        n.Lt,\n                        {\n                            [c]: roundCssNumber(t) + \"\"\n                        }\n                    ];\n            scrollbarStyle(S, createScrollbarStyleFn(n.x));\n            scrollbarStyle(m, createScrollbarStyleFn(n.y));\n        }\n    };\n    const refreshScrollbarsScrollCoordinates = ()=>{\n        const { Dt: t } = o;\n        const n = isDefaultDirectionScrollCoordinates(t);\n        const createScrollbarStyleFn = (t)=>(n)=>[\n                    n.Lt,\n                    {\n                        [r]: t ? \"0\" : \"1\"\n                    }\n                ];\n        scrollbarStyle(S, createScrollbarStyleFn(n.x));\n        scrollbarStyle(m, createScrollbarStyleFn(n.y));\n        if (p) {\n            S.forEach(C.x.kt);\n            m.forEach(C.y.kt);\n        }\n    };\n    const refreshScrollbarsScrollbarOffset = ()=>{\n        if (h && !g) {\n            const { Rt: t, Dt: n } = o;\n            const s = isDefaultDirectionScrollCoordinates(n);\n            const e = getScrollCoordinatesPercent(n, getElementScroll(v));\n            const styleScrollbarPosition = (n)=>{\n                const { Lt: o } = n;\n                const c = parent(o) === _ && o;\n                const getTranslateValue = (t, n, o)=>{\n                    const s = n * t;\n                    return numberToCssPx(o ? s : -s);\n                };\n                return [\n                    c,\n                    c && {\n                        transform: getTrasformTranslateValue({\n                            x: getTranslateValue(e.x, t.x, s.x),\n                            y: getTranslateValue(e.y, t.y, s.y)\n                        })\n                    }\n                ];\n            };\n            scrollbarStyle(S, styleScrollbarPosition);\n            scrollbarStyle(m, styleScrollbarPosition);\n        }\n    };\n    const generateScrollbarDOM = (t)=>{\n        const n = t ? \"x\" : \"y\";\n        const o = t ? ft : _t;\n        const e = createDiv(\"\".concat(at, \" \").concat(o));\n        const c = createDiv(dt);\n        const r = createDiv(pt);\n        const i = {\n            Lt: e,\n            Ut: c,\n            Mt: r\n        };\n        const l = C[n];\n        push(t ? S : m, i);\n        push(y, [\n            appendChildren(e, c),\n            appendChildren(c, r),\n            bind(removeElements, e),\n            l && l.kt(i),\n            s(i, scrollbarsAddRemoveClass, t)\n        ]);\n        return i;\n    };\n    const $ = bind(generateScrollbarDOM, true);\n    const x = bind(generateScrollbarDOM, false);\n    const appendElements = ()=>{\n        appendChildren(O, S[0].Lt);\n        appendChildren(O, m[0].Lt);\n        return bind(runEachAndClear, y);\n    };\n    $();\n    x();\n    return [\n        {\n            Pt: refreshScrollbarsHandleLength,\n            Nt: refreshScrollbarsHandleOffset,\n            qt: refreshScrollbarsScrollCoordinates,\n            Bt: refreshScrollbarsScrollbarOffset,\n            Ft: scrollbarsAddRemoveClass,\n            jt: {\n                Xt: S,\n                Yt: $,\n                Wt: bind(scrollbarStyle, S)\n            },\n            Jt: {\n                Xt: m,\n                Yt: x,\n                Wt: bind(scrollbarStyle, m)\n            }\n        },\n        appendElements\n    ];\n};\nconst createScrollbarsSetupEvents = (t, n, o, s)=>(r, i, l)=>{\n        const { vt: u, L: f, V: _, gt: d, Gt: p, St: v } = n;\n        const { Lt: g, Ut: h, Mt: b } = r;\n        const [w, y] = selfClearTimeout(333);\n        const [S, m] = selfClearTimeout(444);\n        const scrollOffsetElementScrollBy = (t)=>{\n            if (isFunction(d.scrollBy)) {\n                d.scrollBy({\n                    behavior: \"smooth\",\n                    left: t.x,\n                    top: t.y\n                });\n            }\n        };\n        const createInteractiveScrollEvents = ()=>{\n            const n = \"pointerup pointercancel lostpointercapture\";\n            const s = \"client\".concat(l ? \"X\" : \"Y\");\n            const r = l ? C : $;\n            const i = l ? \"left\" : \"top\";\n            const a = l ? \"w\" : \"h\";\n            const u = l ? \"x\" : \"y\";\n            const createRelativeHandleMove = (t, n)=>(s)=>{\n                    const { Rt: e } = o;\n                    const c = A(h)[a] - A(b)[a];\n                    const r = n * s / c;\n                    const i = r * e[u];\n                    scrollElementTo(d, {\n                        [u]: t + i\n                    });\n                };\n            const f = [];\n            return addEventListener(h, \"pointerdown\", (o)=>{\n                const l = closest(o.target, \".\".concat(pt)) === b;\n                const _ = l ? b : h;\n                const g = t.scrollbars;\n                const w = g[l ? \"dragScroll\" : \"clickScroll\"];\n                const { button: y, isPrimary: O, pointerType: C } = o;\n                const { pointers: $ } = g;\n                const x = y === 0 && O && w && ($ || []).includes(C);\n                if (x) {\n                    runEachAndClear(f);\n                    m();\n                    const t = !l && (o.shiftKey || w === \"instant\");\n                    const g = bind(getBoundingClientRect, b);\n                    const y = bind(getBoundingClientRect, h);\n                    const getHandleOffset = (t, n)=>(t || g())[i] - (n || y())[i];\n                    const O = e(getBoundingClientRect(d)[r]) / A(d)[a] || 1;\n                    const C = createRelativeHandleMove(getElementScroll(d)[u], 1 / O);\n                    const $ = o[s];\n                    const x = g();\n                    const H = y();\n                    const E = x[r];\n                    const z = getHandleOffset(x, H) + E / 2;\n                    const I = $ - H[i];\n                    const T = l ? 0 : I - z;\n                    const releasePointerCapture = (t)=>{\n                        runEachAndClear(k);\n                        _.releasePointerCapture(t.pointerId);\n                    };\n                    const D = l || t;\n                    const M = v();\n                    const k = [\n                        addEventListener(p, n, releasePointerCapture),\n                        addEventListener(p, \"selectstart\", (t)=>preventDefault(t), {\n                            I: false\n                        }),\n                        addEventListener(h, n, releasePointerCapture),\n                        D && addEventListener(h, \"pointermove\", (t)=>C(T + (t[s] - $))),\n                        D && (()=>{\n                            const t = getElementScroll(d);\n                            M();\n                            const n = getElementScroll(d);\n                            const o = {\n                                x: n.x - t.x,\n                                y: n.y - t.y\n                            };\n                            if (c(o.x) > 3 || c(o.y) > 3) {\n                                v();\n                                scrollElementTo(d, t);\n                                scrollOffsetElementScrollBy(o);\n                                S(M);\n                            }\n                        })\n                    ];\n                    _.setPointerCapture(o.pointerId);\n                    if (t) {\n                        C(T);\n                    } else if (!l) {\n                        const t = getStaticPluginModuleInstance(Et);\n                        if (t) {\n                            const n = t(C, T, E, (t)=>{\n                                if (t) {\n                                    M();\n                                } else {\n                                    push(k, M);\n                                }\n                            });\n                            push(k, n);\n                            push(f, bind(n, true));\n                        }\n                    }\n                }\n            });\n        };\n        let O = true;\n        return bind(runEachAndClear, [\n            addEventListener(b, \"pointermove pointerleave\", s),\n            addEventListener(g, \"pointerenter\", ()=>{\n                i(ht, true);\n            }),\n            addEventListener(g, \"pointerleave pointercancel\", ()=>{\n                i(ht, false);\n            }),\n            !_ && addEventListener(g, \"mousedown\", ()=>{\n                const t = getFocusedElement();\n                if (hasAttr(t, j) || hasAttr(t, B) || t === document.body) {\n                    a(bind(focusElement, f), 25);\n                }\n            }),\n            addEventListener(g, \"wheel\", (t)=>{\n                const { deltaX: n, deltaY: o, deltaMode: s } = t;\n                if (O && s === 0 && parent(g) === u) {\n                    scrollOffsetElementScrollBy({\n                        x: n,\n                        y: o\n                    });\n                }\n                O = false;\n                i(St, true);\n                w(()=>{\n                    O = true;\n                    i(St);\n                });\n                preventDefault(t);\n            }, {\n                I: false,\n                A: true\n            }),\n            addEventListener(g, \"pointerdown\", ()=>{\n                const t = addEventListener(p, \"click\", (t)=>{\n                    n();\n                    stopAndPrevent(t);\n                }, {\n                    T: true,\n                    A: true,\n                    I: false\n                });\n                const n = addEventListener(p, \"pointerup pointercancel\", ()=>{\n                    n();\n                    setTimeout(t, 150);\n                }, {\n                    A: true,\n                    I: true\n                });\n            }, {\n                A: true,\n                I: true\n            }),\n            createInteractiveScrollEvents(),\n            y,\n            m\n        ]);\n    };\nconst createScrollbarsSetup = (t, n, o, s, e, c)=>{\n    let r;\n    let i;\n    let l;\n    let a;\n    let u;\n    let f = noop;\n    let _ = 0;\n    const d = [\n        \"mouse\",\n        \"pen\"\n    ];\n    const isHoverablePointerType = (t)=>d.includes(t.pointerType);\n    const [p, v] = selfClearTimeout();\n    const [g, h] = selfClearTimeout(100);\n    const [b, w] = selfClearTimeout(100);\n    const [y, S] = selfClearTimeout(()=>_);\n    const [m, O] = createScrollbarsSetupElements(t, e, s, createScrollbarsSetupEvents(n, e, s, (t)=>isHoverablePointerType(t) && manageScrollbarsAutoHideInstantInteraction()));\n    const { vt: C, Kt: $, bt: H } = e;\n    const { Ft: z, Pt: I, Nt: A, qt: T, Bt: D } = m;\n    const manageScrollbarsAutoHide = (t, n)=>{\n        S();\n        if (t) {\n            z(yt);\n        } else {\n            const t = bind(z, yt, true);\n            if (_ > 0 && !n) {\n                y(t);\n            } else {\n                t();\n            }\n        }\n    };\n    const manageScrollbarsAutoHideInstantInteraction = ()=>{\n        if (l ? !r : !a) {\n            manageScrollbarsAutoHide(true);\n            g(()=>{\n                manageScrollbarsAutoHide(false);\n            });\n        }\n    };\n    const manageAutoHideSuspension = (t)=>{\n        z(wt, t, true);\n        z(wt, t, false);\n    };\n    const onHostMouseEnter = (t)=>{\n        if (isHoverablePointerType(t)) {\n            r = l;\n            if (l) {\n                manageScrollbarsAutoHide(true);\n            }\n        }\n    };\n    const M = [\n        S,\n        h,\n        w,\n        v,\n        ()=>f(),\n        addEventListener(C, \"pointerover\", onHostMouseEnter, {\n            T: true\n        }),\n        addEventListener(C, \"pointerenter\", onHostMouseEnter),\n        addEventListener(C, \"pointerleave\", (t)=>{\n            if (isHoverablePointerType(t)) {\n                r = false;\n                if (l) {\n                    manageScrollbarsAutoHide(false);\n                }\n            }\n        }),\n        addEventListener(C, \"pointermove\", (t)=>{\n            if (isHoverablePointerType(t) && i) {\n                manageScrollbarsAutoHideInstantInteraction();\n            }\n        }),\n        addEventListener($, \"scroll\", (t)=>{\n            p(()=>{\n                A();\n                manageScrollbarsAutoHideInstantInteraction();\n            });\n            c(t);\n            D();\n        })\n    ];\n    const k = getStaticPluginModuleInstance(xt);\n    return [\n        ()=>bind(runEachAndClear, push(M, O())),\n        (param)=>{\n            let { zt: t, At: n, Qt: e, Zt: c } = param;\n            const { tn: r, nn: d, sn: p, en: v } = c || {};\n            const { Ct: g, ft: h } = e || {};\n            const { B: w } = o;\n            const { k: y, U: S } = getEnvironment();\n            const { cn: m, j: O } = s;\n            const [C, M] = t(\"showNativeOverlaidScrollbars\");\n            const [R, V] = t(\"scrollbars.theme\");\n            const [L, U] = t(\"scrollbars.visibility\");\n            const [P, N] = t(\"scrollbars.autoHide\");\n            const [q, B] = t(\"scrollbars.autoHideSuspend\");\n            const [F] = t(\"scrollbars.autoHideDelay\");\n            const [j, X] = t(\"scrollbars.dragScroll\");\n            const [Y, W] = t(\"scrollbars.clickScroll\");\n            const [J, G] = t(\"overflow\");\n            const K = h && !n;\n            const Q = O.x || O.y;\n            const Z = r || d || v || g || n;\n            const tt = p || U || G;\n            const nt = C && y.x && y.y;\n            const ot = !S && !k;\n            const st = nt || ot;\n            const setScrollbarVisibility = (t, n, o)=>{\n                const s = t.includes(E) && (L === x || L === \"auto\" && n === E);\n                z(vt, s, o);\n                return s;\n            };\n            _ = F;\n            if (K) {\n                if (q && Q) {\n                    manageAutoHideSuspension(false);\n                    f();\n                    b(()=>{\n                        f = addEventListener($, \"scroll\", bind(manageAutoHideSuspension, true), {\n                            T: true\n                        });\n                    });\n                } else {\n                    manageAutoHideSuspension(true);\n                }\n            }\n            if (M || ot) {\n                z(lt, st);\n            }\n            if (V) {\n                z(u);\n                z(R, true);\n                u = R;\n            }\n            if (B && !q) {\n                manageAutoHideSuspension(true);\n            }\n            if (N) {\n                i = P === \"move\";\n                l = P === \"leave\";\n                a = P === \"never\";\n                manageScrollbarsAutoHide(a, true);\n            }\n            if (X) {\n                z(Ot, j);\n            }\n            if (W) {\n                z(mt, !!Y);\n            }\n            if (tt) {\n                const t = setScrollbarVisibility(J.x, m.x, true);\n                const n = setScrollbarVisibility(J.y, m.y, false);\n                const o = t && n;\n                z(gt, !o);\n            }\n            if (Z) {\n                A();\n                I();\n                D();\n                if (v) {\n                    T();\n                }\n                z(bt, !O.x, true);\n                z(bt, !O.y, false);\n                z(ut, w && !H);\n            }\n        },\n        {},\n        m\n    ];\n};\nconst createStructureSetupElements = (t)=>{\n    const o = getEnvironment();\n    const { K: s, U: e } = o;\n    const { elements: c } = s();\n    const { padding: r, viewport: i, content: l } = c;\n    const a = isHTMLElement(t);\n    const u = a ? {} : t;\n    const { elements: f } = u;\n    const { padding: _, viewport: d, content: p } = f || {};\n    const v = a ? t : u.target;\n    const g = isBodyElement(v);\n    const h = v.ownerDocument;\n    const b = h.documentElement;\n    const getDocumentWindow = ()=>h.defaultView || n;\n    const w = bind(staticInitializationElement, [\n        v\n    ]);\n    const y = bind(dynamicInitializationElement, [\n        v\n    ]);\n    const S = bind(createDiv, \"\");\n    const C = bind(w, S, i);\n    const $ = bind(y, S, l);\n    const elementHasOverflow = (t)=>{\n        const n = A(t);\n        const o = D(t);\n        const s = getStyles(t, m);\n        const e = getStyles(t, O);\n        return o.w - n.w > 0 && !overflowIsVisible(s) || o.h - n.h > 0 && !overflowIsVisible(e);\n    };\n    const x = C(d);\n    const H = x === v;\n    const E = H && g;\n    const z = !H && $(p);\n    const I = !H && x === z;\n    const T = E ? b : x;\n    const M = E ? T : v;\n    const k = !H && y(S, r, _);\n    const R = !I && z;\n    const V = [\n        R,\n        T,\n        k,\n        M\n    ].map((t)=>isHTMLElement(t) && !parent(t) && t);\n    const elementIsGenerated = (t)=>t && inArray(V, t);\n    const L = !elementIsGenerated(T) && elementHasOverflow(T) ? T : v;\n    const U = E ? b : T;\n    const N = E ? h : T;\n    const X = {\n        dt: v,\n        vt: M,\n        L: T,\n        rn: k,\n        ht: R,\n        gt: U,\n        Kt: N,\n        ln: g ? b : L,\n        Gt: h,\n        bt: g,\n        Tt: a,\n        V: H,\n        an: getDocumentWindow,\n        wt: (t)=>hasAttrClass(T, j, t),\n        yt: (t, n)=>addRemoveAttrClass(T, j, t, n),\n        St: ()=>addRemoveAttrClass(U, j, G, true)\n    };\n    const { dt: Y, vt: W, rn: J, L: Q, ht: nt } = X;\n    const ot = [\n        ()=>{\n            removeAttrs(W, [\n                B,\n                P\n            ]);\n            removeAttrs(Y, P);\n            if (g) {\n                removeAttrs(b, [\n                    P,\n                    B\n                ]);\n            }\n        }\n    ];\n    let st = contents([\n        nt,\n        Q,\n        J,\n        W,\n        Y\n    ].find((t)=>t && !elementIsGenerated(t)));\n    const et = E ? Y : nt || Q;\n    const ct = bind(runEachAndClear, ot);\n    const appendElements = ()=>{\n        const t = getDocumentWindow();\n        const n = getFocusedElement();\n        const unwrap = (t)=>{\n            appendChildren(parent(t), contents(t));\n            removeElements(t);\n        };\n        const prepareWrapUnwrapFocus = (t)=>addEventListener(t, \"focusin focusout focus blur\", stopAndPrevent, {\n                A: true,\n                I: false\n            });\n        const o = \"tabindex\";\n        const s = getAttr(Q, o);\n        const c = prepareWrapUnwrapFocus(n);\n        setAttrs(W, B, H ? \"\" : F);\n        setAttrs(J, Z, \"\");\n        setAttrs(Q, j, \"\");\n        setAttrs(nt, tt, \"\");\n        if (!H) {\n            setAttrs(Q, o, s || \"-1\");\n            if (g) {\n                setAttrs(b, q, \"\");\n            }\n        }\n        appendChildren(et, st);\n        appendChildren(W, J);\n        appendChildren(J || W, !H && Q);\n        appendChildren(Q, nt);\n        push(ot, [\n            c,\n            ()=>{\n                const t = getFocusedElement();\n                const n = elementIsGenerated(Q);\n                const e = n && t === Q ? Y : t;\n                const c = prepareWrapUnwrapFocus(e);\n                removeAttrs(J, Z);\n                removeAttrs(nt, tt);\n                removeAttrs(Q, j);\n                if (g) {\n                    removeAttrs(b, q);\n                }\n                if (s) {\n                    setAttrs(Q, o, s);\n                } else {\n                    removeAttrs(Q, o);\n                }\n                if (elementIsGenerated(nt)) {\n                    unwrap(nt);\n                }\n                if (n) {\n                    unwrap(Q);\n                }\n                if (elementIsGenerated(J)) {\n                    unwrap(J);\n                }\n                focusElement(e);\n                c();\n            }\n        ]);\n        if (e && !H) {\n            addAttrClass(Q, j, K);\n            push(ot, bind(removeAttrs, Q, j));\n        }\n        focusElement(!H && g && n === Y && t.top === t ? Q : n);\n        c();\n        st = 0;\n        return ct;\n    };\n    return [\n        X,\n        appendElements,\n        ct\n    ];\n};\nconst createTrinsicUpdateSegment = (param)=>{\n    let { ht: t } = param;\n    return (param)=>{\n        let { Qt: n, un: o, At: s } = param;\n        const { $t: e } = n || {};\n        const { Ot: c } = o;\n        const r = t && (e || s);\n        if (r) {\n            setStyles(t, {\n                [$]: c && \"100%\"\n            });\n        }\n    };\n};\nconst createPaddingUpdateSegment = (param, e)=>{\n    let { vt: t, rn: n, L: o, V: s } = param;\n    const [c, r] = createCache({\n        i: equalTRBL,\n        o: topRightBottomLeft()\n    }, bind(topRightBottomLeft, t, \"padding\", \"\"));\n    return (param)=>{\n        let { zt: t, Qt: i, un: l, At: a } = param;\n        let [u, f] = r(a);\n        const { U: _ } = getEnvironment();\n        const { _t: d, xt: p, Ct: m } = i || {};\n        const { B: O } = l;\n        const [$, x] = t(\"paddingAbsolute\");\n        const H = a || p;\n        if (d || f || H) {\n            [u, f] = c(a);\n        }\n        const E = !s && (x || m || f);\n        if (E) {\n            const t = !$ || !n && !_;\n            const s = u.r + u.l;\n            const c = u.t + u.b;\n            const r = {\n                [y]: t && !O ? -s : 0,\n                [S]: t ? -c : 0,\n                [w]: t && O ? -s : 0,\n                top: t ? -u.t : 0,\n                right: t ? O ? -u.r : \"auto\" : 0,\n                left: t ? O ? \"auto\" : -u.l : 0,\n                [C]: t && \"calc(100% + \".concat(s, \"px)\")\n            };\n            const i = {\n                [v]: t ? u.t : 0,\n                [g]: t ? u.r : 0,\n                [b]: t ? u.b : 0,\n                [h]: t ? u.l : 0\n            };\n            setStyles(n || o, r);\n            setStyles(o, i);\n            assignDeep(e, {\n                rn: u,\n                fn: !t,\n                F: n ? i : assignDeep({}, r, i)\n            });\n        }\n        return {\n            _n: E\n        };\n    };\n};\nconst createOverflowUpdateSegment = (t, s)=>{\n    const e = getEnvironment();\n    const { vt: r, rn: i, L: a, V: u, Kt: f, gt: _, bt: d, yt: p, an: v } = t;\n    const { U: g } = e;\n    const h = d && u;\n    const b = bind(o, 0);\n    const w = {\n        display: ()=>false,\n        direction: (t)=>t !== \"ltr\",\n        flexDirection: (t)=>t.endsWith(\"-reverse\"),\n        writingMode: (t)=>t !== \"horizontal-tb\"\n    };\n    const y = keys(w);\n    const S = {\n        i: equalWH,\n        o: {\n            w: 0,\n            h: 0\n        }\n    };\n    const m = {\n        i: equalXY,\n        o: {}\n    };\n    const setMeasuringMode = (t)=>{\n        p(J, !h && t);\n    };\n    const getFlowDirectionStyles = ()=>getStyles(a, y);\n    const getMeasuredScrollCoordinates = (t, n)=>{\n        const o = !keys(t).length;\n        const s = !n && y.some((n)=>{\n            const o = t[n];\n            return isString(o) && w[n](o);\n        });\n        const e = o && !s;\n        if (e || !hasDimensions(a)) {\n            return {\n                D: {\n                    x: 0,\n                    y: 0\n                },\n                M: {\n                    x: 1,\n                    y: 1\n                }\n            };\n        }\n        setMeasuringMode(true);\n        const r = getElementScroll(_);\n        const i = p(Q, true);\n        const u = addEventListener(f, E, (t)=>{\n            const n = getElementScroll(_);\n            if (t.isTrusted && n.x === r.x && n.y === r.y) {\n                stopPropagation(t);\n            }\n        }, {\n            A: true,\n            T: true\n        });\n        scrollElementTo(_, {\n            x: 0,\n            y: 0\n        });\n        i();\n        const d = getElementScroll(_);\n        const v = D(_);\n        scrollElementTo(_, {\n            x: v.w,\n            y: v.h\n        });\n        const g = getElementScroll(_);\n        const h = {\n            x: g.x - d.x,\n            y: g.y - d.y\n        };\n        scrollElementTo(_, {\n            x: -v.w,\n            y: -v.h\n        });\n        const b = getElementScroll(_);\n        const S = {\n            x: b.x - d.x,\n            y: b.y - d.y\n        };\n        const m = {\n            x: c(h.x) >= c(S.x) ? g.x : b.x,\n            y: c(h.y) >= c(S.y) ? g.y : b.y\n        };\n        scrollElementTo(_, r);\n        l(()=>u());\n        return {\n            D: d,\n            M: m\n        };\n    };\n    const getOverflowAmount = (t, o)=>{\n        const s = n.devicePixelRatio % 1 !== 0 ? 1 : 0;\n        const e = {\n            w: b(t.w - o.w),\n            h: b(t.h - o.h)\n        };\n        return {\n            w: e.w > s ? e.w : 0,\n            h: e.h > s ? e.h : 0\n        };\n    };\n    const getViewportOverflowStyle = (t, n)=>{\n        const getAxisOverflowStyle = (t, n, o, s)=>{\n            const e = t === x ? H : overflowBehaviorToOverflowStyle(t);\n            const c = overflowIsVisible(t);\n            const r = overflowIsVisible(o);\n            if (!n && !s) {\n                return H;\n            }\n            if (c && r) {\n                return x;\n            }\n            if (c) {\n                const t = n ? x : H;\n                return n && s ? e : t;\n            }\n            const i = r && s ? x : H;\n            return n ? e : i;\n        };\n        return {\n            x: getAxisOverflowStyle(n.x, t.x, n.y, t.y),\n            y: getAxisOverflowStyle(n.y, t.y, n.x, t.x)\n        };\n    };\n    const setViewportOverflowStyle = (t)=>{\n        const createAllOverflowStyleClassNames = (t)=>[\n                x,\n                H,\n                E\n            ].map((n)=>createViewportOverflowStyleClassName(overflowCssValueToOverflowStyle(n), t));\n        const n = createAllOverflowStyleClassNames(true).concat(createAllOverflowStyleClassNames()).join(\" \");\n        p(n);\n        p(keys(t).map((n)=>createViewportOverflowStyleClassName(t[n], n === \"x\")).join(\" \"), true);\n    };\n    const [O, C] = createCache(S, bind(getFractionalSize, a));\n    const [$, z] = createCache(S, bind(D, a));\n    const [I, A] = createCache(S);\n    const [M] = createCache(m);\n    const [k, R] = createCache(S);\n    const [V] = createCache(m);\n    const [L] = createCache({\n        i: (t, n)=>equal(t, n, deduplicateArray(concat(keys(t), keys(n)))),\n        o: {}\n    });\n    const [U, P] = createCache({\n        i: (t, n)=>equalXY(t.D, n.D) && equalXY(t.M, n.M),\n        o: getZeroScrollCoordinates()\n    });\n    const q = getStaticPluginModuleInstance(xt);\n    const createViewportOverflowStyleClassName = (t, n)=>{\n        const o = n ? X : Y;\n        return \"\".concat(o).concat(capitalizeFirstLetter(t));\n    };\n    return (param, param1)=>{\n        let { zt: n, Qt: o, un: c, At: l } = param, { _n: u } = param1;\n        const { _t: f, Ht: _, xt: d, Ct: w, ft: y, Et: S } = o || {};\n        const m = q && q.R(t, s, c, e, n);\n        const { X: x, Y: H, W: E } = m || {};\n        const [D, F] = getShowNativeOverlaidScrollbars(n, e);\n        const [j, X] = n(\"overflow\");\n        const Y = overflowIsVisible(j.x);\n        const W = overflowIsVisible(j.y);\n        const J = f || u || d || w || S || F;\n        let G = C(l);\n        let Q = z(l);\n        let tt = A(l);\n        let nt = R(l);\n        if (F && g) {\n            p(K, !D);\n        }\n        if (J) {\n            if (hasAttrClass(r, B, N)) {\n                setMeasuringMode(true);\n            }\n            const t = H && H();\n            const [n] = G = O(l);\n            const [o] = Q = $(l);\n            const s = T(a);\n            const e = h && getWindowSize(v());\n            const c = {\n                w: b(o.w + n.w),\n                h: b(o.h + n.h)\n            };\n            const i = {\n                w: b((e ? e.w : s.w + b(s.w - o.w)) + n.w),\n                h: b((e ? e.h : s.h + b(s.h - o.h)) + n.h)\n            };\n            if (t) {\n                t();\n            }\n            nt = k(i);\n            tt = I(getOverflowAmount(c, i), l);\n        }\n        const [ot, st] = nt;\n        const [et, ct] = tt;\n        const [rt, it] = Q;\n        const [lt, at] = G;\n        const [ut, ft] = M({\n            x: et.w > 0,\n            y: et.h > 0\n        });\n        const _t = Y && W && (ut.x || ut.y) || Y && ut.x && !ut.y || W && ut.y && !ut.x;\n        const dt = u || w || S || at || it || st || ct || X || F || J || _ && h;\n        const [pt] = n(\"update.flowDirectionStyles\");\n        const [vt, gt] = L(pt ? pt(a) : getFlowDirectionStyles(), l);\n        const ht = w || y || gt || ft || l;\n        const [bt, wt] = ht ? U(getMeasuredScrollCoordinates(vt, !!pt), l) : P();\n        let yt = getViewportOverflowStyle(ut, j);\n        setMeasuringMode(false);\n        if (dt) {\n            setViewportOverflowStyle(yt);\n            yt = getElementOverflowStyle(a, ut);\n            if (E && x) {\n                x(yt, rt, lt);\n                setStyles(a, E(yt));\n            }\n        }\n        const [St, mt] = V(yt);\n        addRemoveAttrClass(r, B, N, _t);\n        addRemoveAttrClass(i, Z, N, _t);\n        assignDeep(s, {\n            cn: St,\n            Vt: {\n                x: ot.w,\n                y: ot.h\n            },\n            Rt: {\n                x: et.w,\n                y: et.h\n            },\n            j: ut,\n            Dt: sanitizeScrollCoordinates(bt, et)\n        });\n        return {\n            sn: mt,\n            tn: st,\n            nn: ct,\n            en: wt || ct\n        };\n    };\n};\nconst createStructureSetup = (t)=>{\n    const [n, o, s] = createStructureSetupElements(t);\n    const e = {\n        rn: {\n            t: 0,\n            r: 0,\n            b: 0,\n            l: 0\n        },\n        fn: false,\n        F: {\n            [y]: 0,\n            [S]: 0,\n            [w]: 0,\n            [v]: 0,\n            [g]: 0,\n            [b]: 0,\n            [h]: 0\n        },\n        Vt: {\n            x: 0,\n            y: 0\n        },\n        Rt: {\n            x: 0,\n            y: 0\n        },\n        cn: {\n            x: H,\n            y: H\n        },\n        j: {\n            x: false,\n            y: false\n        },\n        Dt: getZeroScrollCoordinates()\n    };\n    const { dt: c, gt: r, V: i, St: l } = n;\n    const { U: a, k: u } = getEnvironment();\n    const f = !a && (u.x || u.y);\n    const _ = [\n        createTrinsicUpdateSegment(n),\n        createPaddingUpdateSegment(n, e),\n        createOverflowUpdateSegment(n, e)\n    ];\n    return [\n        o,\n        (t)=>{\n            const n = {};\n            const o = f;\n            const s = o && getElementScroll(r);\n            const e = s && l();\n            each(_, (o)=>{\n                assignDeep(n, o(t, n) || {});\n            });\n            scrollElementTo(r, s);\n            if (e) {\n                e();\n            }\n            if (!i) {\n                scrollElementTo(c, 0);\n            }\n            return n;\n        },\n        e,\n        n,\n        s\n    ];\n};\nconst createSetups = (t, n, o, s, e)=>{\n    let c = false;\n    const r = createOptionCheck(n, {});\n    const [i, l, a, u, f] = createStructureSetup(t);\n    const [_, d, p] = createObserversSetup(u, a, r, (t)=>{\n        update({}, t);\n    });\n    const [v, g, , h] = createScrollbarsSetup(t, n, p, a, u, e);\n    const updateHintsAreTruthy = (t)=>keys(t).some((n)=>!!t[n]);\n    const update = (t, e)=>{\n        if (o()) {\n            return false;\n        }\n        const { dn: r, At: i, It: a, pn: u } = t;\n        const f = r || {};\n        const _ = !!i || !c;\n        const v = {\n            zt: createOptionCheck(n, f, _),\n            dn: f,\n            At: _\n        };\n        if (u) {\n            g(v);\n            return false;\n        }\n        const h = e || d(assignDeep({}, v, {\n            It: a\n        }));\n        const b = l(assignDeep({}, v, {\n            un: p,\n            Qt: h\n        }));\n        g(assignDeep({}, v, {\n            Qt: h,\n            Zt: b\n        }));\n        const w = updateHintsAreTruthy(h);\n        const y = updateHintsAreTruthy(b);\n        const S = w || y || !isEmptyObject(f) || _;\n        c = true;\n        if (S) {\n            s(t, {\n                Qt: h,\n                Zt: b\n            });\n        }\n        return S;\n    };\n    return [\n        ()=>{\n            const { ln: t, gt: n, St: o } = u;\n            const s = getElementScroll(t);\n            const e = [\n                _(),\n                i(),\n                v()\n            ];\n            const c = o();\n            scrollElementTo(n, s);\n            c();\n            return bind(runEachAndClear, e);\n        },\n        update,\n        ()=>({\n                vn: p,\n                gn: a\n            }),\n        {\n            hn: u,\n            bn: h\n        },\n        f\n    ];\n};\nconst Vt = new WeakMap;\nconst addInstance = (t, n)=>{\n    Vt.set(t, n);\n};\nconst removeInstance = (t)=>{\n    Vt.delete(t);\n};\nconst getInstance = (t)=>Vt.get(t);\nconst OverlayScrollbars = (t, n, o)=>{\n    const { tt: s } = getEnvironment();\n    const e = isHTMLElement(t);\n    const c = e ? t : t.target;\n    const r = getInstance(c);\n    if (n && !r) {\n        let r = false;\n        const i = [];\n        const l = {};\n        const validateOptions = (t)=>{\n            const n = removeUndefinedProperties(t);\n            const o = getStaticPluginModuleInstance(R);\n            return o ? o(n, true) : n;\n        };\n        const a = assignDeep({}, s(), validateOptions(n));\n        const [u, f, _] = createEventListenerHub();\n        const [d, p, v] = createEventListenerHub(o);\n        const triggerEvent = (t, n)=>{\n            v(t, n);\n            _(t, n);\n        };\n        const [g, h, b, w, y] = createSetups(t, a, ()=>r, (param, param1)=>{\n            let { dn: t, At: n } = param, { Qt: o, Zt: s } = param1;\n            const { _t: e, Ct: c, $t: r, xt: i, Ht: l, ft: a } = o;\n            const { tn: u, nn: f, sn: _, en: d } = s;\n            triggerEvent(\"updated\", [\n                S,\n                {\n                    updateHints: {\n                        sizeChanged: !!e,\n                        directionChanged: !!c,\n                        heightIntrinsicChanged: !!r,\n                        overflowEdgeChanged: !!u,\n                        overflowAmountChanged: !!f,\n                        overflowStyleChanged: !!_,\n                        scrollCoordinatesChanged: !!d,\n                        contentMutation: !!i,\n                        hostMutation: !!l,\n                        appear: !!a\n                    },\n                    changedOptions: t || {},\n                    force: !!n\n                }\n            ]);\n        }, (t)=>triggerEvent(\"scroll\", [\n                S,\n                t\n            ]));\n        const destroy = (t)=>{\n            removeInstance(c);\n            runEachAndClear(i);\n            r = true;\n            triggerEvent(\"destroyed\", [\n                S,\n                t\n            ]);\n            f();\n            p();\n        };\n        const S = {\n            options (t, n) {\n                if (t) {\n                    const o = n ? s() : {};\n                    const e = getOptionsDiff(a, assignDeep(o, validateOptions(t)));\n                    if (!isEmptyObject(e)) {\n                        assignDeep(a, e);\n                        h({\n                            dn: e\n                        });\n                    }\n                }\n                return assignDeep({}, a);\n            },\n            on: d,\n            off: (t, n)=>{\n                if (t && n) {\n                    p(t, n);\n                }\n            },\n            state () {\n                const { vn: t, gn: n } = b();\n                const { B: o } = t;\n                const { Vt: s, Rt: e, cn: c, j: i, rn: l, fn: a, Dt: u } = n;\n                return assignDeep({}, {\n                    overflowEdge: s,\n                    overflowAmount: e,\n                    overflowStyle: c,\n                    hasOverflow: i,\n                    scrollCoordinates: {\n                        start: u.D,\n                        end: u.M\n                    },\n                    padding: l,\n                    paddingAbsolute: a,\n                    directionRTL: o,\n                    destroyed: r\n                });\n            },\n            elements () {\n                const { dt: t, vt: n, rn: o, L: s, ht: e, gt: c, Kt: r } = w.hn;\n                const { jt: i, Jt: l } = w.bn;\n                const translateScrollbarStructure = (t)=>{\n                    const { Mt: n, Ut: o, Lt: s } = t;\n                    return {\n                        scrollbar: s,\n                        track: o,\n                        handle: n\n                    };\n                };\n                const translateScrollbarsSetupElement = (t)=>{\n                    const { Xt: n, Yt: o } = t;\n                    const s = translateScrollbarStructure(n[0]);\n                    return assignDeep({}, s, {\n                        clone: ()=>{\n                            const t = translateScrollbarStructure(o());\n                            h({\n                                pn: true\n                            });\n                            return t;\n                        }\n                    });\n                };\n                return assignDeep({}, {\n                    target: t,\n                    host: n,\n                    padding: o || s,\n                    viewport: s,\n                    content: e || s,\n                    scrollOffsetElement: c,\n                    scrollEventElement: r,\n                    scrollbarHorizontal: translateScrollbarsSetupElement(i),\n                    scrollbarVertical: translateScrollbarsSetupElement(l)\n                });\n            },\n            update: (t)=>h({\n                    At: t,\n                    It: true\n                }),\n            destroy: bind(destroy, false),\n            plugin: (t)=>l[keys(t)[0]]\n        };\n        push(i, [\n            y\n        ]);\n        addInstance(c, S);\n        registerPluginModuleInstances(M, OverlayScrollbars, [\n            S,\n            u,\n            l\n        ]);\n        if (cancelInitialization(w.hn.bt, !e && t.cancel)) {\n            destroy(true);\n            return S;\n        }\n        push(i, g());\n        triggerEvent(\"initialized\", [\n            S\n        ]);\n        S.update();\n        return S;\n    }\n    return r;\n};\n_c = OverlayScrollbars;\nOverlayScrollbars.plugin = (t)=>{\n    const n = isArray(t);\n    const o = n ? t : [\n        t\n    ];\n    const s = o.map((t)=>registerPluginModuleInstances(t, OverlayScrollbars)[0]);\n    addPlugins(o);\n    return n ? s : s[0];\n};\nOverlayScrollbars.valid = (t)=>{\n    const n = t && t.elements;\n    const o = isFunction(n) && n();\n    return isPlainObject(o) && !!getInstance(o.target);\n};\nOverlayScrollbars.env = ()=>{\n    const { P: t, k: n, U: o, J: s, ot: e, st: c, K: r, Z: i, tt: l, nt: a } = getEnvironment();\n    return assignDeep({}, {\n        scrollbarsSize: t,\n        scrollbarsOverlaid: n,\n        scrollbarsHiding: o,\n        scrollTimeline: s,\n        staticDefaultInitialization: e,\n        staticDefaultOptions: c,\n        getDefaultInitialization: r,\n        setDefaultInitialization: i,\n        getDefaultOptions: l,\n        setDefaultOptions: a\n    });\n};\nOverlayScrollbars.nonce = setNonce;\nOverlayScrollbars.trustedTypePolicy = setTrustedTypePolicy;\n //# sourceMappingURL=overlayscrollbars.mjs.map\nvar _c;\n$RefreshReg$(_c, \"OverlayScrollbars\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9wYWNrYWdlcy9vdmVybGF5c2Nyb2xsYmFycy9kaXN0L292ZXJsYXlzY3JvbGxiYXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7SUFrQ08sTUFBTUEsY0FBMkJBLENBQ3RDQyxHQUNBQztJQUVBLFFBQU1DLEdBQUVDLENBQUFBLEVBQWFDLEdBQUVDLENBQUFBLEVBQU1DLEdBQUVDLENBQUFBLEVBQUFBLEdBQXdCUDtJQUN2RCxJQUFJUSxJQUFnQkw7SUFDcEIsSUFBSU07SUFFSixNQUFNQyx3QkFBc0RBLENBQUNDLEdBQVVDO1FBQ3JFLE1BQU1DLElBQU9MO1FBRWIsTUFBTU0sSUFBU0g7UUFDZixNQUFNSSxJQUFVSCxLQUFVUCxDQUFBQSxJQUFBQSxDQUFVQSxFQUFPUSxHQUFNQyxLQUFVRCxNQUFTQyxDQUFBQTtRQUVwRSxJQUFJQyxLQUFXUixHQUFxQjtZQUNsQ0MsSUFBU007WUFDVEwsSUFBWUk7UUFDZDtRQUVBLE9BQU87WUFBQ0w7WUFBUU87WUFBU047U0FBQUE7SUFBVTtJQUVyQyxNQUFNTyxzQkFBMkNKLENBQUFBLElBQy9DRixzQkFBc0JULEVBQVFPLEdBQVFDLElBQVlHO0lBRXBELE1BQU1LLGtCQUEyQ0wsQ0FBQUEsSUFBb0I7WUFDbkVKO1lBQUFBLENBQUFBLENBQ0VJO1lBQ0ZIO1NBQUFBO0lBR0YsT0FBTztRQUFDUixJQUFTZSxzQkFBc0JOO1FBQXVCTztLQUFBQTtBQUU5QztBQ2xFWCxNQUFNQyxJQUFBQSxLQUVPLFdBRVhDLGdCQUFnQixpQkFFckJDLE9BQU9DLFFBQUFBO0FDSkosTUFBTUMsSUFBT0osSUFBWUUsU0FBUyxDQUFvQjtBQUN0RCxNQUFNRyxJQUFVQyxLQUFLQyxHQUFBQTtBQUNyQixNQUFNQyxJQUFVRixLQUFLRyxHQUFBQTtBQUNyQixNQUFNQyxJQUFZSixLQUFLSyxLQUFBQTtBQUd2QixNQUFNQyxJQUFVTixLQUFLTyxHQUFBQTtBQUNyQixNQUFNQyxJQUFXUixLQUFLUyxJQUFBQTtBQUN0QixNQUFNQyxJQUFNWixFQUFJYSxvQkFBQUE7QUFDaEIsTUFBTUMsSUFBTWQsRUFBSWUscUJBQUFBO0FBQ2hCLE1BQU1DLElBQU9oQixFQUFJaUIsVUFBQUE7QUFDakIsTUFBTUMsSUFBU2xCLEVBQUltQixZQUFBQTtBQ1gxQixNQUFNQyxTQUFhQyxDQUFBQSxJQUFBQSxPQUNUckIsQ0FBQUEsQ0FBSXFCLEVBQUFBLEtBQThCLGNBQ3RDckIsQ0FBQUEsQ0FBSXFCLEVBQUFBLEdBQUFBLEtBQ0pDO0FBRUMsTUFBTUMsSUFBOEJILE9BQWdDO0FBQ3BFLE1BQU1JLElBQ1hKLE9BQW9DO0FBQy9CLE1BQU1LLElBQTRCTCxPQUE4QjtBQUNoRSxNQUFNTSxJQUFVTixPQUF3RDtBQ1J4RSxNQUFNTyxjQUFlQyxDQUFBQSxJQUErQkEsTUFBQUEsS0FBUU47QUFFNUQsTUFBTU8sU0FBVUQsQ0FBQUEsSUFBMEJBLE1BQVE7QUFVbEQsTUFBTUUsV0FBWUYsQ0FBQUEsSUFBQUEsT0FBbUNBLE1BQVE7QUFFN0QsTUFBTUcsV0FBWUgsQ0FBQUEsSUFBQUEsT0FBbUNBLE1BQVE7QUFFN0QsTUFBTUksWUFBYUosQ0FBQUEsSUFBQUEsT0FBb0NBLE1BQVE7QUFFL0QsTUFBTUssYUFBY0wsQ0FBQUEsSUFBQUEsT0FBb0RBLE1BQVE7QUFFaEYsTUFBTU0sVUFBb0JOLENBQUFBLElBQThCTyxNQUFNRCxPQUFBQSxDQUFRTjtBQUV0RSxNQUFNUSxXQUFZUixDQUFBQSxJQUFBQSxPQUNoQkEsTUFBUSxhQUFhTSxRQUFRTixNQUFBQSxDQUFTQyxPQUFPRDtBQU0vQyxNQUFNUyxjQUE0Q1QsQ0FBQUE7SUFDdkQsTUFBTVUsSUFBQUEsQ0FBQUEsQ0FBV1YsS0FBT0EsRUFBSVUsTUFBQUE7SUFDNUIsTUFBTUMsSUFBc0JULFNBQVNRLE1BQVdBLElBQUFBLENBQUFBLEtBQWVBLElBQVMsS0FBSztJQUU3RSxPQUFPSixRQUFRTixNQUFBQSxDQUFVSyxXQUFXTCxNQUFRVyxJQUN4Q0QsSUFBUyxLQUFLRixTQUFTUixLQUNyQlUsSUFBUyxLQUFLVixJQUNkLE9BQ0Y7QUFBSztBQU9KLE1BQU1ZLGdCQUEwQlosQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FDbkNBLEtBQU9BLEVBQUlhLFdBQUFBLEtBQWdCQztBQU14QixNQUFNQyxnQkFBaUJmLENBQUFBLElBQWlDQSxhQUFlL0I7QUFNdkUsTUFBTStDLFlBQWFoQixDQUFBQSxJQUE2QkEsYUFBZWlCO0FDMUN0RSxNQUFNQyx1QkFBdUJBLElBQU1DLFlBQVlDLEdBQUFBO0FBRXhDLE1BQU1DLGdCQUFnQkEsQ0FDM0JDLEdBQ0FDLEdBQ0FDLEdBRUFDLEdBQ0FDO0lBRUEsSUFBSUMsSUFBbUI7SUFDdkIsTUFBTUMsSUFBWVY7SUFDbEIsTUFBTVcsSUFBZ0J4RCxFQUFRLEdBQUdtRDtJQUNqQyxNQUFNTSxRQUFTQyxDQUFBQTtRQUNiLE1BQU1DLElBQVVkO1FBQ2hCLE1BQU1lLElBQWNELElBQVVKO1FBQzlCLE1BQU1NLElBQWdCRCxLQUFlSjtRQUNyQyxNQUFNTSxJQUFVSixJQUNaLElBQ0EsSUFBSzFELENBQUFBLEVBQVEsR0FBR3VELElBQVlDLElBQWdCRyxLQUFXSCxLQUFpQjtRQUM1RSxNQUFNTyxJQUFBQSxDQUNIYixJQUFLRCxDQUFBQSxJQUNIakIsQ0FBQUEsV0FBV3FCLEtBQ1JBLEVBQU9TLEdBQVNBLElBQVVOLEdBQWUsR0FBRyxHQUFHQSxLQUMvQ00sQ0FBQUEsSUFDTmI7UUFDRixNQUFNZSxJQUFxQkgsS0FBaUJDLE1BQVk7UUFFeEQsSUFBSVYsR0FBQUE7WUFDRkEsRUFBUVcsR0FBVUQsR0FBU0U7O1FBRzdCVixJQUFtQlUsSUFBcUIsSUFBSW5ELEVBQUssSUFBTTRDO0lBQVE7SUFFakVBO0lBQ0EsT0FBUUMsQ0FBQUE7UUFDTi9DLEVBQUsyQztRQUNMLElBQUlJLEdBQUFBO1lBQ0ZELE1BQU1DOztJQUNSO0FBQ0Q7QUNoQ2EsU0FBQU8sS0FDZEMsQ0FBQUEsRUFDQUMsQ0FBQUE7SUFFQSxJQUFJL0IsWUFBWThCLElBQUFBO1FBQ2QsSUFBSyxJQUFJckYsSUFBSSxHQUFHQSxJQUFJcUYsRUFBTzdCLE1BQUFBLEVBQVF4RCxJQUFBQTtZQUNqQyxJQUFJc0YsRUFBU0QsQ0FBQUEsQ0FBT3JGLEVBQUFBLEVBQUlBLEdBQUdxRixPQUFZO2dCQUNyQzs7O1dBR0MsSUFBSUEsR0FBQUE7UUFFVEQsS0FBS3hCLE9BQU8yQixJQUFBQSxDQUFLRixJQUFVRyxDQUFBQSxJQUFRRixFQUFTRCxDQUFBQSxDQUFPRyxFQUFBQSxFQUFNQSxHQUFLSDs7SUFFaEUsT0FBT0E7QUFDVDtBQVFPLE1BQU1JLFVBQVVBLENBQVVDLEdBQXlCQyxJQUN4REQsRUFBSUUsT0FBQUEsQ0FBUUQsTUFBUztBQVFoQixNQUFNRSxTQUFTQSxDQUFJQyxHQUEyQkMsSUFBbUNELEVBQUVELE1BQUFBLENBQU9FO0FBTzFGLE1BQU1DLE9BQU9BLENBQUlDLEdBQVlDLEdBQXlCQztJQUMzRCxLQUEyQmxELFNBQVNpRCxNQUFVM0MsWUFBWTJDLElBQUFBO1FBQ3hEN0MsTUFBTStDLFNBQUFBLENBQVVKLElBQUFBLENBQUtLLEtBQUFBLENBQU1KLEdBQU9DOztRQUVsQ0QsRUFBTUQsSUFBQUEsQ0FBS0U7O0lBRWIsT0FBT0Q7QUFBSztBQU9QLE1BQU03QixPQUFpQnNCLENBQUFBLElBQWdDckMsTUFBTWUsSUFBQUEsQ0FBS3NCLEtBQU87QUFRekUsTUFBTVksb0JBQXdCQyxDQUFBQTtJQUNuQyxJQUFJbkQsUUFBUW1ELElBQUFBO1FBQ1YsT0FBT0E7O0lBRVQsUUFBUXRELFNBQVNzRCxNQUFVaEQsWUFBWWdELEtBQVNuQyxLQUFLbUMsS0FBUztRQUFDQTtLQUFBQTtBQUFNO0FBT2hFLE1BQU1DLGVBQWdCUCxDQUFBQSxJQUFBQSxDQUFBQSxDQUErQ0EsS0FBQUEsQ0FBVUEsRUFBTXpDLE1BQUFBO0FBT3JGLE1BQU1pRCxtQkFBc0RSLENBQUFBLElBQ2pFN0IsS0FBSyxJQUFJc0MsSUFBSVQ7QUFRUixNQUFNVSxrQkFBa0JBLENBQUNqQixHQUFvQmtCLEdBQWNDO0lBRWhFLE1BQU1DLFFBQVNDLENBQUFBLElBQXFCQSxJQUFLQSxFQUFHVixLQUFBQSxDQUFBQSxLQUFNN0QsR0FBV29FLEtBQVEsTUFBTTtJQUMzRXhCLEtBQUtNLEdBQUtvQjtJQUNWLEtBQUtELEdBQUFBO1FBQ0ZuQixFQUFjbEMsTUFBQUEsR0FBUzs7QUFDMUI7QUN2SEssTUFBTXdELElBQWdCO0FBQ3RCLE1BQU1DLElBQWtCO0FBQ3hCLE1BQU1DLElBQWlCO0FBQ3ZCLE1BQU1DLElBQW1CO0FBQ3pCLE1BQU1DLElBQWdCO0FBQ3RCLE1BQU1DLElBQWlCO0FBQ3ZCLE1BQU1DLElBQWtCO0FBQ3hCLE1BQU1DLElBQWU7QUFDckIsTUFBTUMsSUFBZTtBQUNyQixNQUFNQyxJQUFXO0FBQ2pCLE1BQU1DLElBQVk7QUFDbEIsTUFBTUMsSUFBYTtBQUNuQixNQUFNQyxJQUFZO0FBQ2xCLE1BQU1DLElBQVk7QUFFbEIsTUFBTUMsd0JBQXlCQyxDQUFBQTtJQUNwQyxNQUFNQyxJQUFXQyxPQUFPRixLQUFPO0lBQy9CLE9BQU9DLElBQVdBLENBQUFBLENBQVMsR0FBR0UsV0FBQUEsS0FBZ0JGLEVBQVNHLEtBQUFBLENBQU0sS0FBSztBQUFFO0FDSC9ELE1BQU1DLFFBQVFBLENBQ25CdEMsR0FDQUMsR0FDQXNDLEdBRUFDO0lBRUEsSUFBSXhDLEtBQUtDLEdBQUc7UUFDVixJQUFJd0MsSUFBUztRQUNibkQsS0FBS2lELEdBQVFHLENBQUFBO1lBQ1gsTUFBTUMsSUFBa0QzQyxDQUFBQSxDQUFFMEMsRUFBQUE7WUFDMUQsTUFBTUUsSUFBa0QzQyxDQUFBQSxDQUFFeUMsRUFBQUE7WUFDMUQsSUFBSUMsTUFBYUMsR0FBQUE7Z0JBQ2ZILElBQVM7O1FBQ1g7UUFFRixPQUFPQTtJQUNUO0lBQ0EsT0FBTztBQUFLO0FBU1AsTUFBTUksVUFBVUEsQ0FBSTdDLEdBQW9CQyxJQUM3Q3FDLE1BQXNCdEMsR0FBR0MsR0FBRztRQUFDO1FBQUs7S0FBQTtBQVE3QixNQUFNNkMsVUFBVUEsQ0FBSTlDLEdBQW9CQyxJQUM3Q3FDLE1BQXNCdEMsR0FBR0MsR0FBRztRQUFDO1FBQUs7S0FBQTtBQVE3QixNQUFNOEMsWUFBWUEsQ0FBQy9DLEdBQVVDLElBQWFxQyxNQUFZdEMsR0FBR0MsR0FBRztRQUFDO1FBQUs7UUFBSztRQUFLO0tBQUE7QUNyQjVFLE1BQU0rQyxPQUFPQSxTQUNsQi9CO3FDQUNHSDtRQUFBQTs7V0FDcUJHLEVBQUcrQixJQUFBQSxDQUFLLE1BQU1sQzs7QUFPakMsTUFBTW1DLG1CQUFvQkMsQ0FBQUE7SUFDL0IsSUFBSUM7SUFDSixNQUFNQyxJQUFTRixJQUFVOUcsSUFBT0Y7SUFDaEMsTUFBTW1ILElBQVdILElBQVU1RyxJQUFTTjtJQUNwQyxPQUFPO1FBQ0p3RCxDQUFBQTtZQUNDNkQsRUFBU0Y7WUFHVEEsSUFBS0MsRUFBTyxJQUFNNUQsS0FBWW5DLFdBQVc2RixLQUFXQSxNQUFZQTtRQUFRO1FBRTFFLElBQU1HLEVBQVNGO0tBQUFBO0FBQytDO0FBR2xFLE1BQU1HLGVBQ0pDLENBQUFBO0lBRUEsTUFBTUMsSUFBdUJuRyxXQUFXa0csS0FBa0JBLE1BQW1CQTtJQUM3RSxJQUFJckcsU0FBU3NHLElBQXVCO1FBQ2xDLE1BQU1DLElBQVdELElBQXVCcEgsSUFBUUY7UUFDaEQsTUFBTXdILElBQVFGLElBQXVCbEgsSUFBU047UUFDOUMsT0FBUTJILENBQUFBO1lBQ04sTUFBTUMsSUFBWUgsRUFDaEIsSUFBTUUsS0FHTkg7WUFFRixPQUFPO2dCQUNMRSxFQUFPRTtZQUFVO1FBQ2xCO0lBRUw7SUFFQSxPQUFPSixLQUF3QkEsRUFBcUJLLENBQUFBO0FBQVU7QUFRekQsTUFBTUMsV0FBV0EsQ0FDdEJDLEdBQ0FqSztJQUVBLFFBQ0VrSyxHQUFpQkMsQ0FBQUEsRUFDakJDLEdBQW9CQyxDQUFBQSxFQUFTQyxHQUM3QkMsQ0FBQUEsRUFBUUMsR0FDUkMsQ0FBQUEsRUFBQUEsR0FDRXpLLEtBQVcsQ0FBRTtJQUNqQixJQUFJMEs7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSixNQUFNQyxJQUEyQixTQUEzQkEseUJBQXFDOUQsQ0FBQUE7UUFDekMsSUFBSTJELEdBQUFBO1lBQ0ZBOztRQUVGLElBQUlELEdBQUFBO1lBQ0ZBOztRQUdGRyxJQUFpQkYsSUFBeUJELElBQTRCRSxJQUFBQSxLQUFnQmhJO1FBR3RGcUgsRUFBbUJ4RCxLQUFBQSxDQUFNc0UsSUFBQUEsRUFBTS9EO0lBQ2hDO0lBRUQsTUFBTWdFLGFBQ0puSyxDQUFBQSxJQUVBNEosS0FBZ0JHLElBQWdCSCxFQUFhRyxHQUFlL0osS0FBUUE7SUFFdEUsTUFBTW9LLFFBQVFBO1FBRVosSUFBSU4sS0FBMEJDLEdBQUFBO1lBQzVCRSxFQUF5QkUsV0FBV0osTUFBa0JBOztJQUN4RDtJQUdGLE1BQU1NLElBQWMsU0FBZEE7UUFFSixNQUFNbEUsSUFBdUN4QyxLQUFLMkc7UUFDbEQsTUFBTUMsSUFBbUI1QixhQUFhVztRQUV0QyxJQUFJaUIsR0FBa0I7WUFDcEIsTUFBTUMsSUFBQUEsT0FBaUJkLE1BQWEsYUFBYUEsTUFBYUE7WUFDOUQsTUFBTWUsSUFBb0I5QixhQUFhYTtZQUN2QyxNQUFNa0IsSUFBb0JQLFdBQVdoRTtZQUNyQyxNQUFNd0UsSUFBY0QsS0FBcUJ2RTtZQUN6QyxNQUFNeUUsSUFBY1gsRUFBeUI1QixJQUFBQSxDQUFLLEdBQUdzQztZQUVyRCxJQUFJYixHQUFBQTtnQkFDRkE7O1lBR0YsSUFBSVUsS0FBQUEsQ0FBWVIsR0FBZ0I7Z0JBQzlCWTtnQkFDQVosSUFBaUI7Z0JBQ2pCRixJQUF5QlMsRUFBaUIsSUFBT1AsSUFBQUEsS0FBaUJqSTtZQUNwRSxPQUFPO2dCQUNMK0gsSUFBeUJTLEVBQWlCSztnQkFFMUMsSUFBSUgsS0FBQUEsQ0FBc0JaLEdBQUFBO29CQUN4QkEsSUFBNEJZLEVBQWtCTDs7WUFFbEQ7WUFFQUwsSUFBZ0JZO1FBQ2xCO1lBQ0VWLEVBQXlCOUQ7O0lBRTVCO0lBQ0RrRSxFQUFZUSxDQUFBQSxHQUFTVDtJQUVyQixPQUFPQztBQUE0QztBQzdKOUMsTUFBTVMsaUJBQWlCQSxDQUFDekksR0FBVTBGLElBQ3ZDNUUsT0FBT3dDLFNBQUFBLENBQVVtRixjQUFBQSxDQUFlQyxJQUFBQSxDQUFLMUksR0FBSzBGO0FBTXJDLE1BQU1qRCxPQUFRekMsQ0FBQUEsSUFBNkJBLElBQU1jLE9BQU8yQixJQUFBQSxDQUFLekMsS0FBTztBQTJCcEUsTUFBTTJJLGFBQXlCQSxDQUNwQ0MsR0FDQUMsR0FDQUMsR0FDQUMsR0FDQUMsR0FDQUMsR0FDQUM7SUFFQSxNQUFNQyxJQUFzQjtRQUFDTjtRQUFTQztRQUFTQztRQUFTQztRQUFTQztRQUFTQztLQUFBQTtJQUcxRSxZQUFZTixNQUFXLFlBQVkzSSxPQUFPMkksRUFBQUEsS0FBQUEsQ0FBYXZJLFdBQVd1SSxJQUFBQTtRQUNoRUEsSUFBUyxDQUFPOztJQUdsQnRHLEtBQUs2RyxHQUFVNUcsQ0FBQUE7UUFFYkQsS0FBS0MsR0FBUSxDQUFDNkcsR0FBRzFHO1lBQ2YsTUFBTTJHLElBQVk5RyxDQUFBQSxDQUFPRyxFQUFBQTtZQUl6QixJQUFJa0csTUFBV1MsR0FBQUE7Z0JBQ2IsT0FBTzs7WUFHVCxNQUFNQyxJQUFjaEosUUFBUStJO1lBRzVCLElBQUlBLEtBQVF6SSxjQUFjeUksSUFBTztnQkFDL0IsTUFBTUUsSUFBTVgsQ0FBQUEsQ0FBT2xHLEVBQUFBO2dCQUNuQixJQUFJOEcsSUFBYUQ7Z0JBR2pCLElBQUlELEtBQUFBLENBQWdCaEosUUFBUWlKLElBQUFBO29CQUMxQkMsSUFBUTt1QkFDSCxLQUFLRixLQUFBQSxDQUFnQjFJLGNBQWMySSxJQUFBQTtvQkFDeENDLElBQVEsQ0FBRTs7Z0JBSVpaLENBQUFBLENBQU9sRyxFQUFBQSxHQUFrQmlHLFdBQVdhLEdBQU9IO1lBQzdDO2dCQUNFVCxDQUFBQSxDQUFPbEcsRUFBQUEsR0FBa0I0RyxJQUFjRCxFQUFLaEUsS0FBQUEsS0FBVWdFOztRQUN4RDtJQUNBO0lBSUosT0FBT1Q7QUFBYTtBQUdmLE1BQU1hLDRCQUE0QkEsQ0FBd0JiLEdBQVdjLElBQzFFcEgsS0FBS3FHLFdBQVcsSUFBSUMsSUFBUyxDQUFDbkYsR0FBT2YsR0FBSzJHO1FBQ3hDLElBQUk1RixNQUFBQSxLQUFVL0QsR0FBQUE7bUJBQ0wySixDQUFBQSxDQUFLM0csRUFBQUE7ZUFDUCxJQUFZZSxLQUFTN0MsY0FBYzZDLElBQUFBO1lBQ3hDNEYsQ0FBQUEsQ0FBSzNHLEVBQUFBLEdBQTRCK0csMEJBQTBCaEc7O0lBQzdEO0FBT0csTUFBTWtHLGdCQUFpQjNKLENBQUFBLElBQUFBLENBQXVCeUMsS0FBS3pDLEdBQUtVLE1BQUFBO0FDOUd4RCxNQUFNa0osT0FBT0EsS0FBQUE7QUNTYixNQUFNQyxZQUFZQSxDQUFDcEwsR0FBYUYsR0FBYXVMLElBQ2xEekwsRUFBUUksR0FBS0QsRUFBUUQsR0FBS3VMO0FDSHJCLE1BQU1DLG9CQUFxQkMsQ0FBQUEsSUFDaENyRyxpQkFBQUEsQ0FBa0JyRCxRQUFRMEosS0FBVUEsSUFBQUEsQ0FBVUEsS0FBVSxJQUFJQyxLQUFBQSxDQUFNLE1BQU1DLE1BQUFBLENBQVFDLENBQUFBLElBQVVBO0FBUXJGLE1BQU1DLFVBQVVBLENBQUNDLEdBQTZCQyxJQUNuREQsS0FBT0EsRUFBSUUsWUFBQUEsQ0FBYUQ7QUFRbkIsTUFBTUUsVUFBVUEsQ0FBQ0gsR0FBNkJDLElBQ25ERCxLQUFPQSxFQUFJSSxZQUFBQSxDQUFhSDtBQU9uQixNQUFNSSxXQUFXQSxDQUN0QkwsR0FDQU0sR0FDQWxIO0lBRUFuQixLQUFLeUgsa0JBQWtCWSxJQUFhTCxDQUFBQTtRQUNsQyxJQUFJRCxHQUFBQTtZQUNGQSxFQUFJTyxZQUFBQSxDQUFhTixHQUFVbkYsT0FBTzFCLEtBQVM7O0lBQzdDO0FBQ0E7QUFRRyxNQUFNb0gsY0FBY0EsQ0FBQ1IsR0FBNkJNO0lBQ3ZEckksS0FBS3lILGtCQUFrQlksSUFBYUwsQ0FBQUEsSUFBYUQsS0FBT0EsRUFBSVMsZUFBQUEsQ0FBZ0JSO0FBQVU7QUFHakYsTUFBTVMsbUJBQW1CQSxDQUFDVixHQUE2QkM7SUFDNUQsTUFBTVUsSUFBYWpCLGtCQUFrQkssUUFBUUMsR0FBS0M7SUFDbEQsTUFBTVcsSUFBYWpGLEtBQUswRSxVQUFVTCxHQUFLQztJQUN2QyxNQUFNWSx3QkFBd0JBLENBQUNDLEdBQTRCQztRQUN6RCxNQUFNQyxJQUFnQixJQUFJekgsSUFBSW9IO1FBQzlCMUksS0FBS3lILGtCQUFrQm9CLElBQW1CaEIsQ0FBQUE7WUFDeENrQixDQUFBQSxDQUFjRCxFQUFBQSxDQUFXakI7UUFBTTtRQUVqQyxPQUFPN0ksS0FBSytKLEdBQWVDLElBQUFBLENBQUs7SUFBSTtJQUd0QyxPQUFPO1FBQ0xDLEdBQVVDLENBQUFBLElBQTRCUCxFQUFXQyxzQkFBc0JNLEdBQWM7UUFDckZDLEdBQU9DLENBQUFBLElBQXlCVCxFQUFXQyxzQkFBc0JRLEdBQVc7UUFDNUVDLEdBQU9DLENBQUFBO1lBQ0wsTUFBTUMsSUFBVzlCLGtCQUFrQjZCO1lBQ25DLE9BQU9DLEVBQVNDLE1BQUFBLENBQ2QsQ0FBQ0MsR0FBUzVCLElBQVU0QixLQUFXZixFQUFXZ0IsUUFBQUEsQ0FBUzdCLElBQ25EMEIsRUFBU25MLE1BQUFBLEdBQVM7UUFDbkI7O0FBRUo7QUFTSSxNQUFNdUwsa0JBQWtCQSxDQUM3QjVCLEdBQ0FDLEdBQ0E3RztJQUVBc0gsaUJBQWlCVixHQUFLQyxHQUFVaUIsQ0FBQUEsQ0FBUTlIO0lBQ3hDLE9BQU91QyxLQUFLa0csY0FBYzdCLEdBQUtDLEdBQVU3RztBQUFNO0FBUzFDLE1BQU15SSxlQUFlQSxDQUMxQjdCLEdBQ0FDLEdBQ0E3RztJQUVBc0gsaUJBQWlCVixHQUFLQyxHQUFVbUIsQ0FBQUEsQ0FBS2hJO0lBQ3JDLE9BQU91QyxLQUFLaUcsaUJBQWlCNUIsR0FBS0MsR0FBVTdHO0FBQU07QUFHN0MsTUFBTTBJLHFCQUFxQkEsQ0FDaEM5QixHQUNBQyxHQUNBN0csR0FDQTJJLElBQUFBLENBQ0lBLElBQU1GLGVBQWVELGVBQUFBLEVBQWlCNUIsR0FBS0MsR0FBVTdHO0FBU3BELE1BQU00SSxlQUFlQSxDQUMxQmhDLEdBQ0FDLEdBQ0E3RyxJQUNZc0gsaUJBQWlCVixHQUFLQyxHQUFVcUIsQ0FBQUEsQ0FBS2xJO0FDekhuRCxNQUFNNkksMEJBQTJCakMsQ0FBQUEsSUFBZ0NVLGlCQUFpQlYsR0FBSztBQWVoRixNQUFNa0MsY0FBY0EsQ0FBQ2xDLEdBQTZCbUM7SUFDdkRGLHdCQUF3QmpDLEdBQUtrQixDQUFBQSxDQUFRaUI7QUFBVTtBQVMxQyxNQUFNQyxXQUFXQSxDQUFDcEMsR0FBNkJtQztJQUNwREYsd0JBQXdCakMsR0FBS29CLENBQUFBLENBQUtlO0lBQ2xDLE9BQU94RyxLQUFLdUcsYUFBYWxDLEdBQUttQztBQUFVO0FDdkJuQyxNQUFNRSxPQUFPQSxDQUFDQyxHQUFrQnRDO0lBQ3JDLE1BQU11QyxJQUFVdkMsSUFBTXJKLFVBQVVxSixNQUFRQSxJQUFNbE07SUFDOUMsT0FBT3lPLElBQVV0TCxLQUFLc0wsRUFBUUMsZ0JBQUFBLENBQWlCRixNQUFhO0FBQUU7QUFRekQsTUFBTUcsWUFBWUEsQ0FBQ0gsR0FBa0J0QztJQUMxQyxNQUFNdUMsSUFBVXZDLElBQU1ySixVQUFVcUosTUFBUUEsSUFBTWxNO0lBQzlDLE9BQU95TyxLQUFXQSxFQUFRRyxhQUFBQSxDQUFjSjtBQUFTO0FBUTVDLE1BQU1LLEtBQUtBLENBQUMzQyxHQUF3QnNDLElBQ3pDM0wsVUFBVXFKLE1BQVFBLEVBQUk0QyxPQUFBQSxDQUFRTjtBQUV6QixNQUFNTyxnQkFBaUI3QyxDQUFBQSxJQUEyQjJDLEdBQUczQyxHQUFLO0FBc0IxRCxNQUFNOEMsV0FBWTlDLENBQUFBLElBQ3ZCQSxJQUFNL0ksS0FBSytJLEVBQUkrQyxVQUFBQSxJQUFjO0FBTXhCLE1BQU1DLFNBQVVoRCxDQUFBQSxJQUE4Q0EsS0FBT0EsRUFBSWlELGFBQUFBO0FBUXpFLE1BQU1DLFVBQVVBLENBQUNsRCxHQUF3QnNDLElBQzlDM0wsVUFBVXFKLE1BQVFBLEVBQUlrRCxPQUFBQSxDQUFRWjtBQU16QixNQUFNYSxvQkFBcUJDLENBQUFBLElBQW1CdFAsU0FBa0J1UCxhQUFBQTtBQVFoRSxNQUFNQyxjQUFjQSxDQUN6QnRELEdBQ0F1RCxHQUNBQztJQUVBLE1BQU1DLElBQXlCUCxRQUFRbEQsR0FBS3VEO0lBQzVDLE1BQU1HLElBQXlCMUQsS0FBT3lDLFVBQVVlLEdBQXNCQztJQUN0RSxNQUFNRSxJQUNKVCxRQUFRUSxHQUF3QkgsT0FBMEJFO0lBRTVELE9BQU9BLEtBQTBCQyxJQUM3QkQsTUFBMkJ6RCxLQUN6QjBELE1BQTJCMUQsS0FDMUIyRCxLQUNDVCxRQUFRQSxRQUFRbEQsR0FBS3dELElBQXVCRCxPQUMxQ0UsSUFDTjtBQUFLO0FDM0ZKLE1BQU1HLGlCQUFrQkMsQ0FBQUE7SUFDN0I1TCxLQUFLa0Isa0JBQWtCMEssSUFBU0MsQ0FBQUE7UUFDOUIsTUFBTUMsSUFBWWYsT0FBT2M7UUFDekIsSUFBSUEsS0FBUUMsR0FBQUE7WUFDVkEsRUFBVUMsV0FBQUEsQ0FBWUY7O0lBQ3hCO0FBQ0E7QUFTRyxNQUFNRyxpQkFBaUJBLENBQUNILEdBQXlCSSxJQUN0RHZJLEtBQ0VpSSxnQkFDQUUsS0FDRUksS0FDQWpNLEtBQUtrQixrQkFBa0IrSyxJQUFZQyxDQUFBQTtRQUNqQyxJQUFJQSxHQUFBQTtZQUNGTCxFQUFLTSxXQUFBQSxDQUFZRDs7SUFDbkI7QUM5QlIsSUFBSUU7QUFFRyxNQUFNQyx1QkFBdUJBLElBQU1EO0FBQ25DLE1BQU1FLHVCQUF3QkMsQ0FBQUE7SUFDbkNILElBQW9CRztBQUFvQjtBQ0duQyxNQUFNQyxZQUFhQyxDQUFBQTtJQUN4QixNQUFNQyxJQUFNN1EsU0FBUzhRLGFBQUFBLENBQWM7SUFDbkN2RSxTQUFTc0UsR0FBSyxTQUFTRDtJQUN2QixPQUFPQztBQUFHO0FBT0wsTUFBTUUsWUFBYUMsQ0FBQUE7SUFDeEIsTUFBTUMsSUFBYU47SUFDbkIsTUFBTU8sSUFBcUJWO0lBQzNCLE1BQU1XLElBQWNILEVBQUtJLElBQUFBO0lBQ3pCSCxFQUFXSSxTQUFBQSxHQUFZSCxJQUVsQkEsRUFBMkJJLFVBQUFBLENBQVdILEtBQ3ZDQTtJQUVKLE9BQU9oTixLQUFLNkssU0FBU2lDLElBQWMvRSxDQUFBQSxJQUFRNEQsZUFBZTVEO0FBQUs7QUNkakUsTUFBTXFGLFlBQVlBLENBQUNDLEdBQW9DakssSUFFckRpSyxFQUFjQyxnQkFBQUEsQ0FBaUJsSyxNQUFTaUssQ0FBQUEsQ0FBY2pLLEVBQUFBLElBQWdCO0FBRXhFLE1BQU1tSyxvQkFBcUIvRixDQUFBQTtJQUN6QixNQUFNZ0csSUFBU2hHLEtBQVU7SUFDekIsT0FBT2lHLFNBQVNELEtBQVVBLElBQVM7QUFBQztBQUd0QyxNQUFNRSxzQkFBdUJ2TSxDQUFBQSxJQUEyQm9NLGtCQUFrQkksV0FBV3hNLEtBQVM7QUFFdkYsTUFBTXlNLGlCQUFrQnpNLENBQUFBLElBQWtCbkYsS0FBS0ssS0FBQUEsQ0FBTThFLElBQVEsT0FBUztBQUt0RSxNQUFNME0sZ0JBQWlCckcsQ0FBQUEsSUFBbUIsR0FBb0NBLE9BQWpDb0csZUFBZUwsa0JBQWtCL0YsS0FBQUE7QUFFckUsU0FBQXNHLFVBQ2QvRixDQUFBQSxFQUNBZ0csQ0FBQUE7SUFHQWhHLEtBQ0VnRyxLQUNBL04sS0FBSytOLEdBQVEsQ0FBQ0MsR0FBNEI3UTtRQUN4QztZQUNFLE1BQU04USxJQUFXbEcsRUFBSW1HLEtBQUFBO1lBQ3JCLE1BQU0vTSxJQUNKeEQsT0FBT3FRLE1BQWFsUSxVQUFVa1EsS0FDMUIsS0FDQXBRLFNBQVNvUSxLQUNQSCxjQUFjRyxLQUNkQTtZQUVSLElBQUk3USxFQUFLcUQsT0FBQUEsQ0FBUSxVQUFVO2dCQUN6QnlOLEVBQVNFLFdBQUFBLENBQVloUixHQUFNZ0U7O2dCQUczQjhNLENBQUFBLENBQVM5USxFQUFBQSxHQUFlZ0U7O1FBRzNCLEVBQUMsT0FBQWlOLEdBQUFBLENBQU07SUFBQTtBQUVkO1NBWWdCQyxVQUNkdEcsQ0FBQUEsRUFDQWdHLENBQUFBLEVBQ0FPLENBQUFBO0lBRUEsTUFBTUMsSUFBaUIxUSxTQUFTa1E7SUFDaEMsSUFBSVMsSUFBd0NELElBQWlCLEtBQUssQ0FBRTtJQUVwRSxJQUFJeEcsR0FBSztRQUNQLE1BQU1zRixJQUFnQnZSLEVBQUkyUyxnQkFBQUEsQ0FBaUIxRyxHQUFLdUcsTUFBY3ZHLEVBQUltRyxLQUFBQTtRQUNsRU0sSUFBa0JELElBQ2RuQixVQUFVQyxHQUFlVSxLQUN6Qi9PLEtBQUsrTyxHQUFRdkUsTUFBQUEsQ0FBTyxDQUFDckcsR0FBUS9DO1lBQzNCK0MsQ0FBQUEsQ0FBTy9DLEVBQUFBLEdBQU9nTixVQUFVQyxHQUFlak47WUFDdkMsT0FBTytDO1FBQU0sR0FDWnFMO0lBQ1Q7SUFDQSxPQUFPQTtBQUNUO0FBUU8sTUFBTUUscUJBQXFCQSxDQUNoQzNHLEdBQ0E0RyxHQUNBQztJQUVBLE1BQU1DLElBQWNGLElBQWlCLEdBQUdBLE9BQUFBLEdBQUFBLE9BQW9CO0lBQzVELE1BQU1HLElBQWNGLElBQWlCLElBQUlBLE9BQUFBLEtBQW1CO0lBQzVELE1BQU1HLElBQU0sR0FBb0JELE9BQWpCRCxHQUFBQSxPQUFpQkMsT0FBQUE7SUFDaEMsTUFBTUUsSUFBUSxHQUFzQkYsT0FBbkJELEdBQUFBLFNBQW1CQyxPQUFBQTtJQUNwQyxNQUFNRyxJQUFTLEdBQXVCSCxPQUFwQkQsR0FBQUEsVUFBb0JDLE9BQUFBO0lBQ3RDLE1BQU1JLElBQU8sR0FBcUJKLE9BQWxCRCxHQUFBQSxRQUFrQkMsT0FBQUE7SUFDbEMsTUFBTTNMLElBQVNrTCxVQUFVdEcsR0FBSztRQUFDZ0g7UUFBS0M7UUFBT0M7UUFBUUM7S0FBQUE7SUFDbkQsT0FBTztRQUNMQyxHQUFHekIsb0JBQW9CdkssQ0FBQUEsQ0FBTzRMLEVBQUFBO1FBQzlCSyxHQUFHMUIsb0JBQW9CdkssQ0FBQUEsQ0FBTzZMLEVBQUFBO1FBQzlCck8sR0FBRytNLG9CQUFvQnZLLENBQUFBLENBQU84TCxFQUFBQTtRQUM5QkksR0FBRzNCLG9CQUFvQnZLLENBQUFBLENBQU8rTCxFQUFBQTs7QUFDL0I7QUFHSSxNQUFNSSw0QkFBNEJBLENBQ3ZDbk8sR0FDQW9PLElBRUEsWUFDK0VwTyxPQUE3RWpELFNBQVNpRCxLQUFTLElBQWVBLE9BQVhBLEVBQU1xTyxDQUFBQSxFQUFBQSxLQUFXQyxPQUFOdE8sRUFBTXNPLENBQUFBLEVBQUFBLE9BQU8sR0FBK0J0TyxPQUE1Qm9PLElBQWUsTUFBTSxVQUFPcE8sT0FBQUEsR0FBQUE7QUM5R2pGLE1BQU11Tyx1QkFBd0IzSCxDQUFBQSxJQUFBQSxDQUFBQSxDQUN6QkEsQ0FBQUEsRUFBSTRILFdBQUFBLElBQWU1SCxFQUFJNkgsWUFBQUEsSUFBZ0I3SCxFQUFJOEgsY0FBQUEsR0FBaUJ6UixNQUFBQTtBQUNqRSxNQUFNMFIsSUFBYztJQUNsQkMsR0FBRztJQUNIQyxHQUFHOztBQUdMLE1BQU1DLDRCQUE0QkEsQ0FDaENDLEdBQ0FuSSxJQUVBQSxJQUNJO1FBRUVnSSxHQUFJaEksQ0FBQUEsQ0FBWSxHQUFHbUksT0FBQUEsR0FBQUEsU0FBQUE7UUFFbkJGLEdBQUlqSSxDQUFBQSxDQUFZLEdBQUdtSSxPQUFBQSxHQUFBQSxVQUFBQTtRQUVyQko7QUFLQyxNQUFNSyxnQkFBaUJDLENBQUFBLElBQzVCSCwwQkFBMEIsU0FBU0csS0FBYXRVO0FBTTNDLE1BQU11VSxJQUFnQjNNLEtBQUt1TSwyQkFBd0M7QUFRbkUsTUFBTUssSUFBZ0I1TSxLQUFLdU0sMkJBQXdDO0FBUW5FLE1BQU1NLElBQWdCN00sS0FBS3VNLDJCQUF3QztBQVFuRSxNQUFNTyxvQkFBcUJ6SSxDQUFBQTtJQUNoQyxNQUFNMEksSUFBVzlDLFdBQVdVLFVBQVV0RyxHQUFLMUYsT0FBYztJQUN6RCxNQUFNcU8sSUFBWS9DLFdBQVdVLFVBQVV0RyxHQUFLekYsT0FBZTtJQUMzRCxPQUFPO1FBQ0x5TixHQUFHVSxJQUFXclUsRUFBVXFVO1FBQ3hCVCxHQUFHVSxJQUFZdFUsRUFBVXNVOztBQUMxQjtBQU9JLE1BQU1DLHdCQUF5QjVJLENBQUFBLElBQThCQSxFQUFJNEkscUJBQUFBO0FBTWpFLE1BQU1DLGdCQUFpQjdJLENBQUFBLElBQUFBLENBQUFBLENBQzFCQSxLQUFPMkgscUJBQXFCM0g7QUFLekIsTUFBTThJLHVCQUF3QkMsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FDaENBLENBQUFBLEtBQVNBLENBQUFBLENBQUFBLENBQUt4TyxFQUFBQSxJQUFjd08sQ0FBQUEsQ0FBS3pPLEVBQUFBLENBQUFBO0FBUS9CLE1BQU0wTyxrQkFBa0JBLENBQzdCQyxHQUNBQztJQUVBLE1BQU1DLElBQW9CTCxxQkFBcUJHO0lBQy9DLE1BQU1HLElBQW9CTixxQkFBcUJJO0lBQy9DLFFBQVFFLEtBQXFCRDtBQUFpQjtBQy9FekMsTUFBTUUsc0JBQXNCQSxDQUNqQzlLLEdBQ0ErSyxHQUNBQyxHQUNBQztJQUVBdlIsS0FBS3lILGtCQUFrQjRKLElBQWNHLENBQUFBO1FBQ25DLElBQUlsTCxHQUFBQTtZQUNGQSxFQUFPOEssbUJBQUFBLENBQW9CSSxHQUFXRixHQUEyQkM7O0lBQ25FO0FBQ0E7QUFVRyxNQUFNRSxtQkFBbUJBLENBQzlCbkwsR0FDQStLLEdBQ0FDLEdBQ0E5VztJQUNnQixJQUFBa1g7SUFDaEIsTUFBTUMsSUFBQUEsQ0FBT0QsSUFBSWxYLEtBQVdBLEVBQVFvWCxDQUFBQSxLQUFRLE9BQUFGLElBQUs7SUFDakQsTUFBTUgsSUFBVy9XLEtBQVdBLEVBQVFxWCxDQUFBQSxJQUFhO0lBQ2pELE1BQU1DLElBQVF0WCxLQUFXQSxFQUFRdVgsQ0FBQUEsSUFBVTtJQUMzQyxNQUFNQyxJQUF5QztRQUM3Q0wsU0FBQUE7UUFDQUosU0FBQUE7O0lBR0YsT0FBTzdOLEtBQ0xuQyxpQkFDQWtHLGtCQUFrQjRKLEdBQVlZLEdBQUFBLENBQUtULENBQUFBO1FBQ2pDLE1BQU1VLElBQ0pKLElBQ0tLLENBQUFBO1lBQ0NmLG9CQUFvQjlLLEdBQVFrTCxHQUFXVSxHQUFlWDtZQUN0RCxJQUFJRCxHQUFBQTtnQkFDRkEsRUFBU2E7O1FBQ1gsSUFFRmI7UUFHTixJQUFJaEwsR0FBQUE7WUFDRkEsRUFBT21MLGdCQUFBQSxDQUFpQkQsR0FBV1UsR0FBZUY7O1FBR3BELE9BQU90TyxLQUFLME4scUJBQXFCOUssR0FBUWtMLEdBQVdVLEdBQWVYO0lBQVE7QUFFOUU7QUF5QkksTUFBTWEsa0JBQW1CRCxDQUFBQSxJQUFxQkEsRUFBSUMsZUFBQUE7QUFNbEQsTUFBTUMsaUJBQWtCRixDQUFBQSxJQUFxQkEsRUFBSUUsY0FBQUE7QUFNakQsTUFBTUMsaUJBQWtCSCxDQUFBQSxJQUM1QkMsZ0JBQWdCRCxNQUF1QkUsZUFBZUY7QUN0R2xELE1BQU1JLGtCQUFrQkEsQ0FDN0J4SyxHQUNBeUs7SUFFQSxRQUFNaEQsR0FBRUEsQ0FBQUEsRUFBQ0MsR0FBRUEsQ0FBQUEsRUFBQUEsR0FBTTdSLFNBQVM0VSxLQUFZO1FBQUVoRCxHQUFHZ0Q7UUFBVS9DLEdBQUcrQztRQUFhQSxLQUFZLENBQUU7SUFFbkY1VSxTQUFTNFIsTUFBT3pILENBQUFBLEVBQUkwSyxVQUFBQSxHQUFhakQsQ0FBQUE7SUFFakM1UixTQUFTNlIsTUFBTzFILENBQUFBLEVBQUkySyxTQUFBQSxHQUFZakQsQ0FBQUE7QUFBRTtBQVE3QixNQUFNa0QsbUJBQW9CNUssQ0FBQUEsSUFBb0M7UUFDbkV5SCxHQUFHekgsRUFBSTBLLFVBQUFBO1FBQ1BoRCxHQUFHMUgsRUFBSTJLLFNBQUFBOztBQU1GLE1BQU1FLDJCQUEyQkEsSUFBMEI7UUFDaEVDLEdBQVE7WUFBRXJELEdBQUc7WUFBR0MsR0FBRzs7UUFDbkJxRCxHQUFNO1lBQUV0RCxHQUFHO1lBQUdDLEdBQUc7OztBQVdaLE1BQU1zRCw0QkFBNEJBLENBQ3ZDQyxHQUNBQztJQUVBLFFBQU1DLEdBQUVMLENBQUFBLEVBQU1NLEdBQUVMLENBQUFBLEVBQUFBLEdBQVNFO0lBQ3pCLFFBQU1qRCxHQUFFQSxDQUFBQSxFQUFDQyxHQUFFQSxDQUFBQSxFQUFBQSxHQUFNaUQ7SUFDakIsTUFBTUcsZUFBZUEsQ0FBQ0MsR0FBZUMsR0FBYUM7UUFDaEQsSUFBSUMsSUFBV2hYLEVBQVM2VyxLQUFTRTtRQUNqQyxJQUFJRSxJQUFTalgsRUFBUzhXLEtBQU9DO1FBRTdCLElBQUlDLE1BQWFDLEdBQVE7WUFDdkIsTUFBTUMsSUFBV3BYLEVBQVErVztZQUN6QixNQUFNTSxJQUFTclgsRUFBUWdYO1lBRXZCRyxJQUFTQyxJQUFXQyxJQUFTLElBQUlGO1lBQ2pDRCxJQUFXRSxJQUFXQyxJQUFTLElBQUlIO1FBQ3JDO1FBR0FBLElBQVdBLE1BQWFDLElBQVMsSUFBSUQ7UUFFckMsT0FBTztZQUFDQSxJQUFXO1lBQUdDLElBQVM7U0FBQTtJQUFXO0lBRzVDLE9BQU9HLEdBQVFDLEVBQUFBLEdBQVFULGFBQWFQLEVBQU9yRCxDQUFBQSxFQUFHc0QsRUFBS3RELENBQUFBLEVBQUdPO0lBQ3RELE9BQU8rRCxHQUFRQyxFQUFBQSxHQUFRWCxhQUFhUCxFQUFPcEQsQ0FBQUEsRUFBR3FELEVBQUtyRCxDQUFBQSxFQUFHTztJQUV0RCxPQUFPO1FBQ0w2QyxHQUFRO1lBQ05yRCxHQUFHb0U7WUFDSG5FLEdBQUdxRTs7UUFFTGhCLEdBQU07WUFDSnRELEdBQUdxRTtZQUNIcEUsR0FBR3NFOzs7QUFFTjtBQVVJLE1BQU1DLHNDQUFzQ0E7UUFBQUEsRUFDakRuQixHQUFBQSxDQUFBQSxFQUNBQyxHQUFBQSxDQUFBQSxFQUFBQTtJQUVBLE1BQU1tQixVQUFVQSxDQUFDWixHQUFlQyxJQUFnQkQsTUFBVSxLQUFLQSxLQUFTQztJQUV4RSxPQUFPO1FBQ0w5RCxHQUFHeUUsUUFBUXBCLEVBQU9yRCxDQUFBQSxFQUFHc0QsRUFBS3RELENBQUFBO1FBQzFCQyxHQUFHd0UsUUFBUXBCLEVBQU9wRCxDQUFBQSxFQUFHcUQsRUFBS3JELENBQUFBOztBQUMzQjtBQVFJLE1BQU15RSw4QkFBOEJBLFFBRXpDQztRQUZ5Q0QsRUFDdkNyQixHQUFBQSxDQUFBQSxFQUFRQyxHQUFBQSxDQUFBQSxFQUFBQTtJQUdWLE1BQU1tQixVQUFVQSxDQUFDWixHQUFlQyxHQUFhYyxJQUMzQzdNLFVBQVUsR0FBRyxJQUFJOEwsSUFBUWUsQ0FBQUEsSUFBWWYsQ0FBQUEsSUFBUUMsQ0FBQUEsS0FBUTtJQUV2RCxPQUFPO1FBQ0w5RCxHQUFHeUUsUUFBUXBCLEVBQU9yRCxDQUFBQSxFQUFHc0QsRUFBS3RELENBQUFBLEVBQUcyRSxFQUFjM0UsQ0FBQUE7UUFDM0NDLEdBQUd3RSxRQUFRcEIsRUFBT3BELENBQUFBLEVBQUdxRCxFQUFLckQsQ0FBQUEsRUFBRzBFLEVBQWMxRSxDQUFBQTs7QUFDNUM7QUMzSEksTUFBTTRFLGVBQWdCQyxDQUFBQTtJQUMzQixJQUFJQSxLQUFZQSxFQUF3QkMsS0FBQUEsRUFBQUE7UUFPckNELEVBQXdCQyxLQUFBQSxDQUFNO1lBQzdCQyxlQUFlO1lBR2ZDLGNBQWM7OztBQVVsQjtBQ2tCRixNQUFNQyxpQkFBaUJBLENBQ3JCeFUsR0FDQW9SO0lBRUF0UixLQUFLa0Isa0JBQWtCb1EsSUFBV3BSO0FBQVM7QUFHdEMsTUFBTXlVLHlCQUNYQyxDQUFBQTtJQUVBLE1BQU1DLElBQVMsSUFBSUM7SUFFbkIsTUFBTUMsY0FBc0NBLENBQUM1WCxHQUFNbVU7UUFDakQsSUFBSW5VLEdBQU07WUFDUixNQUFNNlgsSUFBV0gsRUFBT0ksR0FBQUEsQ0FBSTlYO1lBQzVCdVgsZUFBZ0JRLENBQUFBO2dCQUNkLElBQUlGLEdBQUFBO29CQUNGQSxDQUFBQSxDQUFTRSxJQUFlLFdBQVcsU0FBU0E7O1lBQzlDLEdBQ0M1RDtRQUNMLE9BQU87WUFDTHVELEVBQU9NLE9BQUFBLENBQVNILENBQUFBO2dCQUNkQSxFQUFTNVEsS0FBQUE7WUFBTztZQUVsQnlRLEVBQU96USxLQUFBQTtRQUNUO0lBQUE7SUFHRixNQUFNZ1IsV0FBZ0NBLENBQ3BDQyxHQUNBQztRQUtBLElBQUl6WCxTQUFTd1gsSUFBdUI7WUFDbEMsTUFBTUwsSUFBV0gsRUFBT0ksR0FBQUEsQ0FBSUksTUFBeUIsSUFBSS9UO1lBQ3pEdVQsRUFBT1UsR0FBQUEsQ0FBSUYsR0FBc0JMO1lBRWpDTixlQUNHUSxDQUFBQTtnQkFDQyxJQUFJblgsV0FBV21YLElBQUFBO29CQUNiRixFQUFTbEwsR0FBQUEsQ0FBSW9MOztZQUNmLEdBRUZJO1lBR0YsT0FBTzVSLEtBQ0xxUixhQUNBTSxHQUNBQztRQUVKO1FBQ0EsSUFBSXhYLFVBQVV3WCxNQUFtQkEsR0FBQUE7WUFDL0JQOztRQUdGLE1BQU1TLElBQW9CclYsS0FBS2tWO1FBQy9CLE1BQU1JLElBQXlCO1FBQy9CelYsS0FBS3dWLEdBQW9CcFYsQ0FBQUE7WUFDdkIsTUFBTXNWLElBQWlCTCxDQUFBQSxDQUFtRGpWLEVBQUFBO1lBQzFFLElBQUlzVixHQUFBQTtnQkFDRjlVLEtBQUs2VSxHQUFRTCxTQUFTaFYsR0FBS3NWOztRQUM3QjtRQUdGLE9BQU9oUyxLQUFLbkMsaUJBQWlCa1U7SUFBTztJQUd0QyxNQUFNRSxlQUF3Q0EsQ0FBQ3hZLEdBQU1xRTtRQUNuRHhCLEtBQUtoQixLQUFLNlYsRUFBT0ksR0FBQUEsQ0FBSTlYLEtBQVN5WSxDQUFBQTtZQUM1QixJQUFJcFUsS0FBQUEsQ0FBU0osYUFBYUksSUFBQUE7Z0JBQ3ZCb1UsRUFBNkQzVSxLQUFBQSxDQUFNLEdBQUdPOztnQkFFdEVvVTs7UUFDSDtJQUNBO0lBR0pSLFNBQVNSLEtBQXlCO0lBRWxDLE9BQU87UUFBQ1E7UUFBVUw7UUFBYVk7S0FBQUE7QUFBYTtBQ1J2QyxNQUFNRSxJQUE4QyxDQUFFO0FBR3RELE1BQU1DLElBQTJFLENBQUU7QUFPbkYsTUFBTUMsYUFBY0MsQ0FBQUE7SUFDekJoVyxLQUFLZ1csR0FBY0MsQ0FBQUEsSUFDakJqVyxLQUFLaVcsR0FBUSxDQUFDblAsR0FBRzFHO1lBQ2Z5VixDQUFBQSxDQUFjelYsRUFBQUEsR0FBTzZWLENBQUFBLENBQU83VixFQUFBQTtRQUFJO0FBRW5DO0FBR0ksTUFBTThWLGdDQUFnQ0EsQ0FDM0NELEdBQ0FFLEdBQ0FDLElBTUFqVyxLQUFLOFYsR0FBUWhFLEdBQUFBLENBQUs5VSxDQUFBQTtRQUNoQixRQUFRa1osUUFBUUMsQ0FBQUEsRUFBVUMsVUFBVUMsQ0FBQUEsRUFBQUEsR0FDbENQLENBQUFBLENBQ0E5WSxFQUFBQTtRQUNGLE9BQU9zWixHQUFhYixHQUFPYyxFQUFBQSxHQUFxQk4sS0FBZ0I7UUFDaEUsTUFBTU8sSUFBT1AsSUFBZUksSUFBYUY7UUFDekMsSUFBSUssR0FBTTtZQUNSLE1BQU1KLElBQVdILElBRVhPLEVBUUFGLEdBQWNiLEdBQVFPLEtBRXRCUSxFQUlBUjtZQUNOLFFBQVNPLEtBQXFCWixDQUFBQSxDQUFBQSxDQUE2QjNZLEVBQUFBLEdBQVFvWjtRQUNyRTtJQUFBO0FBR0csTUFBTUssZ0NBQ1hDLENBQUFBLElBRUFmLENBQUFBLENBQTRCZSxFQUFBQTtBQ25LdkIsTUFBTUMsSUFBb0M7QUNWakQsTUFBTUMsSUFBc0I7QUFHckIsTUFBTUMsSUFBdUI7QUFDN0IsTUFBTUMsSUFBc0MsR0FBR0QsT0FBQUEsR0FBQUE7QUFHL0MsTUFBTUUsSUFBMEIsR0FBR0gsT0FBQUEsR0FBQUE7QUFHbkMsTUFBTUksSUFBc0I7QUFHNUIsTUFBTUMsSUFBd0IsR0FBR0wsT0FBQUEsR0FBQUE7QUFHakMsTUFBTU0sSUFBb0JOO0FBQzFCLE1BQU1PLElBQXNCO0FBRzVCLE1BQU1DLElBQXdCLEdBQUdSLE9BQUFBLEdBQUFBO0FBQ2pDLE1BQU1TLElBQW1DclY7QUFDekMsTUFBTXNWLElBQW1DclY7QUFDekMsTUFBTXNWLElBQTJCO0FBQ2pDLE1BQU1DLElBQTZCO0FBQ25DLE1BQU1DLElBQTZCO0FBQ25DLE1BQU1DLElBQW1DO0FBQ3pDLE1BQU1DLElBQTZCO0FBR25DLE1BQU1DLElBQXVCLEdBQUdoQixPQUFBQSxHQUFBQTtBQUdoQyxNQUFNaUIsS0FBdUIsR0FBR2pCLE9BQUFBLEdBQUFBO0FBR2hDLE1BQU1rQixLQUF3QjtBQUM5QixNQUFNQyxLQUE4QixHQUFHRCxPQUFBQSxJQUFBQTtBQUN2QyxNQUFNRSxLQUFnQyxHQUFHRixPQUFBQSxJQUFBQTtBQUN6QyxNQUFNRyxLQUFzQyxHQUFHRCxPQUFBQSxJQUFBQTtBQUMvQyxNQUFNRSxLQUFvQyxHQUFHRixPQUFBQSxJQUFBQTtBQUM3QyxNQUFNRyxLQUF5QyxHQUFHRCxPQUFBQSxJQUFBQTtBQUdsRCxNQUFNRSxLQUEyQjtBQUdqQyxNQUFNQyxLQUE4QjtBQUNwQyxNQUFNQyxLQUFxQjtBQUMzQixNQUFNQyxLQUF3QixHQUFHRCxPQUFBQSxJQUFBQTtBQUNqQyxNQUFNRSxLQUErQixHQUFHRixPQUFBQSxJQUFBQTtBQUN4QyxNQUFNRyxLQUE2QixHQUFHSCxPQUFBQSxJQUFBQTtBQUN0QyxNQUFNSSxLQUEwQixHQUFHSixPQUFBQSxJQUFBQTtBQUNuQyxNQUFNSyxLQUEyQixHQUFHTCxPQUFBQSxJQUFBQTtBQUNwQyxNQUFNTSxLQUE0QixHQUFHTixPQUFBQSxJQUFBQTtBQUNyQyxNQUFNTyxLQUErQixHQUFHUCxPQUFBQSxJQUFBQTtBQUV4QyxNQUFNUSxLQUFnQyxHQUFHUixPQUFBQSxJQUFBQTtBQUN6QyxNQUFNUyxLQUE2QixHQUFHVCxPQUFBQSxJQUFBQTtBQUN0QyxNQUFNVSxLQUE2QixHQUFHVixPQUFBQSxJQUFBQTtBQUN0QyxNQUFNVyxLQUFtQyxHQUFHRCxPQUFBQSxJQUFBQTtBQUM1QyxNQUFNRSxLQUEwQixHQUFHWixPQUFBQSxJQUFBQTtBQUNuQyxNQUFNYSxLQUFxQyxHQUFHVCxPQUFBQSxJQUFBQTtBQUM5QyxNQUFNVSxLQUFzQyxHQUFHVCxPQUFBQSxJQUFBQTtBQ3pDL0MsTUFBTVUsS0FBeUI7QUFFekJDLE1BQUFBLEtBQXFDLGFBQXJDQSxHQUFxQyxLQUFRO1FBQ3hERCxDQUFDQSxHQUFBQSxFQUF5QjtZQUN4Qm5ELFFBQ0VBLElBQ0EsQ0FDRXFELEdBQ0FDLEdBQ0FDO29CQUVBLE1BQU1DLElBQWU7b0JBQ3JCLE1BQU1DLElBQWtCO29CQUN4QixNQUFNQyxJQUEwQm5OLFVBQzlCLGVBQTJFeUwsT0FBNURBLElBQUFBLDRCQUE4R0MsT0FBbERELElBQUFBLGtCQUFxSEEsT0FBbkVDLElBQUFBLDhCQUFxSEEsT0FBbERELElBQUFBLGtCQUFrREMsT0FBQUEsSUFBQUE7b0JBRXBQLE1BQU0wQixJQUE4QkQsQ0FBQUEsQ0FBd0I7b0JBQzVELE1BQU1FLElBQWdCRCxFQUE0QkUsU0FBQUE7b0JBQ2xELE1BQU1DLElBQWdCSCxFQUE0QkksVUFBQUE7b0JBQ2xELE1BQU1DLElBQXFCRixLQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxFQUFlQyxVQUFBQTtvQkFFMUMsSUFBSUUsSUFBWWpLLEVBQWMySjtvQkFDOUIsSUFBSU8sSUFBV0Q7b0JBQ2YsSUFBSUUsSUFBVTtvQkFDZCxJQUFJQztvQkFFSixNQUFNQyxRQUFRQTt3QkFDWm5JLGdCQUFnQjRILEdBQWVOO3dCQUMvQnRILGdCQUFnQjBILEdBQWVKO29CQUFhO29CQUU5QyxNQUFNYyxZQUFhQyxDQUFBQTt3QkFDakJILElBQVE7d0JBQ1IsSUFBSUQsR0FBUzs0QkFDWEYsSUFBWUM7NEJBQ1paLEVBQXNCaUIsTUFBVzt3QkFDbkM7b0JBQUE7b0JBRUYsTUFBTUMsV0FBWUMsQ0FBQUE7d0JBQ2hCUCxJQUFXbEssRUFBYzJKO3dCQUN6QlEsSUFBQUEsQ0FBV00sS0FBQUEsQ0FBZ0J2WCxRQUFRZ1gsR0FBVUQ7d0JBRTdDLElBQUlRLEdBQWE7NEJBQ2YxSSxnQkFBZ0IwSTs0QkFFaEIsSUFBSU4sS0FBQUEsQ0FBWUMsR0FBTztnQ0FDckIvZCxFQUFLK2Q7Z0NBQ0xBLElBQVE3ZCxFQUFLK2Q7NEJBQ2Y7d0JBQ0Y7NEJBQ0VBLFVBQVVHLE1BQWdCOzt3QkFHNUJKO29CQUFPO29CQUVULE1BQU1LLElBQWE7d0JBQ2pCL08sZUFBZTBOLEdBQWlCSzt3QkFDaEN0SSxpQkFBaUIwSSxHQUFlTCxHQUFpQmU7d0JBQ2pEcEosaUJBQWlCd0ksR0FBZUgsR0FBaUJlO3FCQUFBQTtvQkFHbkQxUSxTQUFTdVAsR0FBaUJ0QjtvQkFHMUJ0SyxVQUFVdU0sR0FBb0I7d0JBQzVCaFksQ0FBQ0EsRUFBQUEsRUFBV3dYO3dCQUNadlgsQ0FBQ0EsRUFBQUEsRUFBWXVYOztvQkFHZmpkLEVBQUs4ZDtvQkFFTCxPQUFPO3dCQUFDZCxJQUFzQmxXLEtBQUttWCxVQUFVLFNBQVNIO3dCQUFPSztxQkFBQUE7Z0JBQVc7OztBQ2pGekUsTUFBTUMsa0NBQWtDQSxDQUFDQyxHQUFzQ0M7SUFDcEYsUUFBTUMsR0FBRUMsQ0FBQUEsRUFBQUEsR0FBOEJGO0lBQ3RDLE9BQU9HLEdBQW9DQyxFQUFBQSxHQUF1Q0wsRUFDaEY7SUFHRixPQUFPO1FBQ0xJLEtBQ0VELEVBQTBCNUwsQ0FBQUEsSUFDMUI0TCxFQUEwQjNMLENBQUFBO1FBQzVCNkw7S0FBQUE7QUFDUTtBQUdMLE1BQU1DLG9CQUFxQkMsQ0FBQUEsSUFBcUJBLEVBQVNoYixPQUFBQSxDQUFRK0IsT0FBZ0I7QUFFakYsTUFBTWtaLGtDQUNYQyxDQUFBQSxJQUNrQkEsRUFBaUJDLE9BQUFBLENBQVEsR0FBR3BaLE9BQUFBLEdBQUFBLE1BQWU7QUFFeEQsTUFBTXFaLGtDQUFrQ0EsQ0FDN0NDLEdBQ0FDO0lBRUEsSUFBSUQsTUFBYTtRQUNmLE9BQU9DLElBQWNyWixJQUFZRDs7SUFHbkMsTUFBTXVaLElBQWdCRixLQUFZclo7SUFDbEMsT0FBTztRQUFDQTtRQUFXQztRQUFXRjtLQUFBQSxDQUFZbUgsUUFBQUEsQ0FBU3FTLEtBQzlDQSxJQUNEdlo7QUFBUztBQUdSLE1BQU13WiwwQkFBMEJBLENBQ3JDMUgsR0FDQXdIO0lBRUEsUUFBTUcsV0FBRUEsQ0FBQUEsRUFBU0MsV0FBRUEsQ0FBQUEsRUFBQUEsR0FBYzdOLFVBQVVpRyxHQUFTO1FBQUNuUztRQUFjQztLQUFBQTtJQUVuRSxPQUFPO1FBQ0xvTixHQUFHb00sZ0NBQWdDSyxHQUFXSCxFQUFZdE0sQ0FBQUE7UUFDMURDLEdBQUdtTSxnQ0FBZ0NNLEdBQVdKLEVBQVlyTSxDQUFBQTs7QUFDM0Q7QUN4QkksTUFBTTBNLEtBQTZCO0FBRTdCQyxNQUFBQSxLQUF5QyxhQUF6Q0EsR0FBeUMsS0FBUTtRQUM1REQsQ0FBQ0EsR0FBQUEsRUFBNkI7WUFDNUI5RixRQUFRQSxJQUFPO29CQUNiZ0csR0FBc0JBLENBQ3BCQyxHQUNBQyxHQUNBQyxHQUNBdEIsR0FDQXVCO3dCQUVBLFFBQU1DLEdBQUVDLENBQUFBLEVBQWlCQyxHQUFFQyxDQUFBQSxFQUFBQSxHQUFjUDt3QkFDekMsUUFBTVEsR0FBRUMsQ0FBQUEsRUFBdUI1QixHQUFFQyxDQUFBQSxFQUF5QjRCLEdBQUVDLENBQUFBLEVBQUFBLEdBQTBCL0I7d0JBQ3RGLE1BQU1nQyxJQUFBQSxDQUNIUCxLQUFBQSxDQUNBSSxLQUNBM0IsQ0FBQUEsRUFBMEI1TCxDQUFBQSxJQUFLNEwsRUFBMEIzTCxDQUFBQTt3QkFDNUQsT0FBTzBOLEVBQUFBLEdBQWdDbkMsZ0NBQWdDeUIsR0FBY3ZCO3dCQU1yRixNQUFNa0MsaUNBQWtDQyxDQUFBQTs0QkFDdEMsTUFBTUMsSUFDSlAsS0FBMkJJLElBQStCLElBQUk7NEJBRWhFLE1BQU1JLHVCQUF1QkEsQ0FDM0JDLEdBQ0FDLEdBQ0FDO2dDQUVBLE1BQU1DLElBQWdDSCxJQUNsQ0YsSUFDQUk7Z0NBQ0osTUFBTUUsSUFDSkgsS0FBQUEsQ0FBbUJWLElBQTBCWSxJQUFnQztnQ0FDL0UsTUFBTUUsSUFBOEJMLEtBQUFBLENBQUFBLENBQWdCRjtnQ0FFcEQsT0FBTztvQ0FBQ007b0NBQXNCQztpQ0FBQUE7NEJBQXFDOzRCQUdyRSxPQUFPQyxHQUF1QkMsRUFBQUEsR0FBZ0NSLHFCQUM1RG5DLEVBQTBCNUwsQ0FBQUEsRUFDMUI2TixFQUFzQjdOLENBQUFBLEtBQU0vTSxHQUM1QndhLEVBQXNCek4sQ0FBQUE7NEJBRXhCLE9BQU93TyxHQUF1QkMsRUFBQUEsR0FBZ0NWLHFCQUM1RG5DLEVBQTBCM0wsQ0FBQUEsRUFDMUI0TixFQUFzQjVOLENBQUFBLEtBQU1oTixHQUM1QndhLEVBQXNCeE4sQ0FBQUE7NEJBR3hCLE9BQU87Z0NBQ0x5TyxHQUF1QjtvQ0FDckIxTyxHQUFHc087b0NBQ0hyTyxHQUFHdU87O2dDQUVMRyxHQUE4QjtvQ0FDNUIzTyxHQUFHdU87b0NBQ0h0TyxHQUFHd087Ozt3QkFFTjt3QkFVSCxNQUFNRyx3QkFDSmYsQ0FBQUE7NEJBRUEsS0FBS1YsR0FBbUI7Z0NBQ3RCLFFBQU0wQixHQUFFQyxDQUFBQSxFQUFBQSxHQUFvQjlCO2dDQUM1QixNQUFNK0IsSUFBZ0NsWSxXQUNwQyxJQUNBO29DQUNFcEUsQ0FBQ0EsRUFBQUEsRUFBaUI7b0NBQ2xCQyxDQUFDQSxFQUFBQSxFQUFrQjtvQ0FDbkJGLENBQUNBLEVBQUFBLEVBQWdCOztnQ0FHckIsUUFBTXdjLEdBQUVOLENBQUFBLEVBQXFCTyxHQUFFTixDQUFBQSxFQUFBQSxHQUM3QmYsK0JBQStCQztnQ0FDakMsUUFBUTdOLEdBQUdrUCxDQUFBQSxFQUFValAsR0FBR2tQLENBQUFBLEVBQUFBLEdBQWFSO2dDQUNyQyxRQUFRM08sR0FBR29QLENBQUFBLEVBQWFuUCxHQUFHb1AsQ0FBQUEsRUFBQUEsR0FBZ0JYO2dDQUMzQyxRQUFNWSxHQUFFQyxDQUFBQSxFQUFBQSxHQUEwQnhDO2dDQUNsQyxNQUFNeUMsSUFBeUNWLElBQzNDdGMsSUFDQUM7Z0NBQ0osTUFBTWdkLElBQWtEWCxJQUNwRHhjLElBQ0FEO2dDQUNKLE1BQU1xZCxJQUF3QkgsQ0FBQUEsQ0FBc0JDLEVBQUFBO2dDQUNwRCxNQUFNRyxJQUFzQkosQ0FBQUEsQ0FBc0I3YyxFQUFBQTtnQ0FDbEQsTUFBTWtkLElBQXlCTCxDQUFBQSxDQUM3QkUsRUFBQUE7Z0NBRUYsTUFBTUksSUFBdUJOLENBQUFBLENBQXNCaGQsRUFBQUE7Z0NBR25Ed2MsQ0FBQUEsQ0FBaUJsYyxFQUFBQSxHQUFZLGVBRTdCLE9BREV3YyxJQUFjSyxJQUFBQSxDQUNoQjtnQ0FDQVgsQ0FBQUEsQ0FBaUJTLEVBQUFBLEdBQUFBLENBQXdCSCxJQUFjSztnQ0FHdkRYLENBQUFBLENBQWlCcmMsRUFBQUEsR0FBQUEsQ0FBb0IwYyxJQUFjTztnQ0FHbkQsSUFBSWpDLEdBQW1CO29DQUNyQnFCLENBQUFBLENBQWlCVSxFQUFBQSxHQUNmRyxJQUEwQlQsQ0FBQUEsSUFBV0UsSUFBYztvQ0FDckROLENBQUFBLENBQWlCeGMsRUFBQUEsR0FDZnNkLElBQXdCWCxDQUFBQSxJQUFXRSxJQUFjO2dDQUNyRDtnQ0FFQSxPQUFPTDs0QkFDVDt3QkFBQTt3QkFVRixNQUFNZSxtQkFBbUJBLENBQ3ZCakMsR0FDQWtDLEdBQ0FDOzRCQUVBLElBQUl0QyxHQUFtQjtnQ0FDckIsUUFBTTRCLEdBQUVDLENBQUFBLEVBQUFBLEdBQTBCeEM7Z0NBQ2xDLFFBQU1pQyxHQUFFTixDQUFBQSxFQUFxQk8sR0FBRU4sQ0FBQUEsRUFBQUEsR0FDN0JmLCtCQUErQkM7Z0NBQ2pDLFFBQVE3TixHQUFHa1AsQ0FBQUEsRUFBVWpQLEdBQUdrUCxDQUFBQSxFQUFBQSxHQUFhUjtnQ0FDckMsUUFBUTNPLEdBQUdvUCxDQUFBQSxFQUFhblAsR0FBR29QLENBQUFBLEVBQUFBLEdBQWdCWDtnQ0FDM0MsUUFBTUcsR0FBRUMsQ0FBQUEsRUFBQUEsR0FBb0I5QjtnQ0FDNUIsTUFBTWlELElBQXlEbkIsSUFDM0R6YyxJQUNBQztnQ0FDSixNQUFNNGQsSUFBd0NYLENBQUFBLENBQzVDVSxFQUFBQTtnQ0FFRixNQUFNRSxJQUFzQ1osRUFBc0JhLFVBQUFBO2dDQUNsRSxNQUFNQyxJQUF5Qk4sRUFBbUJ4UCxDQUFBQSxHQUFJeVAsRUFBYXpQLENBQUFBO2dDQUNuRSxNQUFNK1AsSUFBeUJQLEVBQW1CdlAsQ0FBQUEsR0FBSXdQLEVBQWF4UCxDQUFBQTtnQ0FDbkUsTUFBTStQLElBQWM7b0NBQ2xCaFEsR0FDRThPLEtBQWVGLElBQ1gsR0FDeUNlLE9BQXZDYixJQUFjZ0IsSUFBeUJILEdBQUFBLFFBRXpDO29DQUNOMVAsR0FDRTRPLEtBQWVGLElBQ1gsR0FDeUNpQixPQUF2Q2YsSUFBY2tCLElBQXlCSCxHQUFBQSxRQUV6Qzs7Z0NBR1I3UixVQUFVK08sR0FBVztvQ0FDbkIsWUFBWWtELEVBQVloUSxDQUFBQTtvQ0FDeEIsWUFBWWdRLEVBQVkvUCxDQUFBQTs7NEJBRTVCOzRCQUVBLE9BQU9rTjt3QkFBaUI7d0JBTTFCLE1BQU04Qyx1QkFBdUJBOzRCQUMzQixJQUFJOUMsR0FBbUI7Z0NBQ3JCLFFBQU0rQyxHQUFFQyxDQUFBQSxFQUFjbkIsR0FBdUJvQixDQUFBQSxFQUFBQSxHQUMzQzVEO2dDQUNGLE1BQU1jLElBQXdCckIsd0JBQXdCYSxHQUFXcUQ7Z0NBQ2pFLFFBQU16QixHQUFFTixDQUFBQSxFQUFBQSxHQUNOZiwrQkFBK0JDO2dDQUNqQyxRQUFRN04sR0FBR2tQLENBQUFBLEVBQVVqUCxHQUFHa1AsQ0FBQUEsRUFBQUEsR0FBYVI7Z0NBQ3JDLE1BQU1pQyxJQUFpQyxDQUFFO2dDQUN6QyxNQUFNQyxjQUFlcGQsQ0FBQUEsSUFDbkJqRCxLQUFLaUQsR0FBUUcsQ0FBQUE7d0NBQ1hnZCxDQUFBQSxDQUFrQmhkLEVBQUFBLEdBQ2hCK2MsQ0FBQUEsQ0FBcUIvYyxFQUFBQTtvQ0FBdUI7Z0NBR2xELElBQUlzYixHQUFBQTtvQ0FDRjJCLFlBQVk7d0NBQUNuZTt3Q0FBaUJOO3dDQUFlRztxQ0FBQUE7O2dDQUcvQyxJQUFJNGMsR0FBQUE7b0NBQ0YwQixZQUFZO3dDQUFDcmU7d0NBQWVDO3dDQUFnQkg7d0NBQWdCRDtxQ0FBQUE7O2dDQUc5RCxNQUFNeWUsSUFBWWpTLFVBQVV3TyxHQUFXMWMsS0FBS2lnQjtnQ0FDNUMsTUFBTUcsSUFBYTVXLGdCQUNqQmtULEdBQ0F0RixHQUNBRztnQ0FHRjVKLFVBQVUrTyxHQUFXdUQ7Z0NBRXJCLE9BQU87b0NBQ0x0UyxVQUNFK08sR0FDQXhXLFdBQVcsSUFBSWlhLEdBQVdsQyxzQkFBc0JmO29DQUVsRGtEO2dDQUFZOzRCQUVoQjs0QkFDQSxPQUFPalo7d0JBQUk7d0JBR2IsT0FBTzs0QkFDTGdZLEdBQUFBOzRCQUNBVSxHQUFBQTs0QkFDQTVCLEdBQUFBOztvQkFDRDs7OztBQ2hRRixNQUFNb0MsS0FBOEI7QUFFOUJDLE1BQUFBLEtBQW9DLGFBQXBDQSxHQUFvQyxLQUFRO1FBQ3ZERCxDQUFDQSxHQUFBQSxFQUE4QjtZQUM3Qm5LLFFBQ0VBLElBQ0EsQ0FDRXFLLEdBQ0FDLEdBQ0FDLEdBQ0FDO29CQVNBLElBQUlDLElBQVU7b0JBQ2QsSUFBSUMsSUFBcUJ6WjtvQkFDekIsTUFBTTBaLElBQWlCO29CQUN2QixNQUFNQyxJQUFnQjtvQkFDdEIsT0FBT0MsR0FBMEJDLEVBQUFBLEdBQy9CeGQsaUJBQWlCcWQ7b0JBQ25CLE1BQU1JLElBQW1CcGxCLEtBQUtTLElBQUFBLENBQUtra0I7b0JBQ25DLE1BQU1VLElBQTZCVCxJQUFlUTtvQkFDbEQsTUFBTUUsSUFBaUNELElBQTZCO29CQUNwRSxNQUFNamlCLFNBQVVvUSxDQUFBQSxJQUFjLEtBQUssSUFBSUEsQ0FBQUEsSUFBTSxLQUFJQSxDQUFBQTtvQkFDakQsTUFBTStSLHlCQUF5QkEsQ0FBQ3ZpQixHQUFjQyxJQUM1Q0YsY0FBY0MsR0FBTUMsR0FBSWdpQixHQUFlUCxHQUFvQnRoQjtvQkFDN0QsTUFBTW9pQix1QkFBdUJBLENBQUNDLEdBQW9CQyxJQUNoRDNpQixjQUNFMGlCLEdBQ0FkLElBQWVVLEdBQ2ZMLElBQWlCVSxHQUNqQixDQUFDNWhCLEdBQVVnSCxHQUFHNmE7NEJBQ1pqQixFQUFtQjVnQjs0QkFFbkIsSUFBSTZoQixHQUFBQTtnQ0FDRlosSUFBcUJRLHVCQUF1QnpoQixHQUFVNmdCOzt3QkFDeEQ7b0JBR04sTUFBTWlCLElBQXFCN2lCLGNBQ3pCLEdBQ0FzaUIsR0FDQUosR0FDQSxDQUFDWSxHQUF3Qi9hLEdBQUdnYjt3QkFDMUJwQixFQUFtQm1CO3dCQUVuQixJQUFJQyxHQUF5Qjs0QkFDM0JqQixFQUF1QkM7NEJBRXZCLEtBQUtBLEdBQVM7Z0NBQ1osTUFBTWlCLElBQTBCcEIsSUFBZWtCO2dDQUMvQyxNQUFNRyxJQUNKaG1CLEtBQUtTLElBQUFBLENBQUtzbEIsSUFBMEJULE9BQ3BDRjtnQ0FFRixJQUFJWSxHQUFBQTtvQ0FDRmQsRUFBeUI7d0NBQ3ZCLE1BQU1lLElBQ0pGLElBQTBCVjt3Q0FDNUIsTUFBTWEsSUFDSmxtQixLQUFLUyxJQUFBQSxDQUFLd2xCLE9BQW1DYjt3Q0FFL0NMLElBQXFCbUIsSUFDakJWLHFCQUNFSyxHQUNBN2xCLEtBQUtPLEdBQUFBLENBQUkwbEIsS0FBaUNyQixLQUU1Q1csdUJBQXVCTSxHQUF3QmxCO29DQUFhOzs0QkFHdEU7d0JBQ0Y7b0JBQUEsR0FFRnZoQjtvQkFHRixPQUFRK2lCLENBQUFBO3dCQUNOckIsSUFBVTt3QkFFVixJQUFJcUIsR0FBQUE7NEJBQ0ZQOzt3QkFHRlQ7d0JBQ0FKO29CQUFvQjtnQkFDckI7OztBQ2JULE1BQU1xQixlQUFnQmpoQixDQUFBQSxJQUNwQmtoQixLQUFLQyxTQUFBQSxDQUFVbmhCLEdBQU8sQ0FBQzJGLEdBQUd5YjtRQUN4QixJQUFJeGtCLFdBQVd3a0IsSUFBQUE7WUFDYixNQUFNOztRQUVSLE9BQU9BO0lBQUc7QUFHZCxNQUFNQyxnQkFBZ0JBLENBQUk5a0IsR0FBVStrQixJQUNsQy9rQixJQUNJLEdBQUcra0IsT0FBQUEsR0FDQTlhLEtBQUFBLENBQU0sS0FDTjZCLE1BQUFBLENBQU8sQ0FBQzlPLEdBQUcwSSxJQUFVMUksS0FBS3lMLGVBQWV6TCxHQUFHMEksS0FBUTFJLENBQUFBLENBQUUwSSxFQUFBQSxHQUFBQSxLQUFRaEcsR0FBWU0sS0FBQUEsS0FDNUVOO0FBK0tBLE1BQU1zbEIsS0FBdUM7SUFBQztJQUFHO0NBQUE7QUFDakQsTUFBTUMsS0FBb0M7SUFBQztJQUFJO0NBQUE7QUFDL0MsTUFBTUMsS0FBa0M7SUFBQztJQUFLO0lBQUs7Q0FBQTtBQUNuRCxNQUFNQyxLQUFrQztJQUM3Q0MsaUJBQWlCO0lBQ2pCM0YsOEJBQThCO0lBQzlCMWlCLFFBQVE7UUFDTnNvQixlQUFlO1lBQUM7Z0JBQUM7Z0JBQU87YUFBQTtTQUFBO1FBQ3hCdmUsVUFBVTtZQUNSd2UsVUFBVU47WUFDVk8sUUFBUTtZQUNSck4sT0FBTytNO1lBQ1B6SCxLQUFLMEg7O1FBRVBNLFlBQVk7UUFDWkMsZ0JBQWdCO1FBQ2hCQyxxQkFBcUI7O0lBRXZCNUgsVUFBVTtRQUNSaE0sR0FBRztRQUNIQyxHQUFHOztJQUVMNFQsWUFBWTtRQUNWQyxPQUFPO1FBQ1BDLFlBQVk7UUFDWkMsVUFBVTtRQUNWQyxlQUFlO1FBQ2ZDLGlCQUFpQjtRQUNqQkMsWUFBWTtRQUNaQyxhQUFhO1FBQ2JDLFVBQVU7WUFBQztZQUFTO1lBQVM7U0FBQTs7O0FBSTFCLE1BQU1DLGlCQUFpQkEsQ0FBSUMsR0FBZ0JDO0lBQ2hELE1BQU1DLElBQXVCLENBQUU7SUFDL0IsTUFBTUMsSUFBY3pqQixPQUFPTixLQUFLNmpCLElBQWE3akIsS0FBSzRqQjtJQUlsRC9qQixLQUFLa2tCLEdBQWNDLENBQUFBO1FBQ2pCLE1BQU1DLElBQWtCTCxDQUFBQSxDQUFZSSxFQUFBQTtRQUNwQyxNQUFNRSxJQUFpQkwsQ0FBQUEsQ0FBV0csRUFBQUE7UUFFbEMsSUFBSWptQixTQUFTa21CLE1BQW9CbG1CLFNBQVNtbUIsSUFBaUI7WUFDekRoZSxXQUFZNGQsQ0FBQUEsQ0FBS0UsRUFBQUEsR0FBYSxDQUFTLEdBQUdMLGVBQWVNLEdBQWlCQztZQUUxRSxJQUFJaGQsY0FBYzRjLENBQUFBLENBQUtFLEVBQUFBLEdBQUFBO3VCQUNkRixDQUFBQSxDQUFLRSxFQUFBQTs7UUFFaEIsT0FBTyxJQUFJaGUsZUFBZTZkLEdBQVlHLE1BQWNFLE1BQW1CRCxHQUFpQjtZQUN0RixJQUFJRSxJQUFTO1lBRWIsSUFBSXRtQixRQUFRb21CLE1BQW9CcG1CLFFBQVFxbUIsSUFBQUE7Z0JBQ3RDO29CQUNFLElBQUlqQyxhQUFhZ0MsT0FBcUJoQyxhQUFhaUMsSUFBQUE7d0JBQ2pEQyxJQUFTOztnQkFHWixFQUFDLE9BQUFsVyxHQUFBQSxDQUFNOztZQUdWLElBQUlrVyxHQUFBQTtnQkFHRkwsQ0FBQUEsQ0FBS0UsRUFBQUEsR0FBYUU7O1FBRXRCO0lBQUE7SUFHRixPQUFPSjtBQUFJO0FBR04sTUFBTU0sb0JBQ1hBLENBQ0UvcEIsR0FDQWdxQixHQUNBcHBCLElBRURxbkIsQ0FBQUEsSUFBUztZQUNSRCxjQUFjaG9CLEdBQVNpb0I7WUFDdkJybkIsS0FBU29uQixjQUFjZ0MsR0FBZ0IvQixPQUFBQSxLQUFVcmxCO1NBQUFBO0FDN1ZyRCxJQUFJcW5CO0FBRUcsTUFBTUMsV0FBV0EsSUFBTUQ7QUFDdkIsTUFBTUUsV0FBWUMsQ0FBQUE7SUFDdkJILEtBQVFHO0FBQVE7QUMyQ2xCLElBQUlDO0FBRUosTUFBTUMsb0JBQW9CQTtJQUN4QixNQUFNQyx5QkFBeUJBLENBQzdCQyxHQUNBQyxHQUNBN2dCO1FBR0E0SCxlQUFlblEsU0FBU3FwQixJQUFBQSxFQUFNRjtRQUM5QmhaLGVBQWVuUSxTQUFTcXBCLElBQUFBLEVBQU1GO1FBRTlCLE1BQU1HLElBQVE3VSxFQUFjMFU7UUFDNUIsTUFBTUksSUFBUS9VLEVBQWMyVTtRQUM1QixNQUFNSyxJQUFRN1Usa0JBQWtCeVU7UUFFaEMsSUFBSTdnQixHQUFBQTtZQUNGdUgsZUFBZXFaOztRQUdqQixPQUFPO1lBQ0x4VixHQUFHNFYsRUFBTXBWLENBQUFBLEdBQUltVixFQUFNblYsQ0FBQUEsR0FBSXFWLEVBQU1yVixDQUFBQTtZQUM3QlAsR0FBRzJWLEVBQU1yVixDQUFBQSxHQUFJb1YsRUFBTXBWLENBQUFBLEdBQUlzVixFQUFNdFYsQ0FBQUE7O0lBQzlCO0lBR0gsTUFBTXVWLDRCQUE2QkMsQ0FBQUE7UUFDakMsSUFBSXBpQixJQUFTO1FBQ2IsTUFBTXFpQixJQUFjcmIsU0FBU29iLEdBQVN0TztRQUN0QztZQUNFOVQsSUFDRWtMLFVBQVVrWCxHQUFTLHVCQUF5QyxVQUM1RGxYLFVBQVVrWCxHQUFTLFdBQVcsMkJBQTJCO1FBRTVELEVBQUMsT0FBQW5YLEdBQUFBLENBQU07UUFDUm9YO1FBQ0EsT0FBT3JpQjtJQUFNO0lBSWYsTUFBTXNpQixJQUFXLElBQTJKek8sT0FBdkpBLEdBQUFBLG9JQUF5TkMsT0FBbEVELEdBQUFBLCtDQUF5SUMsT0FBdkVBLEdBQUFBLHFDQUFrSUEsT0FBM0RBLEdBQUFBLHlCQUEyREEsT0FBQUEsR0FBQUE7SUFDaFgsTUFBTXlPLElBQVM5WSxVQUNiLGVBQTBENlksT0FBM0N6TyxHQUFBQSx3QkFBMkN5TyxPQUFBQSxHQUFBQTtJQUU1RCxNQUFNRSxJQUFTRCxDQUFBQSxDQUFPO0lBQ3RCLE1BQU1FLElBQWNELEVBQU92TCxVQUFBQTtJQUMzQixNQUFNeUwsSUFBV0YsRUFBT3pMLFNBQUFBO0lBQ3hCLE1BQU11SyxJQUFRQztJQUVkLElBQUlELEdBQUFBO1FBQ0ZvQixFQUFTcEIsS0FBQUEsR0FBUUE7O0lBR25CLE9BQU9yUCxLQUFZTyxFQUFBQSxHQUFnQmhCO0lBQ25DLE9BQU9tUixHQUFnQ0MsRUFBQUEsR0FBK0J4ckIsWUFDcEU7UUFDRUksR0FBZW9xQix1QkFBdUJZLEdBQVFDO1FBQzlDL3FCLEdBQVEySTtPQUVWRSxLQUFLcWhCLHdCQUF3QlksR0FBUUMsR0FBYTtJQUVwRCxPQUFPSSxFQUFBQSxHQUF3QkQ7SUFDL0IsTUFBTUUsSUFBeUJYLDBCQUEwQks7SUFDekQsTUFBTU8sSUFBMkI7UUFDL0IxVyxHQUFHd1csRUFBcUJ4VyxDQUFBQSxLQUFNO1FBQzlCQyxHQUFHdVcsRUFBcUJ2VyxDQUFBQSxLQUFNOztJQUVoQyxNQUFNMFcsSUFBOEM7UUFDbERDLFVBQVU7WUFDUkMsTUFBTTtZQUNOQyxTQUFBQSxDQUFVTDtZQUNWTSxVQUFXamdCLENBQUFBLElBQVcyZixLQUEwQnJiLGNBQWN0RSxNQUFXQTtZQUN6RWtnQixTQUFTOztRQUVYbkQsWUFBWTtZQUNWb0QsTUFBTTs7UUFFUkMsUUFBUTtZQUNOUiwwQkFBMEI7WUFDMUJoQixNQUFNOzs7SUFHVixNQUFNeUIsSUFBdUJ0Z0IsV0FBVyxDQUFFLEdBQUV3YztJQUM1QyxNQUFNK0QsSUFBb0JsakIsS0FDeEIyQyxZQUNBLElBQ0FzZ0I7SUFFRixNQUFNRSxJQUEyQm5qQixLQUMvQjJDLFlBQ0EsSUFDQThmO0lBR0YsTUFBTWpMLElBQVc7UUFDZitCLEdBQXVCK0k7UUFDdkI1SyxHQUEyQjhLO1FBQzNCbkosR0FBeUJrSjtRQUN6QmEsR0FBQUEsQ0FBQUEsQ0FBbUJ0cEI7UUFDbkJ1cEIsR0FBb0JyakIsS0FBSzBSLEdBQVU7UUFDbkM0UixHQUEyQkg7UUFDM0JJLEdBQTRCQyxDQUFBQSxJQUMxQjdnQixXQUFXOGYsR0FBNkJlLE1BQ3hDTDtRQUNGTSxJQUFvQlA7UUFDcEJRLElBQXFCQyxDQUFBQSxJQUNuQmhoQixXQUFXc2dCLEdBQXNCVSxNQUFzQlQ7UUFDekRVLElBQThCamhCLFdBQVcsQ0FBRSxHQUFFOGY7UUFDN0NvQixJQUF1QmxoQixXQUFXLElBQUlzZ0I7O0lBR3hDcGUsWUFBWW9kLEdBQVE7SUFDcEJoYSxlQUFlZ2E7SUFHZmxVLGlCQUFpQjNWLEdBQUssVUFBVTtRQUM5QjZaLEVBQWEsS0FBSztJQUFHO0lBR3ZCLElBQ0U1WCxXQUFXakMsRUFBSTByQixVQUFBQSxLQUFBQSxDQUNkdkIsS0FBQUEsQ0FBQUEsQ0FDQ0MsRUFBeUIxVyxDQUFBQSxJQUFBQSxDQUFNMFcsRUFBeUJ6VyxDQUFBQSxHQUMxRDtRQUNBLE1BQU1nWSxrQkFBbUJDLENBQUFBO1lBQ3ZCLE1BQU1DLElBQVE3ckIsRUFBSTByQixVQUFBQSxDQUFXLGdCQUFvQkksT0FBSjlyQixFQUFJOHJCLGdCQUFBQSxFQUFBQTtZQUNqRG5XLGlCQUNFa1csR0FDQSxVQUNBO2dCQUNFRDtnQkFDQUQsZ0JBQWdCQztZQUFPLEdBRXpCO2dCQUNFM1YsR0FBTzs7UUFFVjtRQUVIMFYsZ0JBQWdCO1lBQ2QsT0FBT0ksR0FBNEJDLEVBQUFBLEdBQ2pDaEM7WUFFRnpmLFdBQVc2VSxFQUFJK0IsQ0FBQUEsRUFBdUI0SztZQUN0Q2xTLEVBQWEsS0FBSztnQkFBQ21TO2FBQUFBO1FBQTRCO0lBRW5EO0lBRUEsT0FBTzVNO0FBQUc7QUFHTCxNQUFNNk0saUJBQWlCQTtJQUM1QixLQUFLbEQsSUFBQUE7UUFDSEEsS0FBc0JDOztJQUV4QixPQUFPRDtBQUFtQjtBQzFHNUIsTUFBTW1ELDJCQUEyQkEsQ0FDL0IxaEIsR0FDQXBHLEdBQ0ErbkI7SUFFQSxJQUFJQyxJQUFZO0lBQ2hCLE1BQU1qVyxJQUFNZ1csSUFBcUIsSUFBSUUsVUFBaUM7SUFDdEUsTUFBTUMsVUFBVUE7UUFDZEYsSUFBWTtJQUFJO0lBRWxCLE1BQU1HLGlCQUFtREMsQ0FBQUE7UUFDdkQsSUFBSXJXLEtBQU9nVyxHQUFvQjtZQUM3QixNQUFNTSxJQUFlTixFQUFtQmhXLEdBQUFBLENBQUsxUixDQUFBQTtnQkFDM0MsT0FBTzhKLEdBQVVnSCxFQUFBQSxHQUFjOVEsS0FBUTtnQkFDdkMsTUFBTTZsQixJQUFXL1UsS0FBY2hILElBQUFBLENBQVlpZSxLQUFlbGUsSUFBQUEsRUFBTUMsR0FBVS9ELEtBQVU7Z0JBQ3BGLE9BQU87b0JBQUM4ZjtvQkFBVS9VO2lCQUFBQTtZQUFvQjtZQUd4Q3JSLEtBQUt1b0IsR0FBZWhvQixDQUFBQSxJQUNsQlAsS0FBS08sQ0FBQUEsQ0FBSyxJQUFLd0gsQ0FBQUE7b0JBQ2IsTUFBTXNKLElBQWE5USxDQUFBQSxDQUFLO29CQUN4QixNQUFNaW9CLElBQVV2VyxFQUFJZ0QsR0FBQUEsQ0FBSWxOLE1BQVE7b0JBQ2hDLE1BQU0wZ0IsSUFBZ0JuaUIsRUFBT29pQixRQUFBQSxDQUFTM2dCO29CQUV0QyxJQUFJMGdCLEtBQWlCcFgsR0FBWTt3QkFDL0IsTUFBTXNYLElBQWlCbFgsaUJBQWlCMUosR0FBS3NKLEdBQWF1RSxDQUFBQTs0QkFDeEQsSUFBSXNTLEdBQVc7Z0NBQ2JTO2dDQUNBMVcsRUFBSTJXLE1BQUFBLENBQU83Z0I7NEJBQ2I7Z0NBQ0U3SCxFQUFTMFY7O3dCQUNYO3dCQUVGM0QsRUFBSXNELEdBQUFBLENBQUl4TixHQUFLbkgsS0FBSzRuQixHQUFTRztvQkFDN0IsT0FBTzt3QkFDTHBuQixnQkFBZ0JpbkI7d0JBQ2hCdlcsRUFBSTJXLE1BQUFBLENBQU83Z0I7b0JBQ2I7Z0JBQUE7UUFHTjtJQUFBO0lBR0ZzZ0I7SUFFQSxPQUFPO1FBQUNEO1FBQVNDO0tBQUFBO0FBQWU7QUFXM0IsTUFBTVEsb0JBQW9CQSxDQUMvQnZpQixHQUNBd2lCLEdBQ0E1b0IsR0FDQTFGO0lBRUEsSUFBSXV1QixJQUFjO0lBQ2xCLFFBQU1DLElBQ0pDLENBQUFBLEVBQVdDLElBQ1hDLENBQUFBLEVBQXdCQyxJQUN4QkMsQ0FBQUEsRUFBbUJDLElBQ25CQyxDQUFBQSxFQUFxQkMsSUFDckJDLENBQUFBLEVBQW1CQyxJQUNuQkMsQ0FBQUEsRUFBQUEsR0FDR252QixLQUFvRSxDQUFFO0lBQzNFLE9BQU9vdkIsR0FBMkJDLEVBQUFBLEdBQW9DN0IseUJBQ3BFMWhCLEdBQ0EsSUFBTXlpQixLQUFnQjdvQixFQUF3QyxPQUM5RG1wQjtJQUlGLE1BQU1TLElBQWtCYixLQUFlO0lBQ3ZDLE1BQU1jLElBQStCWixLQUE0QjtJQUNqRSxNQUFNYSxJQUFxQnZwQixPQUFPcXBCLEdBQWlCQztJQUNuRCxNQUFNRSxtQkFBbUJBLENBQ3ZCQyxHQUNBQztRQUVBLEtBQUsvb0IsYUFBYStvQixJQUFZO1lBQzVCLE1BQU1DLElBQXFCWCxLQUF1Qm5pQjtZQUNsRCxNQUFNK2lCLElBQXNCVixLQUF3QnJpQjtZQUNwRCxNQUFNZ2pCLElBQTRCO1lBQ2xDLE1BQU1DLElBQStCO1lBQ3JDLElBQUlDLElBQXNEO1lBQzFELElBQUlDLElBQWtEO1lBR3REenFCLEtBQUttcUIsR0FBWW5ILENBQUFBO2dCQUNmLFFBQU0wSCxlQUNKQSxDQUFBQSxFQUNBcGtCLFFBQVFxa0IsQ0FBQUEsRUFBY0MsTUFDdEJBLENBQUFBLEVBQUlDLFVBQ0pBLENBQUFBLEVBQVFDLFlBQ1JBLENBQUFBLEVBQVVDLGNBQ1ZBLENBQUFBLEVBQUFBLEdBQ0UvSDtnQkFDSixNQUFNZ0ksSUFBbUJKLE1BQVM7Z0JBQ2xDLE1BQU1LLElBQWtCTCxNQUFTO2dCQUNqQyxNQUFNTSxJQUF5QjVrQixNQUFXcWtCO2dCQUMxQyxNQUFNUSxJQUFlSCxLQUFvQk47Z0JBQ3pDLE1BQU12dkIsSUFDSmd3QixLQUFnQnJqQixRQUFRNmlCLEdBQStCRCxLQUFpQjtnQkFFMUUsTUFBTVUsSUFBaUJ2dEIsU0FBUzFDLEtBQVlBLElBQVc7Z0JBQ3ZELE1BQU1rd0IsSUFBbUJGLEtBQWdCTixNQUFhTztnQkFDdEQsTUFBTUUsSUFDSmpyQixRQUFRMHBCLEdBQThCVyxNQUFrQlc7Z0JBRzFELElBQUl2QyxLQUFzQm1DLENBQUFBLEtBQUFBLENBQW9CQyxDQUFBQSxHQUF5QjtvQkFDckUsTUFBTUssSUFBcUJQLEtBQW9CSztvQkFDL0MsTUFBTUcsSUFDSkQsS0FDQWhDLEtBQ0E3ZSxHQUFHaWdCLEdBQWdCcEI7b0JBQ3JCLE1BQU1rQyxJQUFnQkQsSUFBQUEsQ0FDakJwQixFQUFtQk8sR0FBZ0JELEdBQWVHLEdBQVVPLEtBQUFBLENBQzVESixLQUFvQk87b0JBQ3pCLE1BQU1HLElBQ0pELEtBQUFBLENBQWtCcEIsRUFBb0JySCxHQUFBQSxDQUFBQSxDQUFZd0ksR0FBZ0JsbEIsR0FBUTlMO29CQUU1RXdGLEtBQUs4cUIsR0FBYWpmLENBQUFBLElBQVNqTCxLQUFLMHBCLEdBQW1CemU7b0JBQ25EN0wsS0FBSytxQixHQUFlbGYsQ0FBQUEsSUFBU2pMLEtBQUswcEIsR0FBbUJ6ZTtvQkFFckQ0ZSxJQUFpQkEsS0FBa0JpQjtnQkFFckM7Z0JBRUEsS0FDRzVDLEtBQ0RvQyxLQUNBRyxLQUFBQSxDQUNDakIsRUFBbUJPLEdBQWdCRCxHQUFnQkcsR0FBVU8sSUFDOUQ7b0JBQ0F4cUIsS0FBSzJwQixHQUFvQkc7b0JBQ3pCRixJQUFxQkEsS0FBc0JjO2dCQUM3QztZQUFBO1lBSUZ6QixFQUFrQ3hmLENBQUFBLElBQ2hDaEosaUJBQWlCaXBCLEdBQW1COWdCLE1BQUFBLENBQWUsQ0FBQ2xKLEdBQUt1TDtvQkFDdkRqTCxLQUFLTixHQUFLOEosS0FBS0MsR0FBVXdCO29CQUN6QixPQUFPbkIsR0FBR21CLEdBQU14QixLQUFZekosS0FBS04sR0FBS3VMLEtBQVF2TDtnQkFBRyxHQUNoRDtZQUdMLElBQUl3b0IsR0FBbUI7Z0JBQ3JCLEtBQUtvQixLQUFlTyxHQUFBQTtvQkFDakJ2cUIsRUFBd0M7O2dCQUUzQyxPQUFPO29CQUFDO2lCQUFBO1lBR1Y7WUFFQSxLQUFLa0IsYUFBYW1wQixNQUF1QkMsR0FBb0I7Z0JBQzNELE1BQU1ocEIsSUFBTztvQkFDWEgsaUJBQWlCa3BCO29CQUNqQkM7aUJBQUFBO2dCQUdGLEtBQUtOLEdBQUFBO29CQUNGaHFCLEVBQXVDZSxLQUFBQSxDQUFNLEdBQUdPOztnQkFHbkQsT0FBT0E7WUFDVDtRQUNGO0lBQUE7SUFFRixNQUFNbXFCLElBQXFDLElBQUl0dUIsRUFDN0NxRyxLQUFLdW1CLGtCQUFrQjtJQUd6QixPQUFPO1FBQ0w7WUFDRTBCLEVBQWlCQyxPQUFBQSxDQUFRdGxCLEdBQVE7Z0JBQy9CNGMsWUFBWTtnQkFDWjJJLG1CQUFtQjtnQkFDbkJDLGlCQUFpQjlCO2dCQUNqQitCLFNBQVNqRDtnQkFDVGtELFdBQVdsRDtnQkFDWG1ELGVBQWVuRDs7WUFFakJDLElBQWM7WUFFZCxPQUFPO2dCQUNMLElBQUlBLEdBQWE7b0JBQ2ZhO29CQUNBK0IsRUFBaUJPLFVBQUFBO29CQUNqQm5ELElBQWM7Z0JBQ2hCO1lBQUE7UUFDRDtRQUVIO1lBQ0UsSUFBSUEsR0FBQUE7Z0JBQ0YsT0FBT2tCLGlCQUFpQixNQUFNMEIsRUFBaUJRLFdBQUFBOztRQUNqRDtLQUFBO0FBRUg7QUN0UUgsSUFBSUMsS0FBMkM7QUFTeEMsTUFBTUMscUJBQXFCQSxDQUNoQy9sQixHQUVBcVQsR0FDQW5mO0lBRUEsUUFBUTh4QixJQUFTMVMsQ0FBQUEsRUFBQUEsR0FBd0JwZixLQUFXLENBQUU7SUFDdEQsTUFBTSt4QixJQUNKM1YsOEJBQXlENEM7SUFDM0QsT0FBT2dULEVBQUFBLEdBQXdDanlCLFlBQXFDO1FBQ2xGSSxHQUFlO1FBQ2ZJLEdBQXFCOztJQUd2QixPQUFPO1FBQ0wsTUFBTWdnQixJQUE2QjtRQUNuQyxNQUFNMFIsSUFBbUI3ZixVQUN2QixlQUFxRHVMLE9BQXRDRixJQUFBQSxrQkFBc0NFLE9BQUFBLElBQUFBO1FBRXZELE1BQU11VSxJQUFzQkQsQ0FBQUEsQ0FBaUI7UUFDN0MsTUFBTUUsSUFBd0JELEVBQW9CdFMsVUFBQUE7UUFFbEQsTUFBTXdTLDZCQUE4QkMsQ0FBQUE7WUFDbEMsTUFBTUMsSUFBdUI5dUIsUUFBUTZ1QixNQUFBQSxDQUF3QnpyQixhQUFheXJCO1lBRTFFLElBQUlFLElBQU87WUFDWCxJQUFJblMsSUFBUztZQUdiLElBQUlrUyxHQUFzQjtnQkFDeEIsTUFBTUUsSUFBc0JILENBQUFBLENBQW1CO2dCQUMvQyxPQUFPN2IsS0FBbUJDLEVBQUFBLEdBQW1CdWIsRUFDM0NRLEVBQW9CQyxXQUFBQTtnQkFFdEIsTUFBTXJjLElBQWdCQyxxQkFBcUJHO2dCQUMzQzRKLElBQVM3SixnQkFBZ0JDLEdBQWlCQztnQkFDMUM4YixJQUFBQSxDQUFRblMsS0FBQUEsQ0FBV2hLO1lBQ3JCO2dCQUdFZ0ssSUFBU2lTLE1BQXVCOztZQUdsQyxLQUFLRSxHQUFBQTtnQkFDSHBULEVBQXNCO29CQUNwQnVULElBQWM7b0JBQ2RaLElBQVMxUjs7O1FBRWI7UUFHRixJQUFJcmQsR0FBMkI7WUFDN0IsS0FBS08sVUFBVXN1QixLQUEyQjtnQkFDeEMsTUFBTWUsSUFBOEIsSUFBSTV2QixFQUEwQitKO2dCQUNsRTZsQixFQUE0QnZCLE9BQUFBLENBQVF0bEIsR0FBUTtvQkFHMUMsSUFBQThtQixPQUFJQTt3QkFDRmhCLEtBQTJCO29CQUM3Qjs7Z0JBRUZBLEtBQTJCQSxNQUE0QjtnQkFDdkRlLEVBQTRCakIsVUFBQUE7WUFDOUI7WUFrQkEsTUFBTW1CLElBQXNDN29CLFNBQVNvb0IsNEJBQTRCO2dCQUMvRWxvQixHQUFpQjtnQkFDakJFLEdBQW9COztZQUV0QixNQUFNMG9CLHlCQUEwQjlFLENBQUFBLElBQzlCNkUsRUFBb0M3RTtZQUN0QyxNQUFNK0UsSUFBMkIsSUFBSWh3QixFQUEwQit2QjtZQUMvREMsRUFBeUIzQixPQUFBQSxDQUFRUSxLQUEyQjlsQixJQUFTcW1CO1lBRXJFL3JCLEtBQUttYSxHQUFZO2dCQUNmO29CQUNFd1MsRUFBeUJyQixVQUFBQTtnQkFBWTtnQkFBQSxDQU90Q0UsTUFBNEJwZ0IsZUFBZTFGLEdBQVFvbUI7YUFBQUE7WUFHdEQsSUFBSU4sSUFBMEI7Z0JBQzVCLE1BQU1vQixJQUEwQixJQUFJandCLEVBQTBCK3ZCO2dCQUM5REUsRUFBd0I1QixPQUFBQSxDQUFRdGxCLEdBQVE7b0JBQ3RDOG1CLEtBQUs7O2dCQUVQeHNCLEtBQUttYSxHQUFZLElBQU15UyxFQUF3QnRCLFVBQUFBO1lBQ2pEO1FBQ0QsT0FBTSxJQUFJSyxHQUFvQjtZQUM3QixPQUFPa0IsR0FBc0JDLEVBQUFBLEdBQW9CbkIsRUFDL0NJLEdBQ0FDLDRCQUNBaFQ7WUFFRmhaLEtBQ0VtYSxHQUNBdGEsT0FDRTtnQkFDRTBKLFNBQVN1aUIsR0FBcUJ4VTtnQkFDOUJ6RyxpQkFBaUJpYixHQUFxQixrQkFBa0JlO2dCQUN4RHpoQixlQUFlMUYsR0FBUW9tQjthQUFBQSxFQUV6QmdCO1FBR047WUFDRSxPQUFPcG1COztRQUdULE9BQU81RCxLQUFLbkMsaUJBQWlCd1o7SUFBVztBQUN6QztBQ3hKSSxNQUFNNFMsd0JBQXdCQSxDQUNuQ3JuQixHQUNBc25CO0lBRUEsSUFBSUM7SUFDSixNQUFNQyxvQkFBcUJDLENBQUFBLElBQ3hCQSxFQUE2Qi9kLENBQUFBLEtBQU0sS0FDbkMrZCxFQUE0Q0MsY0FBQUEsSUFDNUNELEVBQTRDRSxpQkFBQUEsR0FBb0I7SUFDbkUsTUFBTUMsSUFBa0IxaEIsVUFBVStMO0lBQ2xDLE9BQU80VixFQUFBQSxHQUE4QjV6QixZQUFZO1FBQy9DSSxHQUFlOztJQUVqQixNQUFNeXpCLGtDQUFrQ0EsQ0FDdENDLEdBQ0FuRTtRQUVBLElBQUltRSxHQUFhO1lBQ2YsTUFBTUMsSUFBa0JILEVBQTJCTCxrQkFBa0JPO1lBQ3JFLFNBQVNFLEVBQUFBLEdBQTBCRDtZQUNuQyxPQUNFQyxLQUFBQSxDQUNDckUsS0FDRDBELEVBQXlCVSxNQUFvQjtnQkFBQ0E7YUFBQUE7UUFFbEQ7SUFBQTtJQUVGLE1BQU1FLCtCQUErQkEsQ0FDbkN0RSxHQUNBMUIsSUFDRzRGLGdDQUFnQzVGLEVBQVFpRyxHQUFBQSxJQUFPdkU7SUFFcEQsT0FBTztRQUNMO1lBQ0UsTUFBTW5QLElBQTZCO1lBRW5DLElBQUl6ZCxHQUFpQztnQkFDbkN1d0IsSUFBK0IsSUFBSXZ3QixFQUNqQ29HLEtBQUs4cUIsOEJBQThCLFFBQ25DO29CQUFFRSxNQUFNcG9COztnQkFFVnVuQixFQUE2QmpDLE9BQUFBLENBQVFzQztnQkFDckN0dEIsS0FBS21hLEdBQVk7b0JBQ2Y4UyxFQUE4QjNCLFVBQUFBO2dCQUFZO1lBRTlDLE9BQU87Z0JBQ0wsTUFBTXlDLGdCQUFnQkE7b0JBQ3BCLE1BQU1DLElBQVV2ZSxFQUFjNmQ7b0JBQzlCRSxnQ0FBZ0NRO2dCQUFRO2dCQUUxQ2h1QixLQUFLbWEsR0FBWXNSLG1CQUFtQjZCLEdBQWlCUztnQkFDckRBO1lBQ0Y7WUFFQSxPQUFPanJCLEtBQUtuQyxpQkFBaUJYLEtBQUttYSxHQUFZL08sZUFBZTFGLEdBQVE0bkI7UUFBa0I7UUFFekYsSUFDRUwsS0FDQVcsNkJBQTZCLE1BQU1YLEVBQTZCMUIsV0FBQUE7S0FBQUE7QUFDbkU7QUNuQkksTUFBTTBDLHVCQUF1QkEsQ0FDbEN2UyxHQUNBQyxHQUNBdVMsR0FDQUM7SUFHQSxJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUVKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJcGU7SUFDSixJQUFJcWU7SUFDSixNQUFNQyxJQUFlLElBQUlsWSxPQUFBQSxHQUFBQTtJQUl6QixNQUFNbVksSUFBbUIsSUFBSWpZLE9BQUFBLEdBQUFBO0lBQzdCLE1BQU1rWSxJQUF5QjtRQUFDO1FBQU07UUFBUztRQUFTO1FBQVE7UUFBUTtRQUFRO0tBQUE7SUFDaEYsUUFBTUMsSUFDSkMsQ0FBQUEsRUFBT0MsSUFDUEMsQ0FBQUEsRUFBS2pULEdBQ0xDLENBQUFBLEVBQVNpVCxJQUNUQyxDQUFBQSxFQUFvQkMsSUFDcEJDLENBQUFBLEVBQVF2VCxHQUNSQyxDQUFBQSxFQUFpQnVULElBQ2pCQyxDQUFBQSxFQUFPQyxJQUNQQyxDQUFBQSxFQUFpQkMsSUFDakJDLENBQUFBLEVBQXVCQyxJQUN2QkMsQ0FBQUEsRUFBQUEsR0FDRW5VO0lBQ0osTUFBTW9VLG9CQUFxQjNvQixDQUFBQSxJQUE4QnNHLFVBQVV0RyxHQUFLLGlCQUFpQjtJQUN6RixNQUFNNG9CLGdDQUFnQ0E7UUFDcEMsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osTUFBTXByQixJQUFjbEIsU0FBU3VxQixHQUFvQjtZQUMvQ3JxQixHQUFpQkEsSUFBTWtzQjtZQUN2QmhzQixHQUFvQkEsSUFBTWlzQjtZQUMxQjlyQixHQUFVQSxJQUFNK3JCO1lBQ2hCN3JCLEdBQWE4ckIsQ0FBQUEsRUFBTTExQixDQUFBQTtnQkFDakIsT0FBTzIxQixFQUFBQSxHQUFXRDtnQkFDbEIsT0FBT0UsRUFBQUEsR0FBVzUxQjtnQkFDbEIsT0FBTztvQkFDTG9GLE9BQU9OLEtBQUs2d0IsSUFBVTd3QixLQUFLOHdCLElBQVV6bkIsTUFBQUEsQ0FBTyxDQUFDOUwsR0FBSzBDO3dCQUNoRDFDLENBQUFBLENBQUkwQyxFQUFBQSxHQUFPNHdCLENBQUFBLENBQVE1d0IsRUFBQUEsSUFBZ0M2d0IsQ0FBQUEsQ0FBUTd3QixFQUFBQTt3QkFDM0QsT0FBTzFDO29CQUFHLEdBQ1QsQ0FBaUI7aUJBQUE7WUFFeEI7O1FBRUYsTUFBTWlFLEtBQUtBLENBQ1R1dkIsR0FDQUM7WUFFQSxJQUFJbnpCLFFBQVFtekIsSUFBaUI7Z0JBQzNCLE9BQU9DLEdBQVFDLEdBQVd4ckIsRUFBQUEsR0FBV3NyQjtnQkFDckNQLElBQXFCUTtnQkFDckJQLElBQXdCUTtnQkFDeEJQLElBQXNCanJCO1lBQ3hCLE9BQU8sSUFBSWpJLFNBQVN1ekIsSUFBaUI7Z0JBQ25DUCxJQUFxQk87Z0JBQ3JCTixJQUF3QjtnQkFDeEJDLElBQXNCO1lBQ3hCLE9BQU87Z0JBQ0xGLElBQXFCO2dCQUNyQkMsSUFBd0I7Z0JBQ3hCQyxJQUFzQjtZQUN4QjtZQUVBcHJCLEVBQVl3ckI7UUFBWTtRQUUxQnZ2QixHQUFHdUUsQ0FBQUEsR0FBU1IsRUFBWVEsQ0FBQUE7UUFFeEIsT0FBT3ZFO0lBQUU7SUFHWCxNQUFNMnZCLElBQTZCO1FBQ2pDQyxJQUFrQjtRQUNsQmpULEdBQWlCb1Msa0JBQWtCZjs7SUFFckMsTUFBTXpVLElBQU02TTtJQUNaLE1BQU15SixJQUF5QjVhLDhCQUM3QnVGO0lBRUYsT0FBT3NWLEVBQUFBLEdBQTBCbDNCLFlBQy9CO1FBQ0VNLEdBQVEwSTtRQUNSNUksR0FBZTtZQUFFb1YsR0FBRztZQUFHQyxHQUFHOztPQUU1QjtRQUNFLE1BQU0waEIsSUFDSkYsS0FDQUEsRUFBdUJuVixDQUFBQSxDQUNyQkMsR0FDQUMsR0FDQStVLEdBQ0FwVyxHQUNBNFQsR0FDQTlPLENBQUFBO1FBRUosTUFBTTJSLElBQXVCeEIsS0FBV3hUO1FBQ3hDLE1BQU1pVixJQUFBQSxDQUNIRCxLQUF3QjVuQixhQUFhOGxCLEdBQU94WSxHQUFtQkY7UUFDbEUsTUFBTTBhLElBQUFBLENBQWNsVixLQUFxQjBULEVBQWtCM1k7UUFDM0QsTUFBTW9hLElBQWVELEtBQWNsZixpQkFBaUJvZDtRQUNwRCxNQUFNZ0MsSUFBOEJELEtBQWdCckI7UUFFcEQsTUFBTXVCLElBQWtCekIsRUFBd0I1WSxHQUE0QmlhO1FBQzVFLE1BQU1LLElBQXNCSixLQUFjSCxLQUF1QkE7UUFDakUsTUFBTVEsSUFBaUIzaEIsRUFBY3NNO1FBQ3JDLE1BQU1zVixJQUFhM2hCLGtCQUFrQnFNO1FBRXJDLElBQUlvVixHQUFBQTtZQUNGQTs7UUFHRjFmLGdCQUFnQndkLEdBQXNCK0I7UUFDdEMsSUFBSUMsR0FBQUE7WUFDRkE7O1FBRUYsSUFBSUgsR0FBQUE7WUFDRkk7O1FBR0YsT0FBTztZQUNMamlCLEdBQUdtaUIsRUFBZW5pQixDQUFBQSxHQUFJb2lCLEVBQVdwaUIsQ0FBQUE7WUFDakNDLEdBQUdraUIsRUFBZWxpQixDQUFBQSxHQUFJbWlCLEVBQVduaUIsQ0FBQUE7O0lBQ2xDO0lBR0wsTUFBTW9pQixJQUE4QnpCO0lBQ3BDLE1BQU0wQixlQUFnQm5CLENBQUFBO1FBQ3BCLE1BQU1vQixJQUFvQjVCLGtCQUFrQmY7UUFDNUN0cEIsV0FBVzZxQixHQUFhO1lBQUVxQixJQUFtQmpELE1BQXVCZ0Q7O1FBQ3BFanNCLFdBQVdpckIsR0FBTztZQUFFaFQsR0FBaUJnVTs7UUFDckNoRCxJQUFxQmdEO0lBQWlCO0lBRXhDLE1BQU1FLG1CQUFtQkEsQ0FDdkJDLEdBQ0F2STtRQUVBLE9BQU9vRSxHQUFpQkMsRUFBQUEsR0FBMEJrRTtRQUNsRCxNQUFNdkIsSUFBeUM7WUFDN0N3QixJQUF5Qm5FOztRQUczQmxvQixXQUFXaXJCLEdBQU87WUFBRUMsSUFBa0JqRDs7UUFFdEMsS0FBS3BFLEdBQUFBO1lBQ0g2RSxFQUFtQm1DOztRQUdyQixPQUFPQTtJQUFXO0lBRXBCLE1BQU12QyxnQkFBZ0JBO1lBQUFBLEVBQUd6QixJQUFBQSxDQUFBQSxFQUFjWixJQUFBQSxDQUFBQSxFQUFBQTtRQUVyQyxNQUFNcUcsSUFBV3JHLElBQVV5QyxJQUFxQnFEO1FBQ2hELE1BQU1sQixJQUF5QztZQUM3Q2hFLElBQWNBLEtBQWdCWjtZQUM5QkEsSUFBQUE7O1FBR0YrRixhQUFhbkI7UUFDYnlCLEVBQVN6QixHQUFhakM7SUFBZTtJQUV2QyxNQUFNMkQsb0JBQW9CQSxDQUN4QkMsR0FDQTNJO1FBRUEsU0FBUzRJLEVBQUFBLEdBQW9CckI7UUFDN0IsTUFBTVAsSUFBeUM7WUFDN0M0QixJQUFBQTs7UUFHRlQsYUFBYW5CO1FBRWIsSUFBSTRCLEtBQUFBLENBQXFCNUksR0FBQUE7WUFDdkJrSSxFQUNFbEIsR0FDQTJCLElBQTZCM0QsSUFBZ0JGOztRQUlqRCxPQUFPa0M7SUFBVztJQUVwQixNQUFNNkIsaUJBQWlCQSxDQUNyQnhJLEdBQ0FDLEdBQ0FOO1FBRUEsTUFBTWdILElBQXlDO1lBQzdDOEIsSUFBZXhJOztRQUdqQjZILGFBQWFuQjtRQUViLElBQUkxRyxLQUFBQSxDQUF1Qk4sR0FBQUE7WUFDekJrSSxFQUE0QmxCLEdBQWFsQzs7UUFRM0MsT0FBT2tDO0lBQVc7SUFFcEIsT0FBTytCLEdBQTBCQyxFQUFBQSxHQUF5QmpELElBQ3REdEMsc0JBQXNCa0MsR0FBTzJDLG9CQUM3QjtJQUNKLE1BQU1XLElBQUFBLENBQ0h4VyxLQUNEMFAsbUJBQW1Cd0QsR0FBT2xCLGVBQWU7UUFDdkNyQyxJQUFTOztJQUViLE9BQU84RyxHQUErQkMsRUFBQUEsR0FBOEJ4SyxrQkFDbEVnSCxHQUNBLE9BQ0FrRCxnQkFDQTtRQUNFNUosSUFBMEJzRztRQUMxQnhHLElBQWF3Rzs7SUFHakIsTUFBTTZELElBQ0ozVyxLQUNBcGYsS0FDQSxJQUFJQSxFQUEyQmlyQixDQUFBQTtRQUM3QixNQUFNeFgsSUFBa0J3WCxDQUFBQSxDQUFRQSxFQUFRcHFCLE1BQUFBLEdBQVMsR0FBRzZ1QixXQUFBQTtRQUNwRDBCLGNBQWM7WUFDWnpCLElBQWM7WUFDZFosSUFBU3ZiLGdCQUFnQkMsR0FBaUJDOztRQUU1Q0EsSUFBa0JEO0lBQWU7SUFHckMsT0FBTztRQUNMO1lBR0UsSUFBSXNpQixHQUFBQTtnQkFDRkEsRUFBK0IxSCxPQUFBQSxDQUFRaUU7O1lBRXpDLE1BQU0wRCxJQUFzQkosS0FBeUJBO1lBQ3JELE1BQU1LLElBQXlCUCxLQUE0QkE7WUFDM0QsTUFBTVEsSUFBOEJMO1lBQ3BDLE1BQU1NLElBQXVCeFksRUFBSTZMLENBQUFBLENBQW9CNE0sQ0FBQUE7Z0JBQ25ELFNBQVNiLEVBQUFBLEdBQW9CckI7Z0JBQzdCVyxFQUNFO29CQUFFdUIsSUFBQUE7b0JBQXVCYixJQUFBQTtvQkFBa0I1RixJQUFjaUQ7bUJBQ3pEaEI7WUFDRDtZQUdILE9BQU87Z0JBQ0wsSUFBSW1FLEdBQUFBO29CQUNGQSxFQUErQnBILFVBQUFBOztnQkFFakMsSUFBSXFILEdBQUFBO29CQUNGQTs7Z0JBRUYsSUFBSUMsR0FBQUE7b0JBQ0ZBOztnQkFFRixJQUFJbkUsR0FBQUE7b0JBQ0ZBOztnQkFFRm9FO2dCQUNBQztZQUFzQjtRQUN2QjtRQUVIO2dCQUFBLEVBQUdFLElBQUFBLENBQUFBLEVBQWNDLElBQUFBLENBQUFBLEVBQWNDLElBQUFBLENBQUFBLEVBQUFBO1lBQzdCLE1BQU01QyxJQUF5QyxDQUFFO1lBRWpELE9BQU8vTixFQUFBQSxHQUFrQnlRLEVBQWE7WUFDdEMsT0FBTzFRLEdBQVk2USxFQUFBQSxHQUFxQkgsRUFBYTtZQUNyRCxPQUFPN1EsR0FBZWlSLEVBQUFBLEdBQXdCSixFQUFhO1lBQzNELE9BQU9LLEdBQWVDLEVBQUFBLEdBQW1CTixFQUFhO1lBQ3RELE1BQU1PLElBQWlDSCxLQUF3QkQ7WUFDL0QsTUFBTTVILElBQWMwSCxLQUFnQkM7WUFDcEMsTUFBTU0sNEJBQTZCcFIsQ0FBQUEsSUFDakNqbEIsV0FBV29sQixNQUFtQkEsRUFBZUg7WUFFL0MsSUFBSW1SLEdBQWdDO2dCQUNsQyxJQUFJL0UsR0FBQUE7b0JBQ0ZBOztnQkFFRixJQUFJQyxHQUFBQTtvQkFDRkE7O2dCQUdGLE9BQU9nRixHQUFXNTVCLEVBQUFBLEdBQVVvdUIsa0JBQzFCb0gsS0FBWXBULEdBQ1osTUFDQStWLG1CQUNBO29CQUNFM0osSUFBYXhvQixPQUFPZ3ZCLEdBQXdCdk0sS0FBYztvQkFDMURtRyxJQUFxQnRHO29CQUNyQndHLElBQXVCZ0c7b0JBQ3ZCNUYsSUFBc0JBLENBQUMzRyxHQUFVd0k7d0JBQy9CLFFBQVFsbEIsUUFBUXFrQixDQUFBQSxFQUFjRCxlQUFFQSxDQUFBQSxFQUFBQSxHQUFrQjFIO3dCQUNsRCxNQUFNc1IsSUFBQUEsQ0FDSDlJLEtBQWtCZCxLQUFBQSxDQUFrQi9OLElBQ2pDdFIsWUFBWXNmLEdBQWdCNEUsR0FBY0MsS0FDMUM7d0JBQ04sT0FDRThFLEtBQUFBLENBQUFBLENBQ0VycEIsUUFBUTBmLEdBQWdCLElBQUlsUyxPQUFBQSxRQUFBQSxDQUFBQSxDQUM1QjJiLDBCQUEwQnBSO29CQUFTOztnQkFNN0NxTSxJQUFpQ2dGO2dCQUNqQ2pGLElBQWdDMzBCO1lBQ2xDO1lBRUEsSUFBSXk1QixHQUFpQjtnQkFDbkI5QixFQUE0QmxzQixDQUFBQTtnQkFFNUIsSUFBSWxJLFFBQVFpMkIsTUFBa0JyMkIsU0FBU3EyQixJQUFnQjtvQkFFckRqRixJQUFtQmlGO29CQUNuQmhGLElBQWlCO29CQUNqQkMsSUFBZ0J2TTtvQkFDaEJ3TSxJQUFjdk07Z0JBQ2hCLE9BQU8sSUFBSXRrQixjQUFjMjFCLElBQWdCO29CQUN2Q2pGLElBQW1CaUYsRUFBY2pSLFFBQUFBO29CQUNqQ2lNLElBQWlCZ0YsRUFBY2hSLE1BQUFBO29CQUMvQmlNLElBQWdCK0UsRUFBY3JlLEtBQUFBO29CQUM5QnVaLElBQWM4RSxFQUFjL1ksR0FBQUE7Z0JBQzlCLE9BQU87b0JBQ0w4VCxJQUFtQjtvQkFDbkJDLElBQWlCO29CQUNqQkMsSUFBZ0I7b0JBQ2hCQyxJQUFjO2dCQUNoQjtZQUNGO1lBRUEsSUFBSWhELEdBQWE7Z0JBQ2YsTUFBTW9JLElBQW1CbEI7Z0JBQ3pCLE1BQU1tQixJQUFzQnRCLEtBQXlCQTtnQkFDckQsTUFBTXVCLElBQ0pyRixLQUFpQ0E7Z0JBRW5DLElBQUltRixHQUFBQTtvQkFDRmx1QixXQUNFNnFCLEdBQ0E2QixlQUFld0IsQ0FBQUEsQ0FBaUIsSUFBSUEsQ0FBQUEsQ0FBaUIsSUFBSXBJOztnQkFJN0QsSUFBSXFJLEdBQUFBO29CQUNGbnVCLFdBQVc2cUIsR0FBYXNCLGlCQUFpQmdDLENBQUFBLENBQW9CLElBQUlySTs7Z0JBR25FLElBQUlzSSxHQUFBQTtvQkFDRnB1QixXQUFXNnFCLEdBQWEwQixrQkFBa0I2QixDQUFBQSxDQUFvQixJQUFJdEk7O1lBRXRFO1lBRUFrRyxhQUFhbkI7WUFFYixPQUFPQTtRQUFXO1FBRXBCSTtLQUFBQTtBQUNEO0FDNVVJLE1BQU1vRCx3QkFBd0JBLENBQ25DbHpCLEdBQ0FMLElBQ09wRCxXQUFXb0QsS0FBU0EsRUFBTUYsS0FBQUEsQ0FBTSxHQUFHTyxLQUFRTDtBQUU3QyxNQUFNd3pCLDhCQUE4QkEsQ0FDekNuekIsR0FDQW96QixHQUNBQyxHQUNBQztJQUVBLE1BQU1DLElBQXVCdDNCLFlBQVlxM0IsS0FDckNELElBQ0FDO0lBQ0osTUFBTUUsSUFBeUJOLHNCQUM3Qmx6QixHQUNBdXpCO0lBRUYsT0FBT0MsS0FBMEJKLEVBQW9DM3pCLEtBQUFBLENBQU0sR0FBR087QUFBSztBQUc5RSxNQUFNeXpCLCtCQUErQkEsQ0FDMUN6ekIsR0FDQTB6QixHQUNBQyxHQUNBQztJQUVBLE1BQU1DLElBQXdCNTNCLFlBQVkyM0IsS0FDdENELElBQ0FDO0lBQ0osTUFBTUosSUFBeUJOLHNCQUM3Qmx6QixHQUNBNnpCO0lBRUYsU0FDSUwsS0FDRHYyQixDQUFBQSxjQUFjdTJCLEtBQ1hBLElBQ0FFLEVBQXFDajBCLEtBQUFBLENBQU0sR0FBR08sRUFBQUE7QUFBTTtBQUlyRCxNQUFNOHpCLHVCQUF1QkEsQ0FDbENDLEdBQ0FDO0lBRUEsUUFBTXRQLDBCQUFFQSxDQUFBQSxFQUF3QmhCLE1BQUVBLENBQUFBLEVBQUFBLEdBQVNzUSxLQUE2QixDQUFFO0lBQzFFLFFBQU1yYSxHQUFFQyxDQUFBQSxFQUF5QjBCLEdBQUVDLENBQUFBLEVBQXVCMFksR0FBRXpPLENBQUFBLEVBQUFBLEdBQzFEZTtJQUNGLFFBQVE3QiwwQkFBMEJ3UCxDQUFBQSxFQUFpQ3hRLE1BQU15USxDQUFBQSxFQUFBQSxHQUN2RTNPLElBQTRCTixNQUFBQTtJQUU5QixNQUFNa1AsSUFDSjFQLEtBQUFBLE9BQUFBLElBQTRCd1A7SUFDOUIsTUFBTUcsSUFBbUNwNEIsWUFBWXluQixLQUFReVEsSUFBY3pRO0lBRTNFLE1BQU00USxJQUFBQSxDQUNIMWEsRUFBMEI1TCxDQUFBQSxJQUFLNEwsRUFBMEIzTCxDQUFBQSxLQUMxRG1tQjtJQUNGLE1BQU1HLElBQ0pSLEtBQ0M1M0IsQ0FBQUEsT0FBT2s0QixLQUFBQSxDQUNIOVksSUFDRDhZLENBQUFBO0lBRU4sU0FBU0MsS0FBQUEsQ0FBQUEsQ0FBbUNDO0FBQTZCO0FDMUZwRSxNQUFNQyxnQ0FBZ0NBLENBQzNDMXZCLEdBQ0FnVyxHQUNBQyxHQUNBMFo7SUFFQSxNQUFNQyxJQUErQjtJQUNyQyxNQUFNQyxJQUE2QjtJQUNuQyxNQUFNQyxJQUErQjtJQUNyQyxRQUFNWCxHQUFFek8sQ0FBQUEsRUFBQUEsR0FBOEJlO0lBQ3RDLFFBQVExRSxZQUFZZ1QsQ0FBQUEsRUFBQUEsR0FBMEJyUDtJQUM5QyxRQUFRUCxNQUFNNlAsQ0FBQUEsRUFBQUEsR0FBOEJEO0lBQzVDLFFBQU0zRyxJQUNKQyxDQUFBQSxFQUFPQyxJQUNQQyxDQUFBQSxFQUFLalQsR0FDTEMsQ0FBQUEsRUFBUzBaLElBQ1RDLENBQUFBLEVBQVkxRyxJQUNaQyxDQUFBQSxFQUFvQkcsSUFDcEJDLENBQUFBLEVBQU96VCxHQUNQQyxDQUFBQSxFQUFBQSxHQUNFTDtJQUNKLFFBQVErRyxZQUFZb1QsQ0FBQUEsRUFBQUEsR0FBb0JELElBQWUsS0FBS2x3QjtJQUM1RCxRQUFRbWdCLE1BQU1pUSxDQUFBQSxFQUFBQSxHQUF1QkQsS0FBa0IsQ0FBRTtJQUN6RCxNQUFNMWIsSUFBNkI7SUFDbkMsTUFBTTRiLElBQTZDO0lBQ25ELE1BQU1DLElBQTJDO0lBQ2pELE1BQU1DLElBQXlCQyw2QkFHN0I7UUFBQ25IO1FBQVNFO1FBQU9oVDtLQUFBQSxFQUNqQixJQUFPRixLQUFxQndULElBQVVSLElBQVVFLEdBQ2hEeUcsR0FDQUk7SUFHRixNQUFNSyxxQkFBc0JDLENBQUFBO1FBQzFCLElBQUl4NUIsR0FBUztZQUNYLElBQUl5NUIsSUFBa0M7WUFDdEMsSUFBSUMsSUFBbUM7WUFDdkMsTUFBTUMsSUFBVyxJQUFJMzVCLEVBQVE7Z0JBQzNCeUMsUUFBUTh2QjtnQkFDUmlILE1BQUFBOztZQUVGLE1BQU1JLGtCQUFrQkE7Z0JBQ3RCLElBQUlILEdBQUFBO29CQUNGQSxFQUFjdlEsTUFBQUE7O2dCQUVoQnVRLElBQWdCO1lBQUk7WUFFdEIsTUFBTUksNkJBQThCQyxDQUFBQTtnQkFDbEMsUUFBTUMsSUFBRUMsQ0FBQUEsRUFBQUEsR0FBdUJqYjtnQkFDL0IsTUFBTWtiLElBQ0p6akIsb0NBQW9Dd2pCLEVBQUFBLENBQW9CUixFQUFBQTtnQkFDMUQsTUFBTXpuQixJQUFleW5CLE1BQVM7Z0JBQzlCLE1BQU1VLElBQWlCO29CQUNyQnBvQiwwQkFBMEIsR0FBR0M7b0JBQzdCRCwwQkFBMEIscUJBQTBDLE9BQXJCQyxJQUFlLE1BQU0sV0FBUUE7aUJBQUFBO2dCQUU5RSxNQUFNb29CLElBQVlGLElBQXlCQyxJQUFpQkEsRUFBZUUsT0FBQUE7Z0JBRzNFLElBQ0VWLENBQUFBLENBQXVCLE9BQU9TLENBQUFBLENBQVUsTUFDeENULENBQUFBLENBQXVCLE9BQU9TLENBQUFBLENBQVU7b0JBRXhDLE9BQU9QOztnQkFHVEYsSUFBeUJTO2dCQUV6QlA7Z0JBQ0FILElBQWdCSyxFQUFVTyxFQUFBQSxDQUFRQyxPQUFBQSxDQUNoQztvQkFFRTF6QixPQUFPO3dCQUFDO3FCQUFBO29CQUdSdXpCLFdBQUFBO21CQUdGO29CQUNFUixVQUFBQTs7Z0JBSUosT0FBT0M7WUFBZTtZQUd4QixPQUFPO2dCQUNMQyxJQUFBQTs7UUFFSjtJQUFBO0lBRUYsTUFBTVUsSUFBaUI7UUFDckJ2b0IsR0FBR3VuQixtQkFBbUI7UUFDdEJ0bkIsR0FBR3NuQixtQkFBbUI7O0lBRXhCLE1BQU1pQixxQkFBcUJBO1FBQ3pCLFFBQU1DLElBQUVDLENBQUFBLEVBQWVDLElBQUVDLENBQUFBLEVBQUFBLEdBQWtCN2I7UUFDM0MsTUFBTThiLGVBQWVBLENBQUNDLEdBQTBCQyxJQUM5Q2h4QixVQUFVLEdBQUcsR0FBRyt3QixJQUFvQkEsQ0FBQUEsSUFBbUJDLENBQUFBLEtBQXVCO1FBRWhGLE9BQU87WUFDTC9vQixHQUFHNm9CLGFBQWFELEVBQWM1b0IsQ0FBQUEsRUFBRzBvQixFQUFnQjFvQixDQUFBQTtZQUNqREMsR0FBRzRvQixhQUFhRCxFQUFjM29CLENBQUFBLEVBQUd5b0IsRUFBZ0J6b0IsQ0FBQUE7O0lBQ2xEO0lBRUgsTUFBTStvQixtQ0FBbUNBLENBQ3ZDQyxHQUNBaHNCLEdBQ0EzQztRQUVBLE1BQU00dUIsSUFBUzV1QixJQUFNSyxXQUFXRjtRQUNoQ2pLLEtBQUt5NEIsR0FBc0JFLENBQUFBO1lBQ3pCRCxFQUFPQyxFQUFtQkMsRUFBQUEsRUFBWW5zQjtRQUFXO0lBQ2pEO0lBRUosTUFBTW9zQixpQkFBaUJBLENBQ3JCSixHQUNBeHFCO1FBRUFqTyxLQUFLeTRCLEdBQXNCRSxDQUFBQTtZQUN6QixPQUFPNXdCLEdBQUtnRyxFQUFBQSxHQUFVRSxFQUFTMHFCO1lBQy9CN3FCLFVBQVUvRixHQUFLZ0c7UUFBTztJQUN0QjtJQUVKLE1BQU0rcUIsMkJBQTJCQSxDQUMvQjV1QixHQUNBSixHQUNBaXZCO1FBRUEsTUFBTUMsSUFBYWw3QixVQUFVaTdCO1FBQzdCLE1BQU1FLElBQWdCRCxJQUFhRCxJQUFpQjtRQUNwRCxNQUFNRyxJQUFjRixJQUFBQSxDQUFjRCxJQUFpQjtRQUNuRCxJQUFJRSxHQUFBQTtZQUNGVCxpQ0FBaUM3QixHQUFzQnpzQixHQUFXSjs7UUFFcEUsSUFBSW92QixHQUFBQTtZQUNGVixpQ0FBaUM1QixHQUFvQjFzQixHQUFXSjs7SUFDbEU7SUFFRixNQUFNcXZCLGdDQUFnQ0E7UUFDcEMsTUFBTUMsSUFBa0JwQjtRQUN4QixNQUFNcUIseUJBQ0hDLENBQUFBLElBQ0FoQyxDQUFBQSxJQUFrQztvQkFDakNBLEVBQVVzQixFQUFBQTtvQkFDVjt3QkFDRTFDLENBQUNBLEVBQUFBLEVBQStCdG9CLGVBQWUwckIsS0FBdUI7OztRQUk1RVQsZUFBZWxDLEdBQXNCMEMsdUJBQXVCRCxFQUFnQjVwQixDQUFBQTtRQUM1RXFwQixlQUFlakMsR0FBb0J5Qyx1QkFBdUJELEVBQWdCM3BCLENBQUFBO0lBQUc7SUFFL0UsTUFBTThwQixnQ0FBZ0NBO1FBQ3BDLEtBQUsvN0IsR0FBUztZQUNaLFFBQU0rNUIsSUFBRUMsQ0FBQUEsRUFBQUEsR0FBdUJqYjtZQUMvQixNQUFNaWQsSUFBZ0J0bEIsNEJBQ3BCc2pCLEdBQ0E3a0IsaUJBQWlCb2Q7WUFFbkIsTUFBTXNKLHlCQUNISSxDQUFBQSxJQUNBbkMsQ0FBQUEsSUFBa0M7d0JBQ2pDQSxFQUFVc0IsRUFBQUE7d0JBQ1Y7NEJBQ0V6QyxDQUFDQSxFQUFBQSxFQUE2QnZvQixlQUFlNnJCLEtBQXFCOzs7WUFJeEVaLGVBQWVsQyxHQUFzQjBDLHVCQUF1QkcsRUFBY2hxQixDQUFBQTtZQUMxRXFwQixlQUFlakMsR0FBb0J5Qyx1QkFBdUJHLEVBQWMvcEIsQ0FBQUE7UUFDMUU7SUFBQTtJQUVGLE1BQU1pcUIscUNBQXFDQTtRQUN6QyxRQUFNbkMsSUFBRUMsQ0FBQUEsRUFBQUEsR0FBdUJqYjtRQUMvQixNQUFNa2IsSUFBeUJ6akIsb0NBQW9Dd2pCO1FBQ25FLE1BQU02Qix5QkFDSE0sQ0FBQUEsSUFDQXJDLENBQUFBLElBQWtDO29CQUNqQ0EsRUFBVXNCLEVBQUFBO29CQUNWO3dCQUNFeEMsQ0FBQ0EsRUFBQUEsRUFBK0J1RCxJQUEwQyxNQUFNOzs7UUFJdEZkLGVBQWVsQyxHQUFzQjBDLHVCQUF1QjVCLEVBQXVCam9CLENBQUFBO1FBQ25GcXBCLGVBQWVqQyxHQUFvQnlDLHVCQUF1QjVCLEVBQXVCaG9CLENBQUFBO1FBR2pGLElBQUlqUyxHQUFTO1lBQ1htNUIsRUFBcUJ4aEIsT0FBQUEsQ0FBUTRpQixFQUFldm9CLENBQUFBLENBQUc2bkIsRUFBQUE7WUFDL0NULEVBQW1CemhCLE9BQUFBLENBQVE0aUIsRUFBZXRvQixDQUFBQSxDQUFHNG5CLEVBQUFBO1FBQy9DO0lBQUE7SUFFRixNQUFNdUMsbUNBQW1DQTtRQUN2QyxJQUFJamQsS0FBQUEsQ0FBc0J3VCxHQUFTO1lBQ2pDLFFBQU04SCxJQUFFQyxDQUFBQSxFQUFlWCxJQUFFQyxDQUFBQSxFQUFBQSxHQUF1QmpiO1lBQ2hELE1BQU1zZCxJQUEyQjdsQixvQ0FBb0N3akI7WUFDckUsTUFBTWdDLElBQWdCdGxCLDRCQUNwQnNqQixHQUNBN2tCLGlCQUFpQm9kO1lBRW5CLE1BQU0rSix5QkFBNEN4QyxDQUFBQTtnQkFDaEQsUUFBTXlDLElBQUVuQixDQUFBQSxFQUFBQSxHQUFldEI7Z0JBQ3ZCLE1BQU12dkIsSUFBTWdELE9BQU82dEIsT0FBZ0IvYixLQUFhK2I7Z0JBQ2hELE1BQU1vQixvQkFBb0JBLENBQ3hCUCxHQUNBbEIsR0FDQTBCO29CQUVBLE1BQU1DLElBQUszQixJQUFxQmtCO29CQUNoQyxPQUFPNXJCLGNBQWNvc0IsSUFBMkJDLElBQUFBLENBQU1BO2dCQUFHO2dCQUczRCxPQUFPO29CQUNMbnlCO29CQUNBQSxLQUFPO3dCQUNMNHZCLFdBQVdyb0IsMEJBQTBCOzRCQUNuQ0UsR0FBR3dxQixrQkFBa0JSLEVBQWNocUIsQ0FBQUEsRUFBRzBvQixFQUFnQjFvQixDQUFBQSxFQUFHcXFCLEVBQXlCcnFCLENBQUFBOzRCQUNsRkMsR0FBR3VxQixrQkFBa0JSLEVBQWMvcEIsQ0FBQUEsRUFBR3lvQixFQUFnQnpvQixDQUFBQSxFQUFHb3FCLEVBQXlCcHFCLENBQUFBOzs7O1lBR3ZGO1lBR0hvcEIsZUFBZWxDLEdBQXNCbUQ7WUFDckNqQixlQUFlakMsR0FBb0JrRDtRQUNyQztJQUFBO0lBRUYsTUFBTUssdUJBQXdCNXFCLENBQUFBO1FBQzVCLE1BQU02cUIsSUFBUTdxQixJQUFlLE1BQU07UUFDbkMsTUFBTThxQixJQUFxQjlxQixJQUN2Qm9KLEtBQ0FDO1FBQ0osTUFBTTBoQixJQUFZOXRCLFVBQVUsR0FBeUI2dEIsT0FBdEI1aEIsSUFBQUEsS0FBc0I0aEIsT0FBQUE7UUFDckQsTUFBTUUsSUFBUS90QixVQUFVcU07UUFDeEIsTUFBTTJoQixJQUFTaHVCLFVBQVVzTTtRQUN6QixNQUFNM1YsSUFBUztZQUNieTFCLElBQVkwQjtZQUNaRyxJQUFRRjtZQUNSMUMsSUFBUzJDOztRQUVYLE1BQU1yRCxJQUFXWSxDQUFBQSxDQUFlcUMsRUFBQUE7UUFFaEN4NUIsS0FBSzJPLElBQWVvbkIsSUFBdUJDLEdBQW9CenpCO1FBQy9EdkMsS0FBS21hLEdBQVk7WUFDZi9PLGVBQWVzdUIsR0FBV0M7WUFDMUJ2dUIsZUFBZXV1QixHQUFPQztZQUN0QjkyQixLQUFLaUksZ0JBQWdCMnVCO1lBQ3JCbkQsS0FBWUEsRUFBU0UsRUFBQUEsQ0FBMkJsMEI7WUFDaEQ4eUIsRUFBc0I5eUIsR0FBUTIxQiwwQkFBMEJ2cEI7U0FBQUE7UUFHMUQsT0FBT3BNO0lBQU07SUFFZixNQUFNdTNCLElBQXVDaDNCLEtBQUt5MkIsc0JBQXNCO0lBQ3hFLE1BQU1RLElBQXFDajNCLEtBQUt5MkIsc0JBQXNCO0lBQ3RFLE1BQU1TLGlCQUFpQkE7UUFDckI1dUIsZUFBZTZxQixHQUF3QkYsQ0FBQUEsQ0FBcUIsR0FBR2lDLEVBQUFBO1FBQy9ENXNCLGVBQWU2cUIsR0FBd0JELENBQUFBLENBQW1CLEdBQUdnQyxFQUFBQTtRQUU3RCxPQUFPbDFCLEtBQUtuQyxpQkFBaUJ3WjtJQUFXO0lBRzFDMmY7SUFDQUM7SUFFQSxPQUFPO1FBQ0w7WUFDRUUsSUFBZ0MxQjtZQUNoQzJCLElBQWdDdkI7WUFDaEN3QixJQUFxQ3JCO1lBQ3JDc0IsSUFBbUNwQjtZQUNuQ3FCLElBQTJCbkM7WUFDM0JvQyxJQUFhO2dCQUNYQyxJQUFzQnhFO2dCQUN0QnlFLElBQVFWO2dCQUNSVyxJQUFRMzNCLEtBQUttMUIsZ0JBQWdCbEM7O1lBRS9CMkUsSUFBVztnQkFDVEgsSUFBc0J2RTtnQkFDdEJ3RSxJQUFRVDtnQkFDUlUsSUFBUTMzQixLQUFLbTFCLGdCQUFnQmpDOzs7UUFHakNnRTtLQUFBQTtBQUNEO0FDcFVJLE1BQU1XLDhCQUE4QkEsQ0FDekMvZ0MsR0FDQThoQixHQUNBQyxHQUNBaWYsSUFFTyxDQUFDN0MsR0FBb0JHLEdBQTBCdnBCO1FBQ3BELFFBQU1xZ0IsSUFDSkMsQ0FBQUEsRUFBS2pULEdBQ0xDLENBQUFBLEVBQVNILEdBQ1RDLENBQUFBLEVBQWlCbVQsSUFDakJDLENBQUFBLEVBQW9CMEwsSUFDcEJDLENBQUFBLEVBQVlsTCxJQUNaQyxDQUFBQSxFQUFBQSxHQUNFblU7UUFDSixRQUFNeWQsSUFBRW5CLENBQUFBLEVBQVUrQyxJQUFFbEIsQ0FBQUEsRUFBTW1CLElBQUUvRCxDQUFBQSxFQUFBQSxHQUFZYztRQUN4QyxPQUFPa0QsR0FBY0MsRUFBQUEsR0FBcUJuNEIsaUJBQWlCO1FBQzNELE9BQU9vNEIsR0FBbUNDLEVBQUFBLEdBQ3hDcjRCLGlCQUFpQjtRQUNuQixNQUFNczRCLDhCQUErQkMsQ0FBQUE7WUFDbkMsSUFBSW4rQixXQUFXZ3lCLEVBQXFCb00sUUFBQUEsR0FBQUE7Z0JBQ2xDcE0sRUFBcUJvTSxRQUFBQSxDQUFTO29CQUM1QkMsVUFBVTtvQkFDVmx0QixNQUFNZ3RCLEVBQVkxc0IsQ0FBQUE7b0JBQ2xCVCxLQUFLbXRCLEVBQVl6c0IsQ0FBQUE7OztRQUVyQjtRQUdGLE1BQU00c0IsZ0NBQWdDQTtZQUNwQyxNQUFNQyxJQUE4QjtZQUNwQyxNQUFNQyxJQUFjLFNBQThCLE9BQXJCaHRCLElBQWUsTUFBTTtZQUNsRCxNQUFNaXRCLElBQWlCanRCLElBQWVsTixJQUFXQztZQUNqRCxNQUFNbTZCLElBQWFsdEIsSUFBZSxTQUFTO1lBQzNDLE1BQU1tdEIsSUFBUW50QixJQUFlLE1BQU07WUFDbkMsTUFBTTZxQixJQUFRN3FCLElBQWUsTUFBTTtZQUVuQyxNQUFNb3RCLDJCQUNKQSxDQUFDQyxHQUF5QkMsSUFBMkJDLENBQUFBO29CQUNuRCxRQUFNN0UsSUFBRUMsQ0FBQUEsRUFBQUEsR0FBb0IzYjtvQkFDNUIsTUFBTXdnQixJQUFrQjFzQixFQUFjb3FCLEVBQUFBLENBQVFpQyxFQUFBQSxHQUFTcnNCLEVBQWN3bkIsRUFBQUEsQ0FBUzZFLEVBQUFBO29CQUM5RSxNQUFNTSxJQUFzQkgsSUFBZ0JDLElBQWlCQztvQkFDN0QsTUFBTUUsSUFBY0QsSUFBcUI5RSxDQUFBQSxDQUFnQmtDLEVBQUFBO29CQUV6RDduQixnQkFBZ0J3ZCxHQUFzQjt3QkFDcENxSyxDQUFDQSxFQUFBQSxFQUFRd0MsSUFBa0JLOztnQkFDM0I7WUFFTixNQUFNQyxJQUEyQztZQUVqRCxPQUFPenJCLGlCQUFpQmdwQixHQUFRLGVBQWdCMEMsQ0FBQUE7Z0JBQzlDLE1BQU1DLElBQ0pueUIsUUFBUWt5QixFQUFpQjcyQixNQUFBQSxFQUFnQixJQUFJd1MsT0FBQUEsU0FBZ0MrZTtnQkFDL0UsTUFBTXdGLElBQXdCRCxJQUFldkYsSUFBVTRDO2dCQUV2RCxNQUFNNkMsSUFBbUI5aUMsRUFBUTZvQixVQUFBQTtnQkFDakMsTUFBTWthLElBQXdCRCxDQUFBQSxDQUFpQkYsSUFBZSxlQUFlO2dCQUM3RSxRQUFNSSxRQUFFQSxDQUFBQSxFQUFNQyxXQUFFQSxDQUFBQSxFQUFTQyxhQUFFQSxDQUFBQSxFQUFBQSxHQUFnQlA7Z0JBQzNDLFFBQU10WixVQUFFQSxDQUFBQSxFQUFBQSxHQUFheVo7Z0JBRXJCLE1BQU1LLElBQ0pILE1BQVcsS0FDWEMsS0FDQUYsS0FBQUEsQ0FDQzFaLEtBQVksSUFBSW5hLFFBQUFBLENBQVNnMEI7Z0JBRTVCLElBQUlDLEdBQXFCO29CQUN2QnA4QixnQkFBZ0IyN0I7b0JBQ2hCbEI7b0JBRUEsTUFBTTRCLElBQUFBLENBQ0hSLEtBQWlCRCxDQUFBQSxFQUFpQlUsUUFBQUEsSUFBWU4sTUFBMEI7b0JBQzNFLE1BQU1PLElBQWdCcDZCLEtBQUtpTix1QkFBdUJrbkI7b0JBQ2xELE1BQU1rRyxJQUFlcjZCLEtBQUtpTix1QkFBdUI4cEI7b0JBQ2pELE1BQU11RCxrQkFBa0JBLENBQUNDLEdBQXNCQyxJQUFBQSxDQUM1Q0QsS0FBY0gsR0FBQUEsQ0FBQUEsQ0FBaUJyQixFQUFBQSxHQUFBQSxDQUFleUIsS0FBYUgsR0FBQUEsQ0FBQUEsQ0FBZ0J0QixFQUFBQTtvQkFDOUUsTUFBTTBCLElBQ0ovaEMsRUFBVXVVLHNCQUFzQm9mLEVBQUFBLENBQXNCeU0sRUFBQUEsSUFDcERuc0IsRUFBYzBmLEVBQUFBLENBQXNCMk0sRUFBQUEsSUFBVTtvQkFDbEQsTUFBTWhjLElBQXFCaWMseUJBQ3pCaHFCLGlCQUFpQm9kLEVBQUFBLENBQXNCcUssRUFBQUEsRUFDdkMsSUFBSStEO29CQUVOLE1BQU1DLElBQW9CakIsQ0FBQUEsQ0FBaUJaLEVBQUFBO29CQUMzQyxNQUFNMEIsSUFBYUg7b0JBQ25CLE1BQU1JLElBQVlIO29CQUNsQixNQUFNbmQsSUFBZXFkLENBQUFBLENBQVd6QixFQUFBQTtvQkFDaEMsTUFBTTZCLElBQWVMLGdCQUFnQkMsR0FBWUMsS0FBYXRkLElBQWU7b0JBQzdFLE1BQU0wZCxJQUE2QkYsSUFBb0JGLENBQUFBLENBQVV6QixFQUFBQTtvQkFDakUsTUFBTThCLElBQWNuQixJQUFlLElBQUlrQixJQUE2QkQ7b0JBQ3BFLE1BQU1HLHdCQUF5QkMsQ0FBQUE7d0JBQzdCbDlCLGdCQUFnQm05Qjt3QkFDaEJyQixFQUFzQm1CLHFCQUFBQSxDQUFzQkMsRUFBZUUsU0FBQUE7b0JBQVU7b0JBRXZFLE1BQU1DLElBQW9CeEIsS0FBZ0JRO29CQUMxQyxNQUFNN0wsSUFBOEJ0QjtvQkFFcEMsTUFBTWlPLElBQXNCO3dCQUMxQmp0QixpQkFBaUJpcUIsR0FBY1ksR0FBNkJrQzt3QkFDNUQvc0IsaUJBQWlCaXFCLEdBQWMsZUFBZ0I5bEIsQ0FBQUEsSUFBaUJ2RCxlQUFldUQsSUFBUTs0QkFDckZoRSxHQUFVOzt3QkFFWkgsaUJBQWlCZ3BCLEdBQVE2QixHQUE2QmtDO3dCQUN0REksS0FDRW50QixpQkFBaUJncEIsR0FBUSxlQUFnQm9FLENBQUFBLElBQ3ZDbmUsRUFDRTZkLElBQWVNLENBQUFBLENBQUFBLENBQWlCdEMsRUFBQUEsR0FBZTZCLENBQUFBO3dCQUdyRFEsS0FBQUEsQ0FBQUE7NEJBRUksTUFBTUUsSUFBMEJuc0IsaUJBQWlCb2Q7NEJBQ2pEZ0M7NEJBQ0EsTUFBTWdOLElBQXVCcHNCLGlCQUFpQm9kOzRCQUM5QyxNQUFNaVAsSUFBaUI7Z0NBQ3JCeHZCLEdBQUd1dkIsRUFBcUJ2dkIsQ0FBQUEsR0FBSXN2QixFQUF3QnR2QixDQUFBQTtnQ0FDcERDLEdBQUdzdkIsRUFBcUJ0dkIsQ0FBQUEsR0FBSXF2QixFQUF3QnJ2QixDQUFBQTs7NEJBR3RELElBQUluVCxFQUFRMGlDLEVBQWV4dkIsQ0FBQUEsSUFBSyxLQUFLbFQsRUFBUTBpQyxFQUFldnZCLENBQUFBLElBQUssR0FBRztnQ0FDbEVnaEI7Z0NBQ0FsZSxnQkFBZ0J3ZCxHQUFzQitPO2dDQUN0QzdDLDRCQUE0QitDO2dDQUM1QmpELEVBQWtDaEs7NEJBQ3BDO3dCQUNEO3FCQUFBO29CQUdMc0wsRUFBc0I0QixpQkFBQUEsQ0FBa0I5QixFQUFpQndCLFNBQUFBO29CQUV6RCxJQUFJZixHQUFBQTt3QkFDRmxkLEVBQW1CNmQ7MkJBQ2QsS0FBS25CLEdBQWM7d0JBQ3hCLE1BQU04QixJQUFxQnRvQiw4QkFDekI0Sjt3QkFFRixJQUFJMGUsR0FBb0I7NEJBQ3RCLE1BQU1DLElBQTJCRCxFQUMvQnhlLEdBQ0E2ZCxHQUNBM2QsR0FDQ0UsQ0FBQUE7Z0NBRUMsSUFBSUEsR0FBQUE7b0NBQ0ZpUjs7b0NBRUFueEIsS0FBSzg5QixHQUFxQjNNOzs0QkFDNUI7NEJBSUpueEIsS0FBSzg5QixHQUFxQlM7NEJBQzFCditCLEtBQUtzOEIsR0FBdUJ4NUIsS0FBS3k3QixHQUEwQjt3QkFDN0Q7b0JBQ0Y7Z0JBQ0Y7WUFBQTtRQUNBO1FBR0osSUFBSUMsSUFBZ0I7UUFFcEIsT0FBTzE3QixLQUFLbkMsaUJBQWlCO1lBQzNCa1EsaUJBQWlCb21CLEdBQVMsNEJBQTRCMkQ7WUFDdEQvcEIsaUJBQWlCbW5CLEdBQVksZ0JBQWdCO2dCQUMzQ0UsRUFBeUI3ZixJQUErQjtZQUFLO1lBRS9EeEgsaUJBQWlCbW5CLEdBQVksOEJBQThCO2dCQUN6REUsRUFBeUI3ZixJQUErQjtZQUFNO1lBQUEsQ0FHL0QwRCxLQUNDbEwsaUJBQWlCbW5CLEdBQVksYUFBYTtnQkFDeEMsTUFBTXlHLElBQWlCbjBCO2dCQUV2QixJQUNFaEQsUUFBUW0zQixHQUFnQjluQixNQUN4QnJQLFFBQVFtM0IsR0FBZ0Job0IsTUFDeEJnb0IsTUFBbUJ4akMsU0FBU3FwQixJQUFBQSxFQUFBQTtvQkFFNUJwb0IsRUFBSzRHLEtBQUsyUSxjQUFjd0ksSUFBWTs7WUFDdEM7WUFHSnBMLGlCQUNFbW5CLEdBQ0EsU0FDQzBHLENBQUFBO2dCQUNDLFFBQU1DLFFBQUVBLENBQUFBLEVBQU1DLFFBQUVBLENBQUFBLEVBQU1DLFdBQUVBLENBQUFBLEVBQUFBLEdBQWNIO2dCQUd0QyxJQUFJRixLQUFpQkssTUFBYyxLQUFLMTBCLE9BQU82dEIsT0FBZ0IvSSxHQUFBQTtvQkFDN0RvTSw0QkFBNEI7d0JBQzFCenNCLEdBQUcrdkI7d0JBQ0g5dkIsR0FBRyt2Qjs7O2dCQUlQSixJQUFnQjtnQkFDaEJ0RyxFQUF5QnpmLElBQXlCO2dCQUNsRHdpQixFQUFhO29CQUNYdUQsSUFBZ0I7b0JBQ2hCdEcsRUFBeUJ6ZjtnQkFBd0I7Z0JBR25EaEgsZUFBZWl0QjtZQUFXLEdBRTVCO2dCQUFFMXRCLEdBQVU7Z0JBQU9DLEdBQVU7O1lBSy9CSixpQkFDRW1uQixHQUNBLGVBQ0E7Z0JBQ0UsTUFBTThHLElBQW1CanVCLGlCQUN2QmlxQixHQUNBLFNBQ0NpRSxDQUFBQTtvQkFDQ0M7b0JBQ0F0dEIsZUFBZXF0QjtnQkFBVyxHQUU1QjtvQkFDRTV0QixHQUFPO29CQUNQRixHQUFVO29CQUNWRCxHQUFVOztnQkFHZCxNQUFNZ3VCLElBQXNCbnVCLGlCQUMxQmlxQixHQUNBLDJCQUNBO29CQUNFa0U7b0JBQ0E3aUMsV0FBVzJpQyxHQUFrQjtnQkFBSSxHQUVuQztvQkFDRTd0QixHQUFVO29CQUNWRCxHQUFVOztZQUViLEdBRUg7Z0JBQUVDLEdBQVU7Z0JBQU1ELEdBQVU7O1lBRTlCeXFCO1lBQ0FQO1lBQ0FFO1NBQUFBO0lBQ0E7QUMxT0MsTUFBTTZELHdCQUF3QkEsQ0FDbkN2NUIsR0FDQTlMLEdBQ0FnaUIsR0FDQUQsR0FDQUQsR0FDQXpCO0lBRUEsSUFBSWlsQjtJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUMsSUFBeUM3NEI7SUFDN0MsSUFBSTg0QixJQUF3QjtJQUM1QixNQUFNQyxJQUF3QjtRQUFDO1FBQVM7S0FBQTtJQUd4QyxNQUFNQyx5QkFBMEIxcUIsQ0FBQUEsSUFDOUJ5cUIsRUFBc0IzMkIsUUFBQUEsQ0FBU2tNLEVBQU04bkIsV0FBQUE7SUFFdkMsT0FBTzZDLEdBQTZCQyxFQUFBQSxHQUE4Qjc4QjtJQUNsRSxPQUFPODhCLEdBQW1DQyxFQUFBQSxHQUN4Qy84QixpQkFBaUI7SUFDbkIsT0FBT2c5QixHQUF3QkMsRUFBQUEsR0FBK0JqOUIsaUJBQWlCO0lBQy9FLE9BQU9rOUIsR0FBaUJDLEVBQUFBLEdBQXdCbjlCLGlCQUFpQixJQUFNeThCO0lBQ3ZFLE9BQU9oYSxHQUFVd1UsRUFBQUEsR0FBa0I1RSw4QkFDakMxdkIsR0FDQWdXLEdBQ0FDLEdBQ0FnZiw0QkFDRS9nQyxHQUNBOGhCLEdBQ0FDLEdBQ0MzRyxDQUFBQSxJQUFVMHFCLHVCQUF1QjFxQixNQUFVbXJCO0lBR2hELFFBQU1uUixJQUFFQyxDQUFBQSxFQUFLbVIsSUFBRUMsQ0FBQUEsRUFBbUIvUSxJQUFFQyxDQUFBQSxFQUFBQSxHQUFZN1Q7SUFDaEQsUUFBTTRrQixJQUNKakcsQ0FBQUEsRUFBeUJrRyxJQUN6QnRHLENBQUFBLEVBQThCdUcsSUFDOUJ0RyxDQUFBQSxFQUE4QnVHLElBQzlCdEcsQ0FBQUEsRUFBbUN1RyxJQUNuQ3RHLENBQUFBLEVBQUFBLEdBQ0U1VTtJQUNKLE1BQU1tYiwyQkFBMkJBLENBQUNDLEdBQXlCQztRQUN6RFg7UUFDQSxJQUFJVSxHQUFBQTtZQUNGdkcsRUFBMEI3aEI7ZUFDckI7WUFDTCxNQUFNc29CLElBQU9oK0IsS0FBS3UzQixHQUEyQjdoQixJQUFrQztZQUMvRSxJQUFJZ25CLElBQXdCLE1BQU1xQixHQUFBQTtnQkFDaENaLEVBQWdCYTs7Z0JBRWhCQTs7UUFFSjtJQUFBO0lBRUYsTUFBTVgsNkNBQTZDQTtRQUNqRCxJQUFJZixJQUFBQSxDQUFtQkYsSUFBQUEsQ0FBZUcsR0FBaUI7WUFDckRzQix5QkFBeUI7WUFDekJkLEVBQWtDO2dCQUNoQ2MseUJBQXlCO1lBQU07UUFFbkM7SUFBQTtJQUVGLE1BQU1JLDJCQUE0QjczQixDQUFBQTtRQUNoQ214QixFQUEwQjloQixJQUE0QnJQLEdBQUs7UUFDM0RteEIsRUFBMEI5aEIsSUFBNEJyUCxHQUFLO0lBQU07SUFFbkUsTUFBTTgzQixtQkFBb0Joc0IsQ0FBQUE7UUFDeEIsSUFBSTBxQix1QkFBdUIxcUIsSUFBUTtZQUNqQ2txQixJQUFjRTtZQUNkLElBQUlBLEdBQUFBO2dCQUNGdUIseUJBQXlCOztRQUU3QjtJQUFBO0lBRUYsTUFBTXhtQixJQUE2QjtRQUNqQytsQjtRQUNBSjtRQUNBRTtRQUNBSjtRQUNBLElBQU1MO1FBRU4xdUIsaUJBQWlCb2UsR0FBTyxlQUFlK1Isa0JBQWtCO1lBQUU3dkIsR0FBTzs7UUFDbEVOLGlCQUFpQm9lLEdBQU8sZ0JBQWdCK1I7UUFDeENud0IsaUJBQWlCb2UsR0FBTyxnQkFBaUJqYSxDQUFBQTtZQUN2QyxJQUFJMHFCLHVCQUF1QjFxQixJQUFRO2dCQUNqQ2txQixJQUFjO2dCQUNkLElBQUlFLEdBQUFBO29CQUNGdUIseUJBQXlCOztZQUU3QjtRQUFBO1FBRUY5dkIsaUJBQWlCb2UsR0FBTyxlQUFnQmphLENBQUFBO1lBQ3RDLElBQUkwcUIsdUJBQXVCMXFCLE1BQVVtcUIsR0FBQUE7Z0JBQ25DZ0I7O1FBQ0Y7UUFFRnR2QixpQkFBaUJ3dkIsR0FBcUIsVUFBV3JyQixDQUFBQTtZQUMvQzJxQixFQUE0QjtnQkFDMUJ6RjtnQkFDQWlHO1lBQTRDO1lBRzlDbG1CLEVBQVNqRjtZQUVUb2xCO1FBQW1DO0tBQUE7SUFHdkMsTUFBTXhKLElBQXlCNWEsOEJBQzdCdUY7SUFHRixPQUFPO1FBQ0wsSUFBTXpZLEtBQUtuQyxpQkFBaUJYLEtBQUttYSxHQUFZNmY7UUFDN0M7Z0JBQUEsRUFBR2hILElBQUFBLENBQUFBLEVBQWNFLElBQUFBLENBQUFBLEVBQVErTixJQUFBQSxDQUFBQSxFQUF1QkMsSUFBQUEsQ0FBQUEsRUFBQUE7WUFDOUMsUUFBTUMsSUFDSkMsQ0FBQUEsRUFBb0JDLElBQ3BCQyxDQUFBQSxFQUFzQkMsSUFDdEJDLENBQUFBLEVBQXFCQyxJQUNyQkMsQ0FBQUEsRUFBQUEsR0FDRVIsS0FBeUIsQ0FBRTtZQUMvQixRQUFNUyxJQUFFaFEsQ0FBQUEsRUFBaUJpUSxJQUFFbFcsQ0FBQUEsRUFBQUEsR0FBWXVWLEtBQXlCLENBQUU7WUFDbEUsUUFBTXhqQixHQUFFQyxDQUFBQSxFQUFBQSxHQUFvQjlCO1lBQzVCLFFBQU1yQixHQUFFQyxDQUFBQSxFQUF5QjBCLEdBQUVDLENBQUFBLEVBQUFBLEdBQTRCZ0w7WUFDL0QsUUFBTTBhLElBQUVDLENBQUFBLEVBQWN6aUIsR0FBRUMsQ0FBQUEsRUFBQUEsR0FBaUIzRDtZQUN6QyxPQUFPbEIsR0FBb0NDLEVBQUFBLEdBQ3pDc1ksRUFBYTtZQUNmLE9BQU90USxHQUFPcWYsRUFBQUEsR0FBZ0IvTyxFQUFhO1lBQzNDLE9BQU9yUSxHQUFZcWYsRUFBQUEsR0FBcUJoUCxFQUFhO1lBQ3JELE9BQU9wUSxHQUFVcWYsRUFBQUEsR0FBbUJqUCxFQUFhO1lBQ2pELE9BQU9sUSxHQUFpQm9mLEVBQUFBLEdBQTBCbFAsRUFBYTtZQUMvRCxPQUFPblEsRUFBQUEsR0FBaUJtUSxFQUFhO1lBQ3JDLE9BQU9qUSxHQUFZb2YsRUFBQUEsR0FBcUJuUCxFQUFhO1lBQ3JELE9BQU9oUSxHQUFhb2YsRUFBQUEsR0FBc0JwUCxFQUFhO1lBQ3ZELE9BQU9wWSxHQUFVeW5CLEVBQUFBLEdBQW1CclAsRUFBYTtZQUNqRCxNQUFNc1AsSUFBZ0I1VyxLQUFBQSxDQUFZd0g7WUFDbEMsTUFBTWhZLElBQWNvRSxFQUFhMVEsQ0FBQUEsSUFBSzBRLEVBQWF6USxDQUFBQTtZQUNuRCxNQUFNMHpCLElBQ0puQixLQUNBRSxLQUNBSSxLQUNBL1AsS0FDQXVCO1lBQ0YsTUFBTXNQLEtBQW1CaEIsS0FBeUJRLEtBQXFCSztZQUN2RSxNQUFNOWxCLEtBQ0o5QixLQUNBRCxFQUEwQjVMLENBQUFBLElBQzFCNEwsRUFBMEIzTCxDQUFBQTtZQUM1QixNQUFNNHpCLEtBQUFBLENBQXNCdG1CLEtBQUFBLENBQTRCeVU7WUFDeEQsTUFBTThSLEtBQXVCbm1CLE1BQWdDa21CO1lBRTdELE1BQU1FLHlCQUF5QkEsQ0FDN0I3bkIsR0FDQThuQixHQUNBajBCO2dCQUVBLE1BQU1rMEIsSUFDSi9uQixFQUFpQmhTLFFBQUFBLENBQVNqSCxNQUN6QjhnQixDQUFBQSxNQUFlaGhCLEtBQWVnaEIsTUFBZSxVQUFVaWdCLE1BQWtCL2dDLENBQUFBO2dCQUU1RXc0QixFQUEwQmxpQixJQUEyQjBxQixHQUFXbDBCO2dCQUVoRSxPQUFPazBCO1lBQVM7WUFHbEJyRCxJQUF3QjNjO1lBRXhCLElBQUl5ZixHQUFBQTtnQkFDRixJQUFJeGYsS0FBbUI1SCxHQUFhO29CQUNsQzZsQix5QkFBeUI7b0JBQ3pCeEI7b0JBQ0FRLEVBQXVCO3dCQUNyQlIsSUFBeUMxdUIsaUJBQ3ZDd3ZCLEdBQ0EsVUFDQXY5QixLQUFLaStCLDBCQUEwQixPQUMvQjs0QkFDRTV2QixHQUFPOztvQkFFVjtnQkFFTDtvQkFDRTR2Qix5QkFBeUI7OztZQUk3QixJQUFJcm1CLEtBQXVDK25CLElBQUFBO2dCQUN6Q3BJLEVBQTBCemlCLElBQTZCOHFCOztZQUd6RCxJQUFJWCxHQUFjO2dCQUNoQjFILEVBQTBCaUY7Z0JBQzFCakYsRUFBMEIzWCxHQUFPO2dCQUVqQzRjLElBQVk1YztZQUNkO1lBRUEsSUFBSXdmLEtBQUFBLENBQTJCcGYsR0FBQUE7Z0JBQzdCaWUseUJBQXlCOztZQUczQixJQUFJa0IsR0FBaUI7Z0JBQ25COUMsSUFBaUJ2YyxNQUFhO2dCQUM5QndjLElBQWtCeGMsTUFBYTtnQkFDL0J5YyxJQUFrQnpjLE1BQWE7Z0JBQy9CK2QseUJBQXlCdEIsR0FBaUI7WUFDNUM7WUFFQSxJQUFJOEMsR0FBQUE7Z0JBQ0Y5SCxFQUEwQjFoQixJQUFxQ29LOztZQUdqRSxJQUFJcWYsR0FBQUE7Z0JBQ0YvSCxFQUEwQjNoQixJQUFBQSxDQUFBQSxDQUFzQ3NLOztZQUtsRSxJQUFJd2YsSUFBa0I7Z0JBQ3BCLE1BQU1NLElBQVdILHVCQUF1Qi9uQixFQUFTaE0sQ0FBQUEsRUFBR2t6QixFQUFlbHpCLENBQUFBLEVBQUc7Z0JBQ3RFLE1BQU1tMEIsSUFBV0osdUJBQXVCL25CLEVBQVMvTCxDQUFBQSxFQUFHaXpCLEVBQWVqekIsQ0FBQUEsRUFBRztnQkFDdEUsTUFBTW0wQixJQUFZRixLQUFZQztnQkFFOUIxSSxFQUEwQmppQixJQUFBQSxDQUErQjRxQjtZQUMzRDtZQUdBLElBQUlULEdBQWtCO2dCQUNwQnJJO2dCQUNBRDtnQkFDQUc7Z0JBQ0EsSUFBSXNILEdBQUFBO29CQUNGdkg7O2dCQUdGRSxFQUEwQi9oQixJQUFBQSxDQUE2QmdILEVBQWExUSxDQUFBQSxFQUFHO2dCQUN2RXlyQixFQUEwQi9oQixJQUFBQSxDQUE2QmdILEVBQWF6USxDQUFBQSxFQUFHO2dCQUN2RXdyQixFQUEwQnZpQixJQUF1QjRGLEtBQUFBLENBQW9CNlI7WUFDdkU7UUFBQTtRQUVGO1FBQ0EvSjtLQUFBQTtBQUNEO0FDaE9JLE1BQU15ZCwrQkFDWHY5QixDQUFBQTtJQUVBLE1BQU00VSxJQUFNNk07SUFDWixRQUFNME4sR0FBRXpPLENBQUFBLEVBQXlCbEssR0FBRUMsQ0FBQUEsRUFBQUEsR0FBNEI3QjtJQUMvRCxRQUFRa0wsVUFBVTBkLENBQUFBLEVBQUFBLEdBQXdCOWM7SUFDMUMsUUFDRVYsU0FBU3lkLENBQUFBLEVBQ1R4ZCxVQUFVeWQsQ0FBQUEsRUFDVnhkLFNBQVN5ZCxDQUFBQSxFQUFBQSxHQUNQSDtJQUNKLE1BQU1JLElBQWN6bEMsY0FBYzZIO0lBQ2xDLE1BQU02OUIsSUFBaUNELElBQWMsS0FBSzU5QjtJQUMxRCxRQUFROGYsVUFBVWdlLENBQUFBLEVBQUFBLEdBQWlCRDtJQUNuQyxRQUNFN2QsU0FBUytkLENBQUFBLEVBQ1Q5ZCxVQUFVK2QsQ0FBQUEsRUFDVjlkLFNBQVMrZCxDQUFBQSxFQUFBQSxHQUNQSCxLQUFnQixDQUFFO0lBRXRCLE1BQU1JLElBQWdCTixJQUFjNTlCLElBQVM2OUIsRUFBOEI3OUIsTUFBQUE7SUFDM0UsTUFBTWl2QixJQUFTM3FCLGNBQWM0NUI7SUFDN0IsTUFBTUMsSUFBZ0JELEVBQWNDLGFBQUFBO0lBQ3BDLE1BQU1DLElBQWFELEVBQWNFLGVBQUFBO0lBQ2pDLE1BQU1DLG9CQUFvQkEsSUFBTUgsRUFBY0ksV0FBQUEsSUFBZS9vQztJQUM3RCxNQUFNNjRCLElBQThCanhCLEtBQUtvaEMsNkJBQW9DO1FBQUNOO0tBQUFBO0lBQzlFLE1BQU12UCxJQUErQnZ4QixLQUFLb3pCLDhCQUFxQztRQUFDME47S0FBQUE7SUFDaEYsTUFBTU8sSUFBZXJoQyxLQUFLOEksV0FBVztJQUNyQyxNQUFNdzRCLElBQTBCdGhDLEtBQzlCaXhCLEdBQ0FvUSxHQUNBZjtJQUVGLE1BQU1pQixJQUF5QnZoQyxLQUM3QnV4QixHQUNBOFAsR0FDQWQ7SUFFRixNQUFNaUIscUJBQXNCbjlCLENBQUFBO1FBQzFCLE1BQU1vOUIsSUFBYTkwQixFQUFjdEk7UUFDakMsTUFBTXE5QixJQUFhNzBCLEVBQWN4STtRQUNqQyxNQUFNa1UsSUFBWTVOLFVBQVV0RyxHQUFLNUY7UUFDakMsTUFBTStaLElBQVk3TixVQUFVdEcsR0FBSzNGO1FBRWpDLE9BQ0dnakMsRUFBV3IxQixDQUFBQSxHQUFJbzFCLEVBQVdwMUIsQ0FBQUEsR0FBSSxNQUFNd0wsa0JBQWtCVSxNQUN0RG1wQixFQUFXcDFCLENBQUFBLEdBQUltMUIsRUFBV24xQixDQUFBQSxHQUFJLE1BQU11TCxrQkFBa0JXO0lBQVc7SUFHdEUsTUFBTW1wQixJQUEwQkwsRUFBd0JWO0lBQ3hELE1BQU1nQixJQUFtQkQsTUFBNEJiO0lBQ3JELE1BQU03UyxJQUF1QjJULEtBQW9CL1A7SUFDakQsTUFBTWdRLElBQUFBLENBQTBCRCxLQUFvQkwsRUFBdUJWO0lBSTNFLE1BQU1pQixJQUFBQSxDQUFxQkYsS0FBb0JELE1BQTRCRTtJQUMzRSxNQUFNRSxJQUFrQjlULElBQXVCK1MsSUFBYVc7SUFDNUQsTUFBTUssSUFBYy9ULElBQXVCOFQsSUFBa0JqQjtJQUM3RCxNQUFNbUIsSUFBQUEsQ0FDSEwsS0FDRHJRLEVBQTZCOFAsR0FBY2hCLEdBQThCTTtJQUMzRSxNQUFNdUIsSUFBQUEsQ0FBa0JKLEtBQXFCRDtJQUM3QyxNQUFNTSxJQUFvQjtRQUFDRDtRQUFnQkg7UUFBaUJFO1FBQWdCRDtLQUFBQSxDQUFhenpCLEdBQUFBLENBQ3RGbEssQ0FBQUEsSUFBUXRKLGNBQWNzSixNQUFBQSxDQUFTZ0QsT0FBT2hELE1BQVFBO0lBRWpELE1BQU0rOUIscUJBQXNCLzlCLENBQUFBLElBQTZCQSxLQUFPMUgsUUFBUXdsQyxHQUFtQjk5QjtJQUMzRixNQUFNZytCLElBQUFBLENBQ0hELG1CQUFtQkwsTUFBb0JQLG1CQUFtQk8sS0FDdkRBLElBQ0FqQjtJQUNOLE1BQU13QixJQUFzQnJVLElBQXVCK1MsSUFBYWU7SUFDaEUsTUFBTVEsSUFBcUJ0VSxJQUF1QjhTLElBQWdCZ0I7SUFFbEUsTUFBTVMsSUFBZ0Q7UUFDcER2VyxJQUFTNlU7UUFDVDNVLElBQU82VjtRQUNQN29CLEdBQVc0b0I7UUFDWFUsSUFBVVI7UUFDVjFWLElBQVUyVjtRQUNWN1YsSUFBc0JpVztRQUN0Qi9FLElBQXFCZ0Y7UUFDckJHLElBQThCN1EsSUFBU21QLElBQWFxQjtRQUNwRHJLLElBQWMrSTtRQUNkdFUsSUFBU29GO1FBQ1RpQixJQUFjME47UUFDZHZuQixHQUFtQjJvQjtRQUNuQmUsSUFBWXpCO1FBQ1p2VSxJQUFvQmlXLENBQUFBLElBQ2xCdjhCLGFBQWEwN0IsR0FBaUJsdUIsR0FBdUIrdUI7UUFDdkQvVixJQUF5QkEsQ0FBQytWLEdBQW9DeDhCLElBQzVERCxtQkFBbUI0N0IsR0FBaUJsdUIsR0FBdUIrdUIsR0FBNEJ4OEI7UUFDekYybUIsSUFBOEJBLElBQzVCNW1CLG1CQUNFbThCLEdBQ0F6dUIsR0FDQUssR0FDQTs7SUFHTixRQUFNOFgsSUFBRUMsQ0FBQUEsRUFBT0MsSUFBRUMsQ0FBQUEsRUFBSzBXLElBQUVKLENBQUFBLEVBQVF2cEIsR0FBRUMsQ0FBQUEsRUFBU21ULElBQUVDLEVBQUFBLEVBQUFBLEdBQWFpVztJQUMxRCxNQUFNbnJCLEtBQTZCO1FBQ2pDO1lBRUV4UyxZQUFZc25CLEdBQU87Z0JBQUN4WTtnQkFBbUJIO2FBQUFBO1lBQ3ZDM08sWUFBWW9uQixHQUFTelk7WUFDckIsSUFBSXFlLEdBQUFBO2dCQUNGaHRCLFlBQVltOEIsR0FBWTtvQkFBQ3h0QjtvQkFBeUJHO2lCQUFBQTs7UUFDcEQ7S0FBQTtJQUdKLElBQUltdkIsS0FBaUIzN0IsU0FDbkI7UUFBQ29sQjtRQUFVcFQ7UUFBV3NwQjtRQUFVdFc7UUFBT0Y7S0FBQUEsQ0FBU3ZsQixJQUFBQSxDQUFNckMsQ0FBQUEsSUFBUUEsS0FBQUEsQ0FBUSs5QixtQkFBbUIvOUI7SUFFM0YsTUFBTTArQixLQUFjOVUsSUFBdUJoQyxJQUFVTSxNQUFZcFQ7SUFDakUsTUFBTXVMLEtBQVUxa0IsS0FBS25DLGlCQUFpQndaO0lBQ3RDLE1BQU02ZixpQkFBaUJBO1FBQ3JCLE1BQU04TCxJQUFTOUI7UUFDZixNQUFNK0IsSUFBZ0J6N0I7UUFDdEIsTUFBTTA3QixTQUFVNytCLENBQUFBO1lBQ2RpRSxlQUFlakIsT0FBT2hELElBQU04QyxTQUFTOUM7WUFDckM0RCxlQUFlNUQ7UUFBSTtRQUdyQixNQUFNOCtCLHlCQUEwQno3QixDQUFBQSxJQUM5QnFHLGlCQUFpQnJHLEdBQWUsK0JBQStCa0gsZ0JBQWdCO2dCQUM3RVQsR0FBVTtnQkFDVkQsR0FBVTs7UUFFZCxNQUFNazFCLElBQWM7UUFDcEIsTUFBTUMsSUFBMkJqL0IsUUFBUStVLEdBQVdpcUI7UUFDcEQsTUFBTUUsSUFBMkJILHVCQUF1QkY7UUFDeER2K0IsU0FBU3luQixHQUFPeFksR0FBbUJpdUIsSUFBbUIsS0FBS2h1QjtRQUMzRGxQLFNBQVMrOUIsR0FBVXB1QixHQUFzQjtRQUN6QzNQLFNBQVN5VSxHQUFXdEYsR0FBdUI7UUFDM0NuUCxTQUFTNm5CLElBQVVqWSxJQUFzQjtRQUV6QyxLQUFLc3RCLEdBQWtCO1lBQ3JCbDlCLFNBQVN5VSxHQUFXaXFCLEdBQWFDLEtBQTRCO1lBQzdELElBQUl4UixHQUFBQTtnQkFDRm50QixTQUFTczhCLEdBQVl0dEIsR0FBdUI7O1FBRWhEO1FBRUFwTCxlQUFleTZCLElBQWFEO1FBQzVCeDZCLGVBQWU2akIsR0FBT3NXO1FBQ3RCbjZCLGVBQWVtNkIsS0FBWXRXLEdBQUFBLENBQVF5VixLQUFvQnpvQjtRQUN2RDdRLGVBQWU2USxHQUFXb1Q7UUFFMUJydkIsS0FBS21hLElBQVk7WUFDZmlzQjtZQUNBO2dCQUNFLE1BQU1DLElBQW1CLzdCO2dCQUN6QixNQUFNZzhCLElBQXNCcEIsbUJBQW1CanBCO2dCQUcvQyxNQUFNc3FCLElBQ0pELEtBQXVCRCxNQUFxQnBxQixJQUFZOFMsSUFBVXNYO2dCQUNwRSxNQUFNRyxJQUE4QlAsdUJBQXVCTTtnQkFDM0Q1K0IsWUFBWTQ5QixHQUFVcHVCO2dCQUN0QnhQLFlBQVkwbkIsSUFBVWpZO2dCQUN0QnpQLFlBQVlzVSxHQUFXdEY7Z0JBQ3ZCLElBQUlnZSxHQUFBQTtvQkFDRmh0QixZQUFZbThCLEdBQVl0dEI7O2dCQUUxQixJQUFJMnZCLEdBQUFBO29CQUNGMytCLFNBQVN5VSxHQUFXaXFCLEdBQWFDOztvQkFFakN4K0IsWUFBWXNVLEdBQVdpcUI7O2dCQUd6QixJQUFJaEIsbUJBQW1CN1YsS0FBQUE7b0JBQ3JCMlcsT0FBTzNXOztnQkFFVCxJQUFJaVgsR0FBQUE7b0JBQ0ZOLE9BQU8vcEI7O2dCQUVULElBQUlpcEIsbUJBQW1CSyxJQUFBQTtvQkFDckJTLE9BQU9UOztnQkFHVDl4QixhQUFhOHlCO2dCQUNiQztZQUE2QjtTQUFBO1FBSWpDLElBQUlycUIsS0FBQUEsQ0FBNEJ1b0IsR0FBa0I7WUFDaEQxN0IsYUFBYWlULEdBQVd0RixHQUF1Qk07WUFDL0NqWCxLQUFLbWEsSUFBWXJYLEtBQUs2RSxhQUFhc1UsR0FBV3RGO1FBQ2hEO1FBSUFsRCxhQUFBQSxDQUNHaXhCLEtBQW9CL1AsS0FBVW9SLE1BQWtCaFgsS0FBVytXLEVBQU8zM0IsR0FBQUEsS0FBUTIzQixJQUN2RTdwQixJQUNBOHBCO1FBRU5LO1FBSUFSLEtBQWlCO1FBRWpCLE9BQU9wZTtJQUFPO0lBR2hCLE9BQU87UUFBQzhkO1FBQW9CdEw7UUFBZ0J4UztLQUFBQTtBQUFRO0FDclIvQyxNQUFNaWYsNkJBQ1hBO1FBQUFBLEVBQUdwWCxJQUFBQSxDQUFBQSxFQUFBQTtXQUNIO1lBQUEsRUFBRzRSLElBQUFBLENBQUFBLEVBQXVCeUYsSUFBQUEsQ0FBQUEsRUFBaUJ4VCxJQUFBQSxDQUFBQSxFQUFBQTtRQUN6QyxRQUFNeVQsSUFBRTdVLENBQUFBLEVBQUFBLEdBQTRCbVAsS0FBeUIsQ0FBRTtRQUMvRCxRQUFNMkYsSUFBRWpXLENBQUFBLEVBQUFBLEdBQXFCK1Y7UUFDN0IsTUFBTS9ZLElBQXlCMEIsS0FBYXlDLENBQUFBLEtBQTJCb0IsQ0FBQUE7UUFFdkUsSUFBSXZGLEdBQUFBO1lBQ0Z6Z0IsVUFBVW1pQixHQUFVO2dCQUNsQjN0QixDQUFDQSxFQUFBQSxFQUFZaXZCLEtBQW9COzs7SUFFckM7O0FDTUcsTUFBTWtXLDZCQUEyREEsUUFFdEVuVztRQUZzRW1XLEVBQ3BFNVgsSUFBQUEsQ0FBQUEsRUFBT3NXLElBQUFBLENBQUFBLEVBQVV0cEIsR0FBQUEsQ0FBQUEsRUFBV0YsR0FBQUEsQ0FBQUEsRUFBQUE7SUFHOUIsT0FBTytxQixHQUFvQkMsRUFBQUEsR0FBdUJwdEMsWUFDaEQ7UUFDRU0sR0FBUTRJO1FBQ1I5SSxHQUFlK1Q7T0FFakJoTCxLQUFLZ0wsb0JBQW9CbWhCLEdBQU8sV0FBVztJQUc3QyxPQUFPO1lBQUEsRUFBRytELElBQUFBLENBQUFBLEVBQWNpTyxJQUFBQSxDQUFBQSxFQUF1QnlGLElBQUFBLENBQUFBLEVBQWlCeFQsSUFBQUEsQ0FBQUEsRUFBQUE7UUFDOUQsS0FBS3hOLEdBQVNzaEIsRUFBQUEsR0FBa0JELEVBQW9CN1Q7UUFDcEQsUUFBTWhYLEdBQUVDLENBQUFBLEVBQUFBLEdBQTRCZ0w7UUFDcEMsUUFBTThmLElBQUUzYSxDQUFBQSxFQUFZNGEsSUFBRWhWLENBQUFBLEVBQWdCeVAsSUFBRWhRLENBQUFBLEVBQUFBLEdBQXNCc1AsS0FBeUIsQ0FBRTtRQUN6RixRQUFNeGpCLEdBQUVDLENBQUFBLEVBQUFBLEdBQW9CZ3BCO1FBQzVCLE9BQU94a0IsR0FBaUJpbEIsRUFBQUEsR0FBMEJuVSxFQUFhO1FBQy9ELE1BQU1vVSxJQUFrQmxVLEtBQVVoQjtRQUVsQyxJQUFJNUYsS0FBZ0IwYSxLQUFrQkksR0FBQUE7YUFDbkMxaEIsR0FBU3NoQixFQUFBQSxHQUFrQkYsRUFBbUI1VDs7UUFHakQsTUFBTW1VLElBQUFBLENBQ0h0ckIsS0FBc0JvckIsQ0FBQUEsS0FBMEJ4VixLQUFxQnFWLENBQUFBO1FBRXhFLElBQUlLLEdBQXFCO1lBRXZCLE1BQU1DLElBQUFBLENBQW1CcGxCLEtBQUFBLENBQXFCcWpCLEtBQUFBLENBQWFwcEI7WUFDM0QsTUFBTW9yQixJQUFvQjdoQixFQUFRbFgsQ0FBQUEsR0FBSWtYLEVBQVFqWCxDQUFBQTtZQUM5QyxNQUFNKzRCLElBQWtCOWhCLEVBQVFuWCxDQUFBQSxHQUFJbVgsRUFBUTNsQixDQUFBQTtZQUU1QyxNQUFNMG5DLElBQTRCO2dCQUNoQ3BtQyxDQUFDQSxFQUFBQSxFQUFpQmltQyxLQUFBQSxDQUFvQjVwQixJQUFBQSxDQUFtQjZwQixJQUFvQjtnQkFDN0VqbUMsQ0FBQ0EsRUFBQUEsRUFBa0JnbUMsSUFBQUEsQ0FBbUJFLElBQWtCO2dCQUN4RHBtQyxDQUFDQSxFQUFBQSxFQUFnQmttQyxLQUFtQjVwQixJQUFBQSxDQUFtQjZwQixJQUFvQjtnQkFDM0VwNUIsS0FBS201QixJQUFBQSxDQUFtQjVoQixFQUFRblgsQ0FBQUEsR0FBSTtnQkFDcENILE9BQU9rNUIsSUFBbUI1cEIsSUFBQUEsQ0FBbUJnSSxFQUFRbFgsQ0FBQUEsR0FBSSxTQUFVO2dCQUNuRUYsTUFBTWc1QixJQUFtQjVwQixJQUFrQixVQUFVZ0ksRUFBUWpYLENBQUFBLEdBQUs7Z0JBQ2xFaE4sQ0FBQ0EsRUFBQUEsRUFBVzZsQyxLQUFtQixlQUFlQyxPQUFBQSxHQUFBQTs7WUFFaEQsTUFBTUcsSUFBNkI7Z0JBQ2pDMW1DLENBQUNBLEVBQUFBLEVBQWdCc21DLElBQWtCNWhCLEVBQVFuWCxDQUFBQSxHQUFJO2dCQUMvQ3ROLENBQUNBLEVBQUFBLEVBQWtCcW1DLElBQWtCNWhCLEVBQVFsWCxDQUFBQSxHQUFJO2dCQUNqRHJOLENBQUNBLEVBQUFBLEVBQW1CbW1DLElBQWtCNWhCLEVBQVEzbEIsQ0FBQUEsR0FBSTtnQkFDbERtQixDQUFDQSxFQUFBQSxFQUFpQm9tQyxJQUFrQjVoQixFQUFRalgsQ0FBQUEsR0FBSTs7WUFJbER2QixVQUFVcTRCLEtBQVl0cEIsR0FBV3dyQjtZQUNqQ3Y2QixVQUFVK08sR0FBV3lyQjtZQUVyQmppQyxXQUFXaXJCLEdBQU87Z0JBQ2hCNlUsSUFBVTdmO2dCQUNWaWlCLElBQUFBLENBQW1CTDtnQkFDbkJucEIsR0FBdUJvbkIsSUFDbkJtQyxJQUNBamlDLFdBQVcsQ0FBRSxHQUFFZ2lDLEdBQWNDOztRQUVyQztRQUVBLE9BQU87WUFDTEUsSUFBc0JQOztJQUN2QjtBQUNGO0FDbEJJLE1BQU1RLDhCQUE0REEsQ0FDdkVuc0IsR0FDQUM7SUFFQSxNQUFNckIsSUFBTTZNO0lBQ1osUUFBTTZILElBQ0pDLENBQUFBLEVBQUswVyxJQUNMSixDQUFBQSxFQUFRdnBCLEdBQ1JDLENBQUFBLEVBQVNILEdBQ1RDLENBQUFBLEVBQWlCcWtCLElBQ2pCQyxDQUFBQSxFQUFtQm5SLElBQ25CQyxDQUFBQSxFQUFvQkcsSUFDcEJDLENBQUFBLEVBQU9HLElBQ1BDLENBQUFBLEVBQXVCbVksSUFDdkJyQyxDQUFBQSxFQUFBQSxHQUNFL3BCO0lBQ0osUUFBTVEsR0FBRUMsQ0FBQUEsRUFBQUEsR0FBNEI3QjtJQUNwQyxNQUFNeVcsSUFBdUJ4QixLQUFXeFQ7SUFDeEMsTUFBTWdzQixJQUFPamxDLEtBQUszSCxHQUFTO0lBQzNCLE1BQU02c0MsSUFHRjtRQUNGQyxTQUFTQSxJQUFNO1FBQ2ZDLFdBQVlDLENBQUFBLElBQW1CQSxNQUFtQjtRQUNsREMsZUFBZ0JDLENBQUFBLElBQXVCQSxFQUFtQkMsUUFBQUEsQ0FBUztRQUNuRUMsYUFBY0MsQ0FBQUEsSUFBcUJBLE1BQXFCOztJQUUxRCxNQUFNQyxJQUF3QmxwQyxLQUFLeW9DO0lBR25DLE1BQU1VLElBQWlCO1FBQ3JCenVDLEdBQVEwSTtRQUNSNUksR0FBZTtZQUFFb1YsR0FBRztZQUFHQyxHQUFHOzs7SUFFNUIsTUFBTXU1QixJQUFtQjtRQUN2QjF1QyxHQUFRMkk7UUFDUjdJLEdBQWU7O0lBR2pCLE1BQU02dUMsbUJBQW9CQyxDQUFBQTtRQUV4QmxaLEVBQXdCNVksR0FBQUEsQ0FBNkJnYSxLQUF3QjhYO0lBQU87SUFHdEYsTUFBTUMseUJBQXlCQSxJQUM3QnI3QixVQUFVd08sR0FBV3dzQjtJQUN2QixNQUFNTSwrQkFBK0JBLENBQ25Ddm1CLEdBQ0F3bUI7UUFFQSxNQUFNQyxJQUFBQSxDQUF3QzFwQyxLQUFLaWpCLEdBQXFCaGxCLE1BQUFBO1FBQ3hFLE1BQU0wckMsSUFBQUEsQ0FDSEYsS0FDRFAsRUFBc0JVLElBQUFBLENBQU1DLENBQUFBO1lBQzFCLE1BQU1DLElBQWE3bUIsQ0FBQUEsQ0FBb0I0bUIsRUFBQUE7WUFDdkMsT0FBT25zQyxTQUFTb3NDLE1BQWVyQixDQUFBQSxDQUFnQ29CLEVBQUFBLENBQVdDO1FBQVc7UUFFekYsTUFBTUMsSUFDSkwsS0FBQUEsQ0FBeUNDO1FBRzNDLElBQUlJLEtBQUFBLENBQTJCdDVCLGNBQWNpTSxJQUFBQTtZQUMzQyxPQUFPO2dCQUNMaEssR0FBUTtvQkFBRXJELEdBQUc7b0JBQUdDLEdBQUc7O2dCQUNuQnFELEdBQU07b0JBQUV0RCxHQUFHO29CQUFHQyxHQUFHOzs7O1FBSXJCKzVCLGlCQUFpQjtRQUVqQixNQUFNVyxJQUF1QngzQixpQkFBaUJvZDtRQUM5QyxNQUFNcWEsSUFBa0I3WixFQUF3QnpZLEdBQTRCO1FBQzVFLE1BQU11eUIsSUFBb0I1NEIsaUJBQ3hCd3ZCLEdBQ0F4K0IsR0FDQ21ULENBQUFBO1lBQ0MsTUFBTTAwQixJQUEwQjMzQixpQkFBaUJvZDtZQUVqRCxJQUNFbmEsRUFBTTIwQixTQUFBQSxJQUNORCxFQUF3Qjk2QixDQUFBQSxLQUFNMjZCLEVBQXFCMzZCLENBQUFBLElBQ25EODZCLEVBQXdCNzZCLENBQUFBLEtBQU0wNkIsRUFBcUIxNkIsQ0FBQUEsRUFBQUE7Z0JBRW5EMkMsZ0JBQWdCd0Q7O1FBQ2xCLEdBRUY7WUFDRS9ELEdBQVU7WUFDVkUsR0FBTzs7UUFJWFEsZ0JBQWdCd2QsR0FBc0I7WUFDcEN2Z0IsR0FBRztZQUNIQyxHQUFHOztRQUVMMjZCO1FBRUEsTUFBTXYzQixJQUFTRixpQkFBaUJvZDtRQUNoQyxNQUFNcVYsSUFBYTcwQixFQUFjd2Y7UUFDakN4ZCxnQkFBZ0J3ZCxHQUFzQjtZQUNwQ3ZnQixHQUFHNDFCLEVBQVdyMUIsQ0FBQUE7WUFDZE4sR0FBRzIxQixFQUFXcDFCLENBQUFBOztRQUVoQixNQUFNdzZCLElBQWlCNzNCLGlCQUFpQm9kO1FBQ3hDLE1BQU0wYSxJQUFtQjtZQUN2Qmo3QixHQUFHZzdCLEVBQWVoN0IsQ0FBQUEsR0FBSXFELEVBQU9yRCxDQUFBQTtZQUM3QkMsR0FBRys2QixFQUFlLzZCLENBQUFBLEdBQUlvRCxFQUFPcEQsQ0FBQUE7O1FBRy9COEMsZ0JBQWdCd2QsR0FBc0I7WUFDcEN2Z0IsR0FBQUEsQ0FBSTQxQixFQUFXcjFCLENBQUFBO1lBQ2ZOLEdBQUFBLENBQUkyMUIsRUFBV3AxQixDQUFBQTs7UUFFakIsTUFBTTA2QixJQUFpQi8zQixpQkFBaUJvZDtRQUN4QyxNQUFNNGEsSUFBbUI7WUFDdkJuN0IsR0FBR2s3QixFQUFlbDdCLENBQUFBLEdBQUlxRCxFQUFPckQsQ0FBQUE7WUFDN0JDLEdBQUdpN0IsRUFBZWo3QixDQUFBQSxHQUFJb0QsRUFBT3BELENBQUFBOztRQVEvQixNQUFNcUQsSUFBTztZQUNYdEQsR0FDRWxULEVBQVFtdUMsRUFBaUJqN0IsQ0FBQUEsS0FBTWxULEVBQVFxdUMsRUFBaUJuN0IsQ0FBQUEsSUFDcERnN0IsRUFBZWg3QixDQUFBQSxHQUNmazdCLEVBQWVsN0IsQ0FBQUE7WUFDckJDLEdBQ0VuVCxFQUFRbXVDLEVBQWlCaDdCLENBQUFBLEtBQU1uVCxFQUFRcXVDLEVBQWlCbDdCLENBQUFBLElBQ3BEKzZCLEVBQWUvNkIsQ0FBQUEsR0FDZmk3QixFQUFlajdCLENBQUFBOztRQUV2QjhDLGdCQUFnQndkLEdBQXNCb2E7UUFDdEN2dEMsRUFBSSxJQUFNeXRDO1FBRVYsT0FBTztZQUNMeDNCLEdBQUFBO1lBQ0FDLEdBQUFBOztJQUNEO0lBRUgsTUFBTTgzQixvQkFBb0JBLENBQ3hCcnJCLEdBQ0FzckI7UUFFQSxNQUFNQyxJQUFhaHZDLEVBQUk4ckIsZ0JBQUFBLEdBQW1CLE1BQU0sSUFBSSxJQUFJO1FBQ3hELE1BQU1yVSxJQUFTO1lBQ2J4RCxHQUFHNDRCLEVBQUtwcEIsRUFBbUJ4UCxDQUFBQSxHQUFJODZCLEVBQW1COTZCLENBQUFBO1lBQ2xEQyxHQUFHMjRCLEVBQUtwcEIsRUFBbUJ2UCxDQUFBQSxHQUFJNjZCLEVBQW1CNzZCLENBQUFBOztRQUdwRCxPQUFPO1lBQ0xELEdBQUd3RCxFQUFPeEQsQ0FBQUEsR0FBSSs2QixJQUFhdjNCLEVBQU94RCxDQUFBQSxHQUFJO1lBQ3RDQyxHQUFHdUQsRUFBT3ZELENBQUFBLEdBQUk4NkIsSUFBYXYzQixFQUFPdkQsQ0FBQUEsR0FBSTs7SUFDdkM7SUFFSCxNQUFNKzZCLDJCQUEyQkEsQ0FDL0JqdkIsR0FDQUo7UUFFQSxNQUFNc3ZCLHVCQUF1QkEsQ0FDM0JDLEdBQ0FDLEdBQ0FDLEdBQ0FDO1lBUUEsTUFBTUMsSUFDSkosTUFBaUIxb0MsSUFBYUMsSUFBWWlaLGdDQUFnQ3d2QjtZQUM1RSxNQUFNSyxJQUFzQi92QixrQkFBa0IwdkI7WUFDOUMsTUFBTU0sSUFBK0Jod0Isa0JBQWtCNHZCO1lBR3ZELEtBQUtELEtBQUFBLENBQW9CRSxHQUFBQTtnQkFDdkIsT0FBTzVvQzs7WUFJVCxJQUFJOG9DLEtBQXVCQyxHQUFBQTtnQkFDekIsT0FBT2hwQzs7WUFJVCxJQUFJK29DLEdBQXFCO2dCQUN2QixNQUFNRSxJQUEyQk4sSUFBa0Izb0MsSUFBYUM7Z0JBQ2hFLE9BQU8wb0MsS0FBbUJFLElBQ3RCQyxJQUNBRztZQUNOO1lBRUEsTUFBTUMsSUFDSkYsS0FBZ0NILElBQXdCN29DLElBQWFDO1lBQ3ZFLE9BQU8wb0MsSUFDSEcsSUFDQUk7UUFBVztRQUdqQixPQUFPO1lBQ0xqOEIsR0FBR3c3QixxQkFBcUJ0dkIsRUFBaUJsTSxDQUFBQSxFQUFHc00sRUFBWXRNLENBQUFBLEVBQUdrTSxFQUFpQmpNLENBQUFBLEVBQUdxTSxFQUFZck0sQ0FBQUE7WUFDM0ZBLEdBQUd1N0IscUJBQXFCdHZCLEVBQWlCak0sQ0FBQUEsRUFBR3FNLEVBQVlyTSxDQUFBQSxFQUFHaU0sRUFBaUJsTSxDQUFBQSxFQUFHc00sRUFBWXRNLENBQUFBOztJQUM1RjtJQUVILE1BQU1rOEIsMkJBQTRCcnVCLENBQUFBO1FBRWhDLE1BQU1zdUIsbUNBQW9DcDhCLENBQUFBLElBQ3hDO2dCQUFDaE47Z0JBQVlDO2dCQUFXQzthQUFBQSxDQUFXd1AsR0FBQUEsQ0FBSy9ELENBQUFBLElBQ3RDMDlCLHFDQUFxQ2h3QixnQ0FBZ0MxTixJQUFRcUI7UUFFakYsTUFBTXM4QixJQUE2QkYsaUNBQWlDLE1BQ2pFbHJDLE1BQUFBLENBQU9rckMsb0NBQ1AzaUMsSUFBQUEsQ0FBSztRQUVSdW5CLEVBQXdCc2I7UUFDeEJ0YixFQUNHcHdCLEtBQUtrZCxHQUNIcEwsR0FBQUEsQ0FBSytrQixDQUFBQSxJQUNKNFUscUNBQXFDdnVCLENBQUFBLENBQXNCMlosRUFBQUEsRUFBT0EsTUFBUyxNQUU1RWh1QixJQUFBQSxDQUFLLE1BQ1I7SUFDRDtJQUdILE9BQU84aUMsR0FBb0JDLEVBQUFBLEdBQTBCeHhDLFlBQ25EK3VDLEdBQ0E1bEMsS0FBSzhNLG1CQUFtQnFNO0lBRTFCLE9BQU9tdkIsR0FBK0JDLEVBQUFBLEdBQXFDMXhDLFlBRXpFK3VDLEdBQWdCNWxDLEtBQUs2TSxHQUFlc007SUFDdEMsT0FBT3F2QixHQUEyQkMsRUFBQUEsR0FDaEM1eEMsWUFBd0IrdUM7SUFDMUIsT0FBTzhDLEVBQUFBLEdBQTBCN3hDLFlBQWtDZ3ZDO0lBQ25FLE9BQU84QyxHQUFvQkMsRUFBQUEsR0FBK0IveEMsWUFBd0IrdUM7SUFDbEYsT0FBT2lELEVBQUFBLEdBQTRCaHlDLFlBQXdDZ3ZDO0lBQzNFLE9BQU9pRCxFQUFBQSxHQUF1Q2p5QyxZQUFxQztRQUNqRk0sR0FBUUEsQ0FBQzR4QyxHQUFTbnhDLElBQ2hCMEgsTUFBTXlwQyxHQUFTbnhDLEdBQVErRixpQkFBaUJaLE9BQU9OLEtBQUtzc0MsSUFBVXRzQyxLQUFLN0U7UUFDckVYLEdBQWU7O0lBRWpCLE9BQU8reEMsR0FBaUNDLEVBQUFBLEdBQ3RDcHlDLFlBQStCO1FBQzdCTSxHQUFRQSxDQUFDNHhDLEdBQVNueEMsSUFDaEJrSSxRQUFRaXBDLEVBQVE1NUIsQ0FBQUEsRUFBUXZYLEVBQU91WCxDQUFBQSxLQUFXclAsUUFBUWlwQyxFQUFRMzVCLENBQUFBLEVBQU14WCxFQUFPd1gsQ0FBQUE7UUFDekVuWSxHQUFlaVk7O0lBR25CLE1BQU00ZSxJQUF5QjVhLDhCQUM3QnVGO0lBR0YsTUFBTXl2Qix1Q0FBdUNBLENBQzNDcEksR0FDQWowQjtRQUVBLE1BQU1xOUIsSUFBU3I5QixJQUNYaUksSUFDQUM7UUFDSixPQUFPLEdBQVkvVSxPQUFUa3FDLEdBQStCcEosT0FBdEI5Z0Msc0JBQXNCOGdDO0lBQWdCO0lBRzNELE9BQU87WUFBQSxFQUNINVAsSUFBQUEsQ0FBQUEsRUFBY2lPLElBQUFBLENBQUFBLEVBQXVCeUYsSUFBQUEsQ0FBQUEsRUFBaUJ4VCxJQUFBQSxDQUFBQSxFQUFBQSxVQUFBQSxFQUN0RDBVLElBQUFBLENBQUFBLEVBQUFBO1FBRUYsUUFBTVgsSUFDSjNhLENBQUFBLEVBQVkyZixJQUNaN1osQ0FBQUEsRUFBYThVLElBQ2JoVixDQUFBQSxFQUFnQnlQLElBQ2hCaFEsQ0FBQUEsRUFBaUJpUSxJQUNqQmxXLENBQUFBLEVBQU93Z0IsSUFDUG5aLENBQUFBLEVBQUFBLEdBQ0VrTyxLQUF5QixDQUFFO1FBQy9CLE1BQU1rTCxJQUNKdmIsS0FDQUEsRUFBdUJuVixDQUFBQSxDQUNyQkMsR0FDQUMsR0FDQStxQixHQUNBcHNCLEdBQ0EwWTtRQUdKLFFBQU1vWixHQUFFMXRCLENBQUFBLEVBQWdCMnRCLEdBQUVqdEIsQ0FBQUEsRUFBb0JrdEIsR0FBRTl1QixDQUFBQSxFQUFBQSxHQUM5QzJ1QixLQUE2QyxDQUFFO1FBRWpELE9BQU81dkIsR0FBOEI3QixFQUFBQSxHQUNuQ04sZ0NBQWdDNFksR0FBYzFZO1FBQ2hELE9BQU9NLEdBQVV5bkIsRUFBQUEsR0FBbUJyUCxFQUFhO1FBQ2pELE1BQU11WixJQUFtQjV4QixrQkFBa0JDLEVBQVNoTSxDQUFBQTtRQUNwRCxNQUFNNDlCLElBQW1CN3hCLGtCQUFrQkMsRUFBUy9MLENBQUFBO1FBRXBELE1BQU00OUIsSUFDSm5nQixLQUNBc2IsS0FDQTFWLEtBQ0FQLEtBQ0FvQixLQUNBclk7UUFFRixJQUFJZ3lCLElBQW9CdkIsRUFBdUJqWTtRQUMvQyxJQUFJeVosSUFBMEJ0QixFQUFrQ25ZO1FBQ2hFLElBQUkwWixLQUFxQnJCLEVBQThCclk7UUFDdkQsSUFBSTJaLEtBQW9CbkIsRUFBNEJ4WTtRQUVwRCxJQUFJeFksS0FBdUN5QixHQUFBQTtZQUN6Q3dULEVBQXdCMVksR0FBQUEsQ0FBbUNzRjs7UUFHN0QsSUFBSWt3QixHQUFpQjtZQUNuQixJQUFJdGpDLGFBQWE4bEIsR0FBT3hZLEdBQW1CRixJQUFBQTtnQkFDekNxeUIsaUJBQWlCOztZQUduQixNQUFNdlgsSUFBc0JqUyxLQUF3QkE7WUFFcEQsT0FBT1IsRUFBQUEsR0FBaUI4dEIsSUFBb0J4QixFQUFtQmhZO1lBQy9ELE9BQU92VSxFQUFBQSxHQUF1Qmd1QixJQUM1QnZCLEVBQThCbFk7WUFDaEMsTUFBTStXLElBQXFCdjZCLEVBQWN1TTtZQUN6QyxNQUFNNndCLElBQWtCL2IsS0FBd0J4aEIsY0FBY2syQjtZQUM5RCxNQUFNc0gsSUFBMkI7Z0JBQy9CNTlCLEdBQUc0NEIsRUFBS3BwQixFQUFtQnhQLENBQUFBLEdBQUl5UCxFQUFhelAsQ0FBQUE7Z0JBQzVDQyxHQUFHMjRCLEVBQUtwcEIsRUFBbUJ2UCxDQUFBQSxHQUFJd1AsRUFBYXhQLENBQUFBOztZQUc5QyxNQUFNNDlCLElBQTJCO2dCQUMvQjc5QixHQUFHNDRCLEVBQUFBLENBQ0ErRSxJQUNHQSxFQUFnQjM5QixDQUFBQSxHQUNoQjg2QixFQUFtQjk2QixDQUFBQSxHQUFJNDRCLEVBQUtrQyxFQUFtQjk2QixDQUFBQSxHQUFJd1AsRUFBbUJ4UCxDQUFBQSxDQUFBQSxJQUN4RXlQLEVBQWF6UCxDQUFBQTtnQkFFakJDLEdBQUcyNEIsRUFBQUEsQ0FDQStFLElBQ0dBLEVBQWdCMTlCLENBQUFBLEdBQ2hCNjZCLEVBQW1CNzZCLENBQUFBLEdBQUkyNEIsRUFBS2tDLEVBQW1CNzZCLENBQUFBLEdBQUl1UCxFQUFtQnZQLENBQUFBLENBQUFBLElBQ3hFd1AsRUFBYXhQLENBQUFBOztZQUluQixJQUFJaWlCLEdBQUFBO2dCQUNGQTs7WUFHRndiLEtBQW9CcEIsRUFBbUJ1QjtZQUN2Q0osS0FBcUJ0QixFQUNuQnRCLGtCQUFrQitDLEdBQTBCQyxJQUM1QzlaO1FBRUo7UUFFQSxPQUFPK1osSUFBY0MsR0FBQUEsR0FBdUJMO1FBQzVDLE9BQU94NkIsSUFBZ0I4NkIsR0FBQUEsR0FBeUJQO1FBQ2hELE9BQU9qdUIsSUFBb0J5dUIsR0FBQUEsR0FBNkJUO1FBQ3hELE9BQU8vdEIsSUFBY3l1QixHQUFBQSxHQUF1Qlg7UUFDNUMsT0FBT3h4QixJQUFhb3lCLEdBQUFBLEdBQXNCOUIsRUFBdUI7WUFDL0Q1OEIsR0FBR3lELEdBQWVsRCxDQUFBQSxHQUFJO1lBQ3RCTixHQUFHd0QsR0FBZWpELENBQUFBLEdBQUk7O1FBRXhCLE1BQU1tK0IsS0FDSGhCLEtBQW9CQyxLQUFxQnR4QixDQUFBQSxHQUFZdE0sQ0FBQUEsSUFBS3NNLEdBQVlyTSxDQUFBQSxLQUN0RTA5QixLQUFvQnJ4QixHQUFZdE0sQ0FBQUEsSUFBQUEsQ0FBTXNNLEdBQVlyTSxDQUFBQSxJQUNsRDI5QixLQUFvQnR4QixHQUFZck0sQ0FBQUEsSUFBQUEsQ0FBTXFNLEdBQVl0TSxDQUFBQTtRQUNyRCxNQUFNNCtCLEtBQ0o1RixLQUNBalcsS0FDQW9CLEtBQ0FzYSxNQUNBRCxNQUNBRixNQUNBQyxNQUNBOUssS0FDQTNuQixLQUNBK3hCLEtBQ0NyYSxLQUFpQnJCO1FBQ3BCLE9BQU8wYyxHQUFBQSxHQUE2QnphLEVBQWE7UUFDakQsT0FBT3hRLElBQXFCa3JCLEdBQUFBLEdBQThCOUIsRUFDeEQ2QixLQUE0QkEsR0FBMEJ4eEIsS0FBYTZzQiwwQkFDbkU1VjtRQUVGLE1BQU15YSxLQUNKaGMsS0FBcUJqRyxLQUFXZ2lCLE1BQThCSixNQUFzQnBhO1FBQ3RGLE9BQU8wYSxJQUFtQkMsR0FBQUEsR0FBNEJGLEtBQ2xEN0IsRUFDRS9DLDZCQUE2QnZtQixJQUFBQSxDQUFBQSxDQUF1QmlyQixLQUNwRHZhLEtBRUY2WTtRQUVKLElBQUl0dkIsS0FBd0IwdEIseUJBQXlCanZCLElBQWFOO1FBRWxFZ3VCLGlCQUFpQjtRQUVqQixJQUFJNEUsSUFBcUI7WUFDdkIxQyx5QkFBeUJydUI7WUFFekJBLEtBQXdCckIsd0JBQXdCYSxHQUFXZjtZQUUzRCxJQUFJc0MsS0FBeUJrQixHQUFrQjtnQkFDN0NBLEVBQWlCakMsSUFBdUJrQyxJQUFvQkM7Z0JBRTVEMVIsVUFBVStPLEdBQVd1QixFQUFzQmY7WUFDN0M7UUFDRjtRQUVBLE9BQU9tbUIsSUFBZWtMLEdBQUFBLEdBQXdCbkMsRUFBeUJsdkI7UUFFdkV4VCxtQkFBbUJnbUIsR0FBT3hZLEdBQW1CRixHQUFxQmczQjtRQUNsRXRrQyxtQkFBbUJzOEIsR0FBVXB1QixHQUFzQlosR0FBcUJnM0I7UUFFeEU5bkMsV0FBV2tXLEdBQXFCO1lBQzlCbW1CLElBQWdCYztZQUNoQnBMLElBQWU7Z0JBQ2I1b0IsR0FBR3ErQixHQUFhOTlCLENBQUFBO2dCQUNoQk4sR0FBR28rQixHQUFhNzlCLENBQUFBOztZQUVsQmtvQixJQUFpQjtnQkFDZjFvQixHQUFHeUQsR0FBZWxELENBQUFBO2dCQUNsQk4sR0FBR3dELEdBQWVqRCxDQUFBQTs7WUFFcEJrUSxHQUFjcEU7WUFDZDBiLElBQW9CemtCLDBCQUEwQnk3QixJQUFtQnY3Qjs7UUFHbkUsT0FBTztZQUNMbXZCLElBQXVCc007WUFDdkIxTSxJQUFzQjhMO1lBQ3RCNUwsSUFBd0I2TDtZQUN4QnpMLElBQTJCbU0sTUFBNEJWOztJQUN4RDtBQUNGO0FDcGJJLE1BQU1ZLHVCQUF3QnJvQyxDQUFBQTtJQUNuQyxPQUFPOGYsR0FBVXdvQixHQUF5QkMsRUFBQUEsR0FBWWhMLDZCQUE2QnY5QjtJQUNuRixNQUFNZ3JCLElBQTZCO1FBQ2pDNlUsSUFBVTtZQUNSaDNCLEdBQUc7WUFDSEMsR0FBRztZQUNIek8sR0FBRztZQUNIME8sR0FBRzs7UUFFTGs1QixJQUFrQjtRQUNsQnhwQixHQUF1QjtZQUNyQjljLENBQUNBLEVBQUFBLEVBQWlCO1lBQ2xCQyxDQUFDQSxFQUFBQSxFQUFrQjtZQUNuQkYsQ0FBQ0EsRUFBQUEsRUFBZ0I7WUFDakJKLENBQUNBLEVBQUFBLEVBQWdCO1lBQ2pCQyxDQUFDQSxFQUFBQSxFQUFrQjtZQUNuQkUsQ0FBQ0EsRUFBQUEsRUFBbUI7WUFDcEJELENBQUNBLEVBQUFBLEVBQWlCOztRQUVwQnMyQixJQUFlO1lBQUU1b0IsR0FBRztZQUFHQyxHQUFHOztRQUMxQnlvQixJQUFpQjtZQUFFMW9CLEdBQUc7WUFBR0MsR0FBRzs7UUFDNUJpekIsSUFBZ0I7WUFDZGx6QixHQUFHaE47WUFDSGlOLEdBQUdqTjs7UUFFTDBkLEdBQWM7WUFDWjFRLEdBQUc7WUFDSEMsR0FBRzs7UUFFTCtuQixJQUFvQjVrQjs7SUFFdEIsUUFBTThjLElBQUVDLENBQUFBLEVBQU9HLElBQUVDLENBQUFBLEVBQW9CclQsR0FBRUMsQ0FBQUEsRUFBaUI2VCxJQUFFQyxDQUFBQSxFQUFBQSxHQUN4RHJLO0lBQ0YsUUFBTXRKLEdBQUVDLENBQUFBLEVBQXVCNUIsR0FBRUMsQ0FBQUEsRUFBQUEsR0FBOEIyTTtJQUMvRCxNQUFNN0ssSUFBQUEsQ0FDSEgsS0FBNEIzQixDQUFBQSxFQUEwQjVMLENBQUFBLElBQUs0TCxFQUEwQjNMLENBQUFBO0lBRXhGLE1BQU1xL0IsSUFBMkM7UUFDL0N6SCwyQkFBMkJqaEI7UUFDM0JxaEIsMkJBQTJCcmhCLEdBQVVrTDtRQUNyQ21YLDRCQUE0QnJpQixHQUFVa0w7S0FBQUE7SUFHeEMsT0FBTztRQUNMc2Q7UUFDQ0csQ0FBQUE7WUFDQyxNQUFNN2QsSUFBeUMsQ0FBRTtZQUNqRCxNQUFNOGQsSUFBcUI5eEI7WUFDM0IsTUFBTTRVLElBQWVrZCxLQUFzQnI4QixpQkFBaUJvZDtZQUM1RCxNQUFNZ0MsSUFBOEJELEtBQWdCckI7WUFFcER6d0IsS0FBSzh1QyxHQUFpQkcsQ0FBQUE7Z0JBQ3BCNW9DLFdBQVc2cUIsR0FBYStkLEVBQWNGLEdBQVk3ZCxNQUFnQjtZQUFHO1lBR3ZFM2UsZ0JBQWdCd2QsR0FBc0IrQjtZQUN0QyxJQUFJQyxHQUFBQTtnQkFDRkE7O1lBRUYsS0FBS3BWLEdBQUFBO2dCQUNIcEssZ0JBQWdCb2QsR0FBUzs7WUFHM0IsT0FBT3VCO1FBQVc7UUFFcEJJO1FBQ0FsTDtRQUNBeW9CO0tBQUFBO0FBQ0Q7QUNsRUksTUFBTUssZUFBZUEsQ0FDMUI1b0MsR0FDQTlMLEdBQ0EyMEMsR0FDQUMsR0FDQXYwQjtJQUVBLElBQUl3MEIsSUFBNkI7SUFDakMsTUFBTXZnQixJQUFtQnZLLGtCQUFrQi9wQixHQUFTO0lBQ3BELE9BQ0U4MEMsR0FDQUMsR0FDQWh6QixHQUNBRCxHQUNBa3pCLEVBQUFBLEdBQ0ViLHFCQUFxQnJvQztJQUN6QixPQUFPbXBDLEdBQXNCQyxHQUFzQmx6QixFQUFBQSxHQUF1QnFTLHFCQUN4RXZTLEdBQ0FDLEdBQ0F1UyxHQUNDNmdCLENBQUFBO1FBQ0NsMUMsT0FBTyxDQUFFLEdBQUVrMUM7SUFBcUI7SUFHcEMsT0FBT0MsR0FBdUJDLEtBQXlCQyxFQUFBQSxHQUNyRGpRLHNCQUNFdjVCLEdBQ0E5TCxHQUNBZ2lCLEdBQ0FELEdBQ0FELEdBQ0F6QjtJQUdKLE1BQU1rMUIsdUJBQXdCQyxDQUFBQSxJQUM1Qjd2QyxLQUFLNnZDLEdBQU9qRyxJQUFBQSxDQUFNM3BDLENBQUFBLElBQUFBLENBQUFBLENBQVU0dkMsQ0FBQUEsQ0FBTTV2QyxFQUFBQTtJQUVwQyxNQUFNM0YsU0FBU0EsQ0FDYnMwQyxHQUNBa0I7UUFFQSxJQUFJZCxLQUFBQTtZQUNGLE9BQU87O1FBR1QsUUFDRWUsSUFBaUJDLENBQUFBLEVBQ2pCcmMsSUFBUXNjLENBQUFBLEVBQVFDLElBQ2hCeGMsQ0FBQUEsRUFBWXljLElBQ1pDLENBQUFBLEVBQUFBLEdBQ0V4QjtRQUVKLE1BQU1tQixJQUFrQkMsS0FBcUIsQ0FBRTtRQUMvQyxNQUFNcmMsSUFBQUEsQ0FBQUEsQ0FBV3NjLEtBQUFBLENBQWFmO1FBQzlCLE1BQU1tQixJQUFxQztZQUN6QzVjLElBQWNyUCxrQkFBa0IvcEIsR0FBUzAxQyxHQUFpQnBjO1lBQzFEb2MsSUFBQUE7WUFDQXBjLElBQUFBOztRQUdGLElBQUl5YyxHQUFpQjtZQUNuQlYsRUFBc0JXO1lBQ3RCLE9BQU87UUFDVDtRQUVBLE1BQU1DLElBQ0pSLEtBQ0FQLEVBQ0VycEMsV0FBVyxJQUFJbXFDLEdBQW1CO1lBQ2hDM2MsSUFBQUE7O1FBSU4sTUFBTTZjLElBQWlCbkIsRUFDckJscEMsV0FBVyxJQUFJbXFDLEdBQW1CO1lBQ2hDbEosSUFBaUI5cUI7WUFDakJxbEIsSUFBdUI0Tzs7UUFJM0JaLEVBQ0V4cEMsV0FBVyxDQUFFLEdBQUVtcUMsR0FBbUI7WUFDaEMzTyxJQUF1QjRPO1lBQ3ZCM08sSUFBdUI0Tzs7UUFJM0IsTUFBTUMsSUFBdUJaLHFCQUFxQlU7UUFDbEQsTUFBTUcsSUFBdUJiLHFCQUFxQlc7UUFDbEQsTUFBTW4xQyxJQUNKbzFDLEtBQXdCQyxLQUFBQSxDQUF5QnZwQyxjQUFjNm9DLE1BQW9CcGM7UUFFckZ1YixJQUE2QjtRQUU3QixJQUFJOXpDLEdBQUFBO1lBQ0Y2ekMsRUFBVUwsR0FBWTtnQkFDcEJsTixJQUF1QjRPO2dCQUN2QjNPLElBQXVCNE87OztRQUkzQixPQUFPbjFDO0lBQU87SUFHaEIsT0FBTztRQUNMO1lBQ0UsUUFBTXMxQyxJQUFFekssQ0FBQUEsRUFBNEJ0VyxJQUFFQyxDQUFBQSxFQUFvQlMsSUFBRUMsQ0FBQUEsRUFBQUEsR0FDMURuVTtZQUNGLE1BQU13MEIsSUFBZ0JuK0IsaUJBQWlCeXpCO1lBQ3ZDLE1BQU1yckIsSUFBYTtnQkFBQzAwQjtnQkFBd0JIO2dCQUF3Qk07YUFBQUE7WUFDcEUsTUFBTTdkLElBQThCdEI7WUFFcENsZSxnQkFBZ0J3ZCxHQUFzQitnQjtZQUN0Qy9lO1lBRUEsT0FBT3J1QixLQUFLbkMsaUJBQWlCd1o7UUFBVztRQUUxQ3RnQjtRQUNBLElBQU87Z0JBQ0xzMkMsSUFBc0J2MEI7Z0JBQ3RCdzBCLElBQXNCejBCOztRQUV4QjtZQUNFMDBCLElBQXlCMzBCO1lBQ3pCNDBCLElBQTBCcEI7O1FBRTVCTjtLQUFBQTtBQUNEO0FDMU1ILE1BQU0yQixLQUF5RCxJQUFJaHBCO0FBTzVELE1BQU1pcEIsY0FBY0EsQ0FBQzlxQyxHQUFpQmtRO0lBQzNDMjZCLEdBQWtCNTdCLEdBQUFBLENBQUlqUCxHQUFRa1E7QUFBVztBQU9wQyxNQUFNNjZCLGlCQUFrQi9xQyxDQUFBQTtJQUM3QjZxQyxHQUFrQnZvQixNQUFBQSxDQUFPdGlCO0FBQU87QUFPM0IsTUFBTWdyQyxjQUFlaHJDLENBQUFBLElBQzFCNnFDLEdBQWtCbDhCLEdBQUFBLENBQUkzTztBQytSakIsTUFBTWlyQyxvQkFBNkNBLENBQ3hEanJDLEdBQ0E5TCxHQUNBZzNDO0lBRUEsUUFBTUMsSUFBRXRxQixDQUFBQSxFQUFBQSxHQUF1Qlk7SUFDL0IsTUFBTTJwQixJQUFrQmp6QyxjQUFjNkg7SUFDdEMsTUFBTXFyQyxJQUFpQkQsSUFBa0JwckMsSUFBU0EsRUFBT0EsTUFBQUE7SUFDekQsTUFBTXNyQyxJQUFvQk4sWUFBWUs7SUFDdEMsSUFBSW4zQyxLQUFBQSxDQUFZbzNDLEdBQW1CO1FBQ2pDLElBQUkxcEIsSUFBWTtRQUNoQixNQUFNbk4sSUFBNkI7UUFDbkMsTUFBTTgyQixJQUFzRSxDQUFFO1FBQzlFLE1BQU1DLGtCQUFtQjl0QixDQUFBQTtZQUN2QixNQUFNK3RCLElBQTZCNXFDLDBCQUEwQjZjO1lBQzdELE1BQU1ndUIsSUFBaUJwN0IsOEJBQ3JCRTtZQUVGLE9BQU9rN0IsSUFDSEEsRUFBZUQsR0FBNEIsUUFDM0NBO1FBQTBCO1FBRWhDLE1BQU1FLElBQWtDNXJDLFdBQ3RDLENBQUUsR0FDRjhnQixLQUNBMnFCLGdCQUFnQnQzQztRQUVsQixPQUFPMDNDLEdBQWdCQyxHQUFvQkMsRUFBQUEsR0FDekN6OUI7UUFDRixPQUFPMDlCLEdBQWtCQyxHQUFzQkMsRUFBQUEsR0FDN0M1OUIsdUJBQXVCNjhCO1FBQ3pCLE1BQU03N0IsZUFBMENBLENBQUN4WSxHQUFNcUU7WUFDckQrd0MsRUFBcUJwMUMsR0FBTXFFO1lBQzNCNHdDLEVBQW1CajFDLEdBQU1xRTtRQUFLO1FBRWhDLE9BQU9neEMsR0FBaUJDLEdBQWNDLEdBQWFDLEdBQWdCQyxFQUFBQSxHQUNqRTFELGFBQ0U1b0MsR0FDQTJyQyxHQUNBLElBQU0vcEIsR0FDTjtnQkFBQSxFQUFHZ29CLElBQUFBLENBQUFBLEVBQWlCcGMsSUFBQUEsQ0FBQUEsRUFBQUEsVUFBQUEsRUFBWStOLElBQUFBLENBQUFBLEVBQXVCQyxJQUFBQSxDQUFBQSxFQUFBQTtZQUNyRCxRQUFNK0YsSUFDSjNhLENBQUFBLEVBQVlxVixJQUNaaFEsQ0FBQUEsRUFBaUJnVixJQUNqQjdVLENBQUFBLEVBQXVCb1YsSUFDdkJoVixDQUFBQSxFQUFnQitaLElBQ2hCN1osQ0FBQUEsRUFBYXdQLElBQ2JsVyxDQUFBQSxFQUFBQSxHQUNFdVY7WUFFSixRQUFNRSxJQUNKQyxDQUFBQSxFQUFvQkMsSUFDcEJDLENBQUFBLEVBQXNCQyxJQUN0QkMsQ0FBQUEsRUFBcUJDLElBQ3JCQyxDQUFBQSxFQUFBQSxHQUNFUjtZQUVKbnNCLGFBQWEsV0FBVztnQkFDdEJZO2dCQUNBO29CQUNFMmEsYUFBYTt3QkFDWDJoQixhQUFBQSxDQUFBQSxDQUFlM2xCO3dCQUNmNGxCLGtCQUFBQSxDQUFBQSxDQUFvQnZnQjt3QkFDcEJoRSx3QkFBQUEsQ0FBQUEsQ0FBMEJtRTt3QkFDMUJvYixxQkFBQUEsQ0FBQUEsQ0FBdUI5TDt3QkFDdkIrTCx1QkFBQUEsQ0FBQUEsQ0FBeUI3TDt3QkFDekJ3TSxzQkFBQUEsQ0FBQUEsQ0FBd0J0TTt3QkFDeEJxTSwwQkFBQUEsQ0FBQUEsQ0FBNEJuTTt3QkFDNUIwRixpQkFBQUEsQ0FBQUEsQ0FBbUJsVjt3QkFDbkJpZ0IsY0FBQUEsQ0FBQUEsQ0FBZ0IvZjt3QkFDaEJwWSxRQUFBQSxDQUFBQSxDQUFVMFI7O29CQUVaOUgsZ0JBQWdCMHJCLEtBQW1CLENBQUU7b0JBQ3JDOTBDLE9BQUFBLENBQUFBLENBQVMwNEI7OztRQUVYLEdBR0hoWixDQUFBQSxJQUFnQm5GLGFBQWEsVUFBVTtnQkFBQ1k7Z0JBQVV1RTthQUFBQTtRQUd2RCxNQUFNc04sVUFBV3ltQixDQUFBQTtZQUNmd0MsZUFBZU07WUFDZnB3QyxnQkFBZ0J3WjtZQUVoQm1OLElBQVk7WUFFWnZTLGFBQWEsYUFBYTtnQkFBQ1k7Z0JBQVVzNEI7YUFBQUE7WUFDckNzRDtZQUNBRztRQUFzQjtRQUd4QixNQUFNLzdCLElBQThCO1lBQ2xDL2IsU0FBUXdwQixDQUFBQSxFQUE2Qmd2QixDQUFBQTtnQkFDbkMsSUFBSWh2QixHQUFZO29CQUNkLE1BQU1pdkIsSUFBT0QsSUFBTzdyQixNQUF1QixDQUFFO29CQUM3QyxNQUFNM0MsSUFBaUJWLGVBQ3JCbXVCLEdBQ0E1ckMsV0FBVzRzQyxHQUFNbkIsZ0JBQWdCOXRCO29CQUVuQyxLQUFLM2MsY0FBY21kLElBQWlCO3dCQUNsQ25lLFdBQVc0ckMsR0FBZ0J6dEI7d0JBQzNCaXVCLEVBQWE7NEJBQUV2QyxJQUFpQjFyQjs7b0JBQ2xDO2dCQUNGO2dCQUNBLE9BQU9uZSxXQUFXLENBQUUsR0FBRTRyQztZQUN2QjtZQUNEaUIsSUFBSWI7WUFDSmMsS0FBS0EsQ0FBQ2gyQyxHQUFNbVU7Z0JBQ1YsSUFBSW5VLEtBQVFtVSxHQUFBQTtvQkFDVmdoQyxFQUFxQm4xQyxHQUFNbVU7O1lBQzdCO1lBRUZnZ0I7Z0JBQ0UsUUFBTThoQixJQUFFckMsQ0FBQUEsRUFBb0JzQyxJQUFFckMsQ0FBQUEsRUFBQUEsR0FBeUIwQjtnQkFDdkQsUUFBTXIwQixHQUFFQyxDQUFBQSxFQUFBQSxHQUFvQnl5QjtnQkFDNUIsUUFBTTVZLElBQ0pDLENBQUFBLEVBQWFILElBQ2JDLENBQUFBLEVBQWV1SyxJQUNmQyxDQUFBQSxFQUFjemlCLEdBQ2RDLENBQUFBLEVBQVlxbUIsSUFDWkosQ0FBQUEsRUFBUXhrQyxJQUNSNG1DLENBQUFBLEVBQWdCaFIsSUFDaEJDLENBQUFBLEVBQUFBLEdBQ0V3WjtnQkFDSixPQUFPM3FDLFdBQ0wsSUFDQTtvQkFDRXduQyxjQUFjelY7b0JBQ2RubEIsZ0JBQWdCaWxCO29CQUNoQnNMLGVBQWVkO29CQUNmNW1CLGFBQWFvRTtvQkFDYnN1QixtQkFBbUI7d0JBQ2pCbjdCLE9BQU9ta0IsRUFBbUIza0IsQ0FBQUE7d0JBQzFCUyxLQUFLa2tCLEVBQW1CMWtCLENBQUFBOztvQkFFMUJ3VCxTQUFTNmY7b0JBQ1RyakIsaUJBQWlCeWxCO29CQUNqQitLLGNBQWNoMUI7b0JBQ2Q0SixXQUFBQTs7WUFHTDtZQUNEOUI7Z0JBQ0UsUUFBTXNKLElBQ0pDLENBQUFBLEVBQU9DLElBQ1BDLENBQUFBLEVBQUswVyxJQUNMSixDQUFBQSxFQUFRdnBCLEdBQ1JDLENBQUFBLEVBQVNtVCxJQUNUQyxDQUFBQSxFQUFRSCxJQUNSQyxDQUFBQSxFQUFvQmlSLElBQ3BCQyxDQUFBQSxFQUFBQSxHQUNFMFIsRUFBZTFCLEVBQUFBO2dCQUNuQixRQUFNc0MsSUFBRXJZLENBQUFBLEVBQVdzWSxJQUFFbFksQ0FBQUEsRUFBQUEsR0FBY3FYLEVBQWV6QixFQUFBQTtnQkFDbEQsTUFBTXVDLDhCQUNKOWEsQ0FBQUE7b0JBRUEsUUFBTWlELElBQUUvRCxDQUFBQSxFQUFPOEQsSUFBRWxCLENBQUFBLEVBQU1WLElBQUVuQixDQUFBQSxFQUFBQSxHQUFlRDtvQkFDeEMsT0FBTzt3QkFDTDJCLFdBQVcxQjt3QkFDWDJCLE9BQU9FO3dCQUNQRCxRQUFRM0M7O2dCQUNUO2dCQUVILE1BQU02YixrQ0FDSkMsQ0FBQUE7b0JBRUEsUUFBTUMsSUFBRXpZLENBQUFBLEVBQW9CMFksSUFBRXpZLENBQUFBLEVBQUFBLEdBQVd1WTtvQkFDekMsTUFBTUcsSUFBc0JMLDRCQUE0QnRZLENBQUFBLENBQXFCO29CQUU3RSxPQUFPOTBCLFdBQVcsQ0FBRSxHQUFFeXRDLEdBQXFCO3dCQUN6QzVzQyxPQUFPQTs0QkFDTCxNQUFNL0QsSUFBU3N3Qyw0QkFBNEJyWTs0QkFDM0NxWCxFQUFhO2dDQUFFbEMsSUFBaUI7OzRCQUNoQyxPQUFPcHRDO3dCQUFNOztnQkFFZjtnQkFFSixPQUFPa0QsV0FDTCxJQUNBO29CQUNFQyxRQUFRcXBCO29CQUNSdEosTUFBTXdKO29CQUNOdkosU0FBUzZmLEtBQVl0cEI7b0JBQ3JCMEosVUFBVTFKO29CQUNWMkosU0FBU3lKLEtBQVlwVDtvQkFDckJtcEIscUJBQXFCalc7b0JBQ3JCa1csb0JBQW9CaEY7b0JBQ3BCOFMscUJBQXFCTCxnQ0FBZ0N4WTtvQkFDckQ4WSxtQkFBbUJOLGdDQUFnQ3BZOztZQUd4RDtZQUNEN2dDLFFBQVNxNUIsQ0FBQUEsSUFBcUIyZSxFQUFhO29CQUFFM2UsSUFBQUE7b0JBQVFELElBQWM7O1lBQ25FekwsU0FBUzFrQixLQUFLMGtCLFNBQVM7WUFDdkJuUyxRQUFtQ0EsQ0FBQUEsSUFDakM0N0IsQ0FBQUEsQ0FBOEIxeEMsS0FBSzhWLEVBQUFBLENBQVE7O1FBSy9DclYsS0FBS21hLEdBQVk7WUFBQzYzQjtTQUFBQTtRQUdsQnhCLFlBQVlPLEdBQWdCcDdCO1FBRzVCTCw4QkFBOEJMLEdBQWUwN0IsbUJBQW1CO1lBQzlEaDdCO1lBQ0EyN0I7WUFDQUw7U0FBQUE7UUFHRixJQUNFdmMscUJBQ0VxZCxFQUFlMUIsRUFBQUEsQ0FBd0I5Z0IsRUFBQUEsRUFBQUEsQ0FDdEN1aEIsS0FBbUJwckMsRUFBT29nQixNQUFBQSxHQUU3QjtZQUNBMEIsUUFBUTtZQUNSLE9BQU83UjtRQUNUO1FBRUEzVixLQUFLbWEsR0FBWXkzQjtRQUVqQjc4QixhQUFhLGVBQWU7WUFBQ1k7U0FBQUE7UUFFN0JBLEVBQVM5YixNQUFBQTtRQUVULE9BQU84YjtJQUNUO0lBQ0EsT0FBT3E3QjtBQUFrQjtLQXZPZEw7QUEwT2JBLGtCQUFrQnQ3QixNQUFBQSxHQUFVZytCLENBQUFBO0lBQzFCLE1BQU1DLElBQVFsMkMsUUFBUWkyQztJQUN0QixNQUFNRSxJQUNKRCxJQUFRRCxJQUFVO1FBQUNBO0tBQUFBO0lBQ3JCLE1BQU05d0MsSUFBU2d4QyxFQUFhbGlDLEdBQUFBLENBQ3pCZ0UsQ0FBQUEsSUFBV0MsOEJBQThCRCxHQUFRczdCLGtCQUFBQSxDQUFtQjtJQUV2RXg3QixXQUFXbytCO0lBQ1gsT0FBT0QsSUFBUS93QyxJQUFVQSxDQUFBQSxDQUFPO0FBQVU7QUFFNUNvdUMsa0JBQWtCNkMsS0FBQUEsR0FBUzU5QixDQUFBQTtJQUN6QixNQUFNNjlCLElBQVk3OUIsS0FBZUEsRUFBaUM0UCxRQUFBQTtJQUNsRSxNQUFNQSxJQUFXcm9CLFdBQVdzMkMsTUFBY0E7SUFDMUMsT0FBTy8xQyxjQUFjOG5CLE1BQUFBLENBQUFBLENBQWVrckIsWUFBWWxyQixFQUFTOWYsTUFBQUE7QUFBTztBQUVsRWlyQyxrQkFBa0JyMkIsR0FBQUEsR0FBTTtJQUN0QixRQUFNOEIsR0FDSkMsQ0FBQUEsRUFBcUI5QixHQUNyQkMsQ0FBQUEsRUFBeUIwQixHQUN6QkMsQ0FBQUEsRUFBdUJ1M0IsR0FDdkJ4dEIsQ0FBQUEsRUFBZXl0QixJQUNmanRCLENBQUFBLEVBQTRCa3RCLElBQzVCanRCLENBQUFBLEVBQXFCa08sR0FDckJ6TyxDQUFBQSxFQUF5Qnl0QixHQUN6Qnh0QixDQUFBQSxFQUF5QndxQixJQUN6QnRxQixDQUFBQSxFQUFrQnV0QixJQUNsQnR0QixDQUFBQSxFQUFBQSxHQUNFVztJQUNKLE9BQU8xaEIsV0FDTCxJQUNBO1FBQ0VzdUMsZ0JBQWdCMTNCO1FBQ2hCMjNCLG9CQUFvQng1QjtRQUNwQnk1QixrQkFBa0I5M0I7UUFDbEJnYixnQkFBZ0JqUjtRQUNoQlgsNkJBQTZCbUI7UUFDN0JYLHNCQUFzQlk7UUFFdEJWLDBCQUEwQkc7UUFDMUI4dEIsMEJBQTBCN3RCO1FBQzFCTCxtQkFBbUJPO1FBQ25CNHRCLG1CQUFtQjN0Qjs7QUFFdEI7QUFFSG1xQixrQkFBa0I5c0IsS0FBQUEsR0FBUUU7QUFDMUI0c0Isa0JBQWtCbmxDLGlCQUFBQSxHQUFvQkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zdXBwb3J0L2NhY2hlLnRzP2I5Y2IiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC9jb21wYXRpYmlsaXR5L2lzQnJvd3Nlci50cz9jNWY5Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvdXRpbHMvYWxpYXMudHM/ZTlhMCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zdXBwb3J0L2NvbXBhdGliaWxpdHkvYXBpcy50cz81NjBlIiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvdXRpbHMvdHlwZXMudHM/YzExMiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zdXBwb3J0L3V0aWxzL2FuaW1hdGlvbi50cz9hZmVhIiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvdXRpbHMvYXJyYXkudHM/ZjA5ZiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zdXBwb3J0L3V0aWxzL3N0cmluZ3MudHM/YWI1NyIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zdXBwb3J0L3V0aWxzL2VxdWFsLnRzPzkwMjQiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC91dGlscy9mdW5jdGlvbi50cz8zYjZlIiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvdXRpbHMvb2JqZWN0LnRzP2Q2NGUiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC91dGlscy9ub29wLnRzP2E5ZGYiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC91dGlscy9tYXRoLnRzP2MyNGIiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC9kb20vYXR0cmlidXRlLnRzP2Y5M2UiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC9kb20vY2xhc3MudHM/YjIzZCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zdXBwb3J0L2RvbS90cmF2ZXJzYWwudHM/ODljZiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zdXBwb3J0L2RvbS9tYW5pcHVsYXRpb24udHM/ZGRjMCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy90cnVzdGVkVHlwZVBvbGljeS50cz81NGY1Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvZG9tL2NyZWF0ZS50cz85ODFhIiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvZG9tL3N0eWxlLnRzPzVkOGQiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC9kb20vZGltZW5zaW9ucy50cz8zMGM5Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvZG9tL2V2ZW50cy50cz9jOGIyIiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvZG9tL3Njcm9sbC50cz81Y2FjIiwid2VicGFjazovL19OX0UvLi4vc3JjL3N1cHBvcnQvZG9tL2ZvY3VzLnRzP2Y1OWYiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc3VwcG9ydC9ldmVudExpc3RlbmVycy50cz85NWY2Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3BsdWdpbnMvcGx1Z2lucy50cz9kM2FiIiwid2VicGFjazovL19OX0UvLi4vc3JjL3BsdWdpbnMvb3B0aW9uc1ZhbGlkYXRpb25QbHVnaW4vb3B0aW9uc1ZhbGlkYXRpb25QbHVnaW4udHM/NDkzMCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9jbGFzc25hbWVzLnRzPzlmOWEiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9zaXplT2JzZXJ2ZXJQbHVnaW4vc2l6ZU9ic2VydmVyUGx1Z2luLnRzPzg1MTkiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc2V0dXBzL3N0cnVjdHVyZVNldHVwL3N0cnVjdHVyZVNldHVwLnV0aWxzLnRzPzhmODYiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvcGx1Z2lucy9zY3JvbGxiYXJzSGlkaW5nUGx1Z2luL3Njcm9sbGJhcnNIaWRpbmdQbHVnaW4udHM/OGQyOSIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wbHVnaW5zL2NsaWNrU2Nyb2xsUGx1Z2luL2NsaWNrU2Nyb2xsUGx1Z2luLnRzPzlkYWIiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvb3B0aW9ucy50cz9lODQ1Iiwid2VicGFjazovL19OX0UvLi4vc3JjL25vbmNlLnRzPzFjOTEiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvZW52aXJvbm1lbnQudHM/MmQzZiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9vYnNlcnZlcnMvZG9tT2JzZXJ2ZXIudHM/OTMyNCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9vYnNlcnZlcnMvc2l6ZU9ic2VydmVyLnRzP2YxZmUiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvb2JzZXJ2ZXJzL3RyaW5zaWNPYnNlcnZlci50cz85M2RlIiwid2VicGFjazovL19OX0UvLi4vc3JjL3NldHVwcy9vYnNlcnZlcnNTZXR1cC9vYnNlcnZlcnNTZXR1cC50cz9kZDM3Iiwid2VicGFjazovL19OX0UvLi4vc3JjL2luaXRpYWxpemF0aW9uLnRzPzFlMzYiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvc2V0dXBzL3Njcm9sbGJhcnNTZXR1cC9zY3JvbGxiYXJzU2V0dXAuZWxlbWVudHMudHM/MjQ4NCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zZXR1cHMvc2Nyb2xsYmFyc1NldHVwL3Njcm9sbGJhcnNTZXR1cC5ldmVudHMudHM/MDMxZSIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zZXR1cHMvc2Nyb2xsYmFyc1NldHVwL3Njcm9sbGJhcnNTZXR1cC50cz85NzFmIiwid2VicGFjazovL19OX0UvLi4vc3JjL3NldHVwcy9zdHJ1Y3R1cmVTZXR1cC9zdHJ1Y3R1cmVTZXR1cC5lbGVtZW50cy50cz83M2QzIiwid2VicGFjazovL19OX0UvLi4vc3JjL3NldHVwcy9zdHJ1Y3R1cmVTZXR1cC91cGRhdGVTZWdtZW50cy90cmluc2ljVXBkYXRlU2VnbWVudC50cz8xYWU0Iiwid2VicGFjazovL19OX0UvLi4vc3JjL3NldHVwcy9zdHJ1Y3R1cmVTZXR1cC91cGRhdGVTZWdtZW50cy9wYWRkaW5nVXBkYXRlU2VnbWVudC50cz9mMGRlIiwid2VicGFjazovL19OX0UvLi4vc3JjL3NldHVwcy9zdHJ1Y3R1cmVTZXR1cC91cGRhdGVTZWdtZW50cy9vdmVyZmxvd1VwZGF0ZVNlZ21lbnQudHM/OGM1OCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zZXR1cHMvc3RydWN0dXJlU2V0dXAvc3RydWN0dXJlU2V0dXAudHM/ZTZmZCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9zZXR1cHMvc2V0dXBzLnRzP2M4N2YiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvaW5zdGFuY2VzLnRzPzI3YTkiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvb3ZlcmxheXNjcm9sbGJhcnMudHM/YzRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIENhY2hlT3B0aW9uczxWYWx1ZT4ge1xyXG4gIC8vIGluaXRpYWwgdmFsdWUgb2YgX3ZhbHVlLlxyXG4gIF9pbml0aWFsVmFsdWU6IFZhbHVlO1xyXG4gIC8vIEN1c3RvbSBjb21wYXJpc29uIGZ1bmN0aW9uIGlmIHNoYWxsb3cgY29tcGFyZSBpc24ndCBlbm91Z2guIFJldHVybnMgdHJ1ZSBpZiBub3RoaW5nIGNoYW5nZWQuXHJcbiAgX2VxdWFsPzogRXF1YWxDYWNoZVByb3BGdW5jdGlvbjxWYWx1ZT47XHJcbiAgLy8gSWYgdHJ1ZSBhbHdheXMgdXBkYXRlcyBfdmFsdWUgYW5kIF9wcmV2aW91cywgb3RoZXJ3aXNlIHRoZXkgdXBkYXRlIG9ubHkgd2hlbiB0aGV5IGNoYW5nZWQuXHJcbiAgX2Fsd2F5c1VwZGF0ZVZhbHVlcz86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIENhY2hlVmFsdWVzPFQ+ID0gW3ZhbHVlOiBULCBjaGFuZ2VkOiBib29sZWFuLCBwcmV2aW91cz86IFRdO1xyXG5cclxuZXhwb3J0IHR5cGUgRXF1YWxDYWNoZVByb3BGdW5jdGlvbjxWYWx1ZT4gPSAoY3VycmVudFZhbDogVmFsdWUsIG5ld1ZhbDogVmFsdWUpID0+IGJvb2xlYW47XHJcblxyXG5leHBvcnQgdHlwZSBDYWNoZVVwZGF0ZXI8VmFsdWU+ID0gKGN1cnJlbnQ6IFZhbHVlLCBwcmV2aW91cz86IFZhbHVlKSA9PiBWYWx1ZTtcclxuXHJcbmV4cG9ydCB0eXBlIFVwZGF0ZUNhY2hlQ29udGV4dHVhbDxWYWx1ZT4gPSAobmV3VmFsdWU6IFZhbHVlLCBmb3JjZT86IGJvb2xlYW4pID0+IENhY2hlVmFsdWVzPFZhbHVlPjtcclxuXHJcbmV4cG9ydCB0eXBlIFVwZGF0ZUNhY2hlPFZhbHVlPiA9IChmb3JjZT86IGJvb2xlYW4pID0+IENhY2hlVmFsdWVzPFZhbHVlPjtcclxuXHJcbmV4cG9ydCB0eXBlIEdldEN1cnJlbnRDYWNoZTxWYWx1ZT4gPSAoZm9yY2U/OiBib29sZWFuKSA9PiBDYWNoZVZhbHVlczxWYWx1ZT47XHJcblxyXG5leHBvcnQgdHlwZSBDYWNoZTxWYWx1ZT4gPSBbVXBkYXRlQ2FjaGU8VmFsdWU+LCBHZXRDdXJyZW50Q2FjaGU8VmFsdWU+XTtcclxuXHJcbmV4cG9ydCB0eXBlIENhY2hlQ29udGV4dHVhbDxWYWx1ZT4gPSBbVXBkYXRlQ2FjaGVDb250ZXh0dWFsPFZhbHVlPiwgR2V0Q3VycmVudENhY2hlPFZhbHVlPl07XHJcblxyXG50eXBlIENyZWF0ZUNhY2hlID0ge1xyXG4gIDxWYWx1ZT4ob3B0aW9uczogQ2FjaGVPcHRpb25zPFZhbHVlPik6IENhY2hlQ29udGV4dHVhbDxWYWx1ZT47XHJcbiAgPFZhbHVlPihvcHRpb25zOiBDYWNoZU9wdGlvbnM8VmFsdWU+LCB1cGRhdGU6IENhY2hlVXBkYXRlcjxWYWx1ZT4pOiBDYWNoZTxWYWx1ZT47XHJcbiAgPFZhbHVlPihcclxuICAgIG9wdGlvbnM6IENhY2hlT3B0aW9uczxWYWx1ZT4sXHJcbiAgICB1cGRhdGU/OiBDYWNoZVVwZGF0ZXI8VmFsdWU+XHJcbiAgKTogQ2FjaGVDb250ZXh0dWFsPFZhbHVlPiB8IENhY2hlPFZhbHVlPjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDYWNoZTogQ3JlYXRlQ2FjaGUgPSA8VmFsdWU+KFxyXG4gIG9wdGlvbnM6IENhY2hlT3B0aW9uczxWYWx1ZT4sXHJcbiAgdXBkYXRlPzogQ2FjaGVVcGRhdGVyPFZhbHVlPlxyXG4pOiBDYWNoZUNvbnRleHR1YWw8VmFsdWU+IHwgQ2FjaGU8VmFsdWU+ID0+IHtcclxuICBjb25zdCB7IF9pbml0aWFsVmFsdWUsIF9lcXVhbCwgX2Fsd2F5c1VwZGF0ZVZhbHVlcyB9ID0gb3B0aW9ucztcclxuICBsZXQgX3ZhbHVlOiBWYWx1ZSA9IF9pbml0aWFsVmFsdWU7XHJcbiAgbGV0IF9wcmV2aW91czogVmFsdWUgfCB1bmRlZmluZWQ7XHJcblxyXG4gIGNvbnN0IGNhY2hlVXBkYXRlQ29udGV4dHVhbDogVXBkYXRlQ2FjaGVDb250ZXh0dWFsPFZhbHVlPiA9IChuZXdWYWx1ZSwgZm9yY2U/KSA9PiB7XHJcbiAgICBjb25zdCBjdXJyID0gX3ZhbHVlO1xyXG5cclxuICAgIGNvbnN0IG5ld1ZhbCA9IG5ld1ZhbHVlO1xyXG4gICAgY29uc3QgY2hhbmdlZCA9IGZvcmNlIHx8IChfZXF1YWwgPyAhX2VxdWFsKGN1cnIsIG5ld1ZhbCkgOiBjdXJyICE9PSBuZXdWYWwpO1xyXG5cclxuICAgIGlmIChjaGFuZ2VkIHx8IF9hbHdheXNVcGRhdGVWYWx1ZXMpIHtcclxuICAgICAgX3ZhbHVlID0gbmV3VmFsO1xyXG4gICAgICBfcHJldmlvdXMgPSBjdXJyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbX3ZhbHVlLCBjaGFuZ2VkLCBfcHJldmlvdXNdO1xyXG4gIH07XHJcbiAgY29uc3QgY2FjaGVVcGRhdGVJc29sYXRlZDogVXBkYXRlQ2FjaGU8VmFsdWU+ID0gKGZvcmNlPykgPT5cclxuICAgIGNhY2hlVXBkYXRlQ29udGV4dHVhbCh1cGRhdGUhKF92YWx1ZSwgX3ByZXZpb3VzKSwgZm9yY2UpO1xyXG5cclxuICBjb25zdCBnZXRDdXJyZW50Q2FjaGU6IEdldEN1cnJlbnRDYWNoZTxWYWx1ZT4gPSAoZm9yY2U/OiBib29sZWFuKSA9PiBbXHJcbiAgICBfdmFsdWUsXHJcbiAgICAhIWZvcmNlLCAvLyBjaGFuZ2VkXHJcbiAgICBfcHJldmlvdXMsXHJcbiAgXTtcclxuXHJcbiAgcmV0dXJuIFt1cGRhdGUgPyBjYWNoZVVwZGF0ZUlzb2xhdGVkIDogY2FjaGVVcGRhdGVDb250ZXh0dWFsLCBnZXRDdXJyZW50Q2FjaGVdIGFzXHJcbiAgICB8IENhY2hlQ29udGV4dHVhbDxWYWx1ZT5cclxuICAgIHwgQ2FjaGU8VmFsdWU+O1xyXG59O1xyXG4iLCJleHBvcnQgY29uc3QgaXNCcm93c2VyID1cclxuICAvLyBkZW5vIGhhcyB0aGUgZ2xvYmFsIGB3aW5kb3dgIGRlZmluZWRcclxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gIC8vIG1ha2Ugc3VyZSBIVE1MIGVsZW1lbnQgaXMgYXZhaWxhYmxlXHJcbiAgdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gIC8vIG1ha2Ugc3VyZSBkb2N1bWVudCBpcyBkZWZpbmVkXHJcbiAgISF3aW5kb3cuZG9jdW1lbnQ7XHJcbiIsImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4uL2NvbXBhdGliaWxpdHkvaXNCcm93c2VyJztcclxuXHJcbmV4cG9ydCBjb25zdCB3bmQgPSAoaXNCcm93c2VyID8gd2luZG93IDoge30pIGFzIHR5cGVvZiB3aW5kb3c7XHJcbmV4cG9ydCBjb25zdCBtYXRoTWF4ID0gTWF0aC5tYXg7XHJcbmV4cG9ydCBjb25zdCBtYXRoTWluID0gTWF0aC5taW47XHJcbmV4cG9ydCBjb25zdCBtYXRoUm91bmQgPSBNYXRoLnJvdW5kO1xyXG5leHBvcnQgY29uc3QgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcclxuZXhwb3J0IGNvbnN0IG1hdGhDZWlsID0gTWF0aC5jZWlsO1xyXG5leHBvcnQgY29uc3QgbWF0aEFicyA9IE1hdGguYWJzO1xyXG5leHBvcnQgY29uc3QgbWF0aFNpZ24gPSBNYXRoLnNpZ247XHJcbmV4cG9ydCBjb25zdCBjQUYgPSB3bmQuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcbmV4cG9ydCBjb25zdCByQUYgPSB3bmQucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG5leHBvcnQgY29uc3Qgc2V0VCA9IHduZC5zZXRUaW1lb3V0O1xyXG5leHBvcnQgY29uc3QgY2xlYXJUID0gd25kLmNsZWFyVGltZW91dDtcclxuIiwiaW1wb3J0IHsgd25kIH0gZnJvbSAnLi4vdXRpbHMvYWxpYXMnO1xyXG5cclxuY29uc3QgZ2V0QXBpID0gPFQ+KG5hbWU6IHN0cmluZykgPT5cclxuICAodHlwZW9mIHduZFtuYW1lIGFzIGtleW9mIHR5cGVvZiB3bmRdICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgPyB3bmRbbmFtZSBhcyBrZXlvZiB0eXBlb2Ygd25kXVxyXG4gICAgOiB1bmRlZmluZWQpIGFzIFQ7XHJcblxyXG5leHBvcnQgY29uc3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yID0gZ2V0QXBpPHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyPignTXV0YXRpb25PYnNlcnZlcicpO1xyXG5leHBvcnQgY29uc3QgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3RvciA9XHJcbiAgZ2V0QXBpPHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlcj4oJ0ludGVyc2VjdGlvbk9ic2VydmVyJyk7XHJcbmV4cG9ydCBjb25zdCBSZXNpemVPYnNlcnZlckNvbnN0cnVjdG9yID0gZ2V0QXBpPHR5cGVvZiBSZXNpemVPYnNlcnZlcj4oJ1Jlc2l6ZU9ic2VydmVyJyk7XHJcbmV4cG9ydCBjb25zdCBzY3JvbGxUID0gZ2V0QXBpPG5ldyAoY29uc3RydWN0b3I6IHVua25vd24pID0+IEFuaW1hdGlvblRpbWVsaW5lPignU2Nyb2xsVGltZWxpbmUnKTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xyXG5pbXBvcnQgdHlwZSB7IFBsYWluT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XHJcblxyXG5leHBvcnQgY29uc3QgaXNVbmRlZmluZWQgPSAob2JqOiBhbnkpOiBvYmogaXMgdW5kZWZpbmVkID0+IG9iaiA9PT0gdW5kZWZpbmVkO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzTnVsbCA9IChvYmo6IGFueSk6IG9iaiBpcyBudWxsID0+IG9iaiA9PT0gbnVsbDtcclxuXHJcbmV4cG9ydCBjb25zdCB0eXBlID0gKG9iajogYW55KTogc3RyaW5nID0+XHJcbiAgaXNVbmRlZmluZWQob2JqKSB8fCBpc051bGwob2JqKVxyXG4gICAgPyBgJHtvYmp9YFxyXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXHJcbiAgICAgICAgLmNhbGwob2JqKVxyXG4gICAgICAgIC5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKylcXF0kLywgJyQxJylcclxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc051bWJlciA9IChvYmo6IGFueSk6IG9iaiBpcyBudW1iZXIgPT4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcic7XHJcblxyXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSAob2JqOiBhbnkpOiBvYmogaXMgc3RyaW5nID0+IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzQm9vbGVhbiA9IChvYmo6IGFueSk6IG9iaiBpcyBib29sZWFuID0+IHR5cGVvZiBvYmogPT09ICdib29sZWFuJztcclxuXHJcbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKG9iajogYW55KTogb2JqIGlzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55ID0+IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XHJcblxyXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IDxUID0gYW55PihvYmo6IGFueSk6IG9iaiBpcyBBcnJheTxUPiA9PiBBcnJheS5pc0FycmF5KG9iaik7XHJcblxyXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSAob2JqOiBhbnkpOiBvYmogaXMgb2JqZWN0ID0+XHJcbiAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkob2JqKSAmJiAhaXNOdWxsKG9iaik7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYXJyYXkgbGlrZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKiBAcGFyYW0gb2JqIFRoZSBPYmplY3RcclxuICovXHJcbmV4cG9ydCBjb25zdCBpc0FycmF5TGlrZSA9IDxUIGV4dGVuZHMgUGxhaW5PYmplY3QgPSBhbnk+KG9iajogYW55KTogb2JqIGlzIEFycmF5TGlrZTxUPiA9PiB7XHJcbiAgY29uc3QgbGVuZ3RoID0gISFvYmogJiYgb2JqLmxlbmd0aDtcclxuICBjb25zdCBsZW5ndGhDb3JyZWN0Rm9ybWF0ID0gaXNOdW1iZXIobGVuZ3RoKSAmJiBsZW5ndGggPiAtMSAmJiBsZW5ndGggJSAxID09IDA7XHJcblxyXG4gIHJldHVybiBpc0FycmF5KG9iaikgfHwgKCFpc0Z1bmN0aW9uKG9iaikgJiYgbGVuZ3RoQ29ycmVjdEZvcm1hdClcclxuICAgID8gbGVuZ3RoID4gMCAmJiBpc09iamVjdChvYmopXHJcbiAgICAgID8gbGVuZ3RoIC0gMSBpbiBvYmpcclxuICAgICAgOiB0cnVlXHJcbiAgICA6IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgXCJwbGFpblwiIChlLmcuIHsga2V5OiB2YWx1ZSB9KSBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cclxuICogQHBhcmFtIG9iaiBUaGUgT2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzUGxhaW5PYmplY3QgPSA8VCA9IGFueT4ob2JqOiBhbnkpOiBvYmogaXMgUGxhaW5PYmplY3Q8VD4gPT5cclxuICAhIW9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgSFRNTEVsZW1lbnQuXHJcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzSFRNTEVsZW1lbnQgPSAob2JqOiBhbnkpOiBvYmogaXMgSFRNTEVsZW1lbnQgPT4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIEVsZW1lbnQuXHJcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzRWxlbWVudCA9IChvYmo6IGFueSk6IG9iaiBpcyBFbGVtZW50ID0+IG9iaiBpbnN0YW5jZW9mIEVsZW1lbnQ7XHJcbiIsImltcG9ydCB7IG1hdGhNYXgsIHJBRiwgY0FGIH0gZnJvbSAnLi9hbGlhcyc7XHJcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbi8qKlxyXG4gKiBwZXJjZW50OiBjdXJyZW50IHBlcmNlbnQgKDAgLSAxKSxcclxuICogdGltZTogY3VycmVudCB0aW1lIChkdXJhdGlvbiAqIHBlcmNlbnQpLFxyXG4gKiBtaW46IHN0YXJ0IHZhbHVlXHJcbiAqIG1heDogZW5kIHZhbHVlXHJcbiAqIGR1cmF0aW9uOiBkdXJhdGlvbiBpbiBtc1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgRWFzaW5nRm4gPSAoXHJcbiAgcGVyY2VudDogbnVtYmVyLFxyXG4gIHRpbWU6IG51bWJlcixcclxuICBtaW46IG51bWJlcixcclxuICBtYXg6IG51bWJlcixcclxuICBkdXJhdGlvbjogbnVtYmVyXHJcbikgPT4gbnVtYmVyO1xyXG5cclxuY29uc3QgYW5pbWF0aW9uQ3VycmVudFRpbWUgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbmV4cG9ydCBjb25zdCBhbmltYXRlTnVtYmVyID0gKFxyXG4gIGZyb206IG51bWJlcixcclxuICB0bzogbnVtYmVyLFxyXG4gIGR1cmF0aW9uOiBudW1iZXIsXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICBvbkZyYW1lOiAocHJvZ3Jlc3M6IG51bWJlciwgcGVyY2VudDogbnVtYmVyLCBjb21wbGV0ZWQ6IGJvb2xlYW4pID0+IGFueSxcclxuICBlYXNpbmc/OiBFYXNpbmdGbiB8IGZhbHNlXHJcbik6ICgoY29tcGxldGU/OiBib29sZWFuKSA9PiB2b2lkKSA9PiB7XHJcbiAgbGV0IGFuaW1hdGlvbkZyYW1lSWQgPSAwO1xyXG4gIGNvbnN0IHRpbWVTdGFydCA9IGFuaW1hdGlvbkN1cnJlbnRUaW1lKCk7XHJcbiAgY29uc3QgZmluYWxEdXJhdGlvbiA9IG1hdGhNYXgoMCwgZHVyYXRpb24pO1xyXG4gIGNvbnN0IGZyYW1lID0gKGNvbXBsZXRlPzogYm9vbGVhbikgPT4ge1xyXG4gICAgY29uc3QgdGltZU5vdyA9IGFuaW1hdGlvbkN1cnJlbnRUaW1lKCk7XHJcbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IHRpbWVOb3cgLSB0aW1lU3RhcnQ7XHJcbiAgICBjb25zdCBzdG9wQW5pbWF0aW9uID0gdGltZUVsYXBzZWQgPj0gZmluYWxEdXJhdGlvbjtcclxuICAgIGNvbnN0IHBlcmNlbnQgPSBjb21wbGV0ZVxyXG4gICAgICA/IDFcclxuICAgICAgOiAxIC0gKG1hdGhNYXgoMCwgdGltZVN0YXJ0ICsgZmluYWxEdXJhdGlvbiAtIHRpbWVOb3cpIC8gZmluYWxEdXJhdGlvbiB8fCAwKTtcclxuICAgIGNvbnN0IHByb2dyZXNzID1cclxuICAgICAgKHRvIC0gZnJvbSkgKlxyXG4gICAgICAgIChpc0Z1bmN0aW9uKGVhc2luZylcclxuICAgICAgICAgID8gZWFzaW5nKHBlcmNlbnQsIHBlcmNlbnQgKiBmaW5hbER1cmF0aW9uLCAwLCAxLCBmaW5hbER1cmF0aW9uKVxyXG4gICAgICAgICAgOiBwZXJjZW50KSArXHJcbiAgICAgIGZyb207XHJcbiAgICBjb25zdCBhbmltYXRpb25Db21wbGV0ZWQgPSBzdG9wQW5pbWF0aW9uIHx8IHBlcmNlbnQgPT09IDE7XHJcblxyXG4gICAgaWYgKG9uRnJhbWUpIHtcclxuICAgICAgb25GcmFtZShwcm9ncmVzcywgcGVyY2VudCwgYW5pbWF0aW9uQ29tcGxldGVkKTtcclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRpb25GcmFtZUlkID0gYW5pbWF0aW9uQ29tcGxldGVkID8gMCA6IHJBRiEoKCkgPT4gZnJhbWUoKSk7XHJcbiAgfTtcclxuICBmcmFtZSgpO1xyXG4gIHJldHVybiAoY29tcGxldGUpID0+IHtcclxuICAgIGNBRiEoYW5pbWF0aW9uRnJhbWVJZCk7XHJcbiAgICBpZiAoY29tcGxldGUpIHtcclxuICAgICAgZnJhbWUoY29tcGxldGUpO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuaW1wb3J0IHR5cGUgeyBQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xyXG5pbXBvcnQgeyBpc0FycmF5LCBpc0FycmF5TGlrZSwgaXNTdHJpbmcgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbnR5cGUgUnVuRWFjaEl0ZW0gPSAoKC4uLmFyZ3M6IGFueSkgPT4gYW55IHwgYW55W10pIHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCBleHRlbmRzIEFycmF5PHVua25vd24+IHwgUmVhZG9ubHlBcnJheTx1bmtub3duPj4oXHJcbiAgYXJyYXk6IFQsXHJcbiAgY2FsbGJhY2s6IChcclxuICAgIHZhbHVlOiBUIGV4dGVuZHMgQXJyYXk8aW5mZXIgVj4gfCBSZWFkb25seUFycmF5PGluZmVyIFY+ID8gViA6IG5ldmVyLFxyXG4gICAgaW5kZXg6IG51bWJlcixcclxuICAgIHNvdXJjZTogVFxyXG4gICkgPT4gYm9vbGVhbiB8IHVua25vd25cclxuKTogVDtcclxuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCBleHRlbmRzIEFycmF5TGlrZTx1bmtub3duPj4oXHJcbiAgYXJyYXlMaWtlT2JqZWN0OiBULFxyXG4gIGNhbGxiYWNrOiAoXHJcbiAgICB2YWx1ZTogVCBleHRlbmRzIEFycmF5TGlrZTxpbmZlciBWPiA/IFYgOiBuZXZlcixcclxuICAgIGluZGV4OiBudW1iZXIsXHJcbiAgICBzb3VyY2U6IFRcclxuICApID0+IGJvb2xlYW4gfCB1bmtub3duXHJcbik6IFQ7XHJcbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQgZXh0ZW5kcyBQbGFpbk9iamVjdD4oXHJcbiAgb2JqOiBULFxyXG4gIGNhbGxiYWNrOiAodmFsdWU6IGFueSwga2V5OiBzdHJpbmcsIHNvdXJjZTogVCkgPT4gYm9vbGVhbiB8IHVua25vd25cclxuKTogVDtcclxuZXhwb3J0IGZ1bmN0aW9uIGVhY2goXHJcbiAgc291cmNlOiBBcnJheTx1bmtub3duPiB8IEFycmF5TGlrZTx1bmtub3duPiB8IFJlYWRvbmx5QXJyYXk8dW5rbm93bj4gfCBQbGFpbk9iamVjdCxcclxuICBjYWxsYmFjazogKHZhbHVlOiBhbnksIGluZGV4T3JLZXk6IGFueSwgc291cmNlOiBhbnkpID0+IGJvb2xlYW4gfCB1bmtub3duXHJcbik6IEFycmF5PHVua25vd24+IHwgQXJyYXlMaWtlPHVua25vd24+IHwgUmVhZG9ubHlBcnJheTx1bmtub3duPiB8IFNldDx1bmtub3duPiB8IFBsYWluT2JqZWN0IHtcclxuICBpZiAoaXNBcnJheUxpa2Uoc291cmNlKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGNhbGxiYWNrKHNvdXJjZVtpXSwgaSwgc291cmNlKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoc291cmNlKSB7XHJcbiAgICAvLyBjYW50IHVzZSBzdXBwb3J0IGZ1bmMga2V5cyBoZXJlIGR1ZSB0byBjaXJjdWxhciBkZXBcclxuICAgIGVhY2goT2JqZWN0LmtleXMoc291cmNlKSwgKGtleSkgPT4gY2FsbGJhY2soc291cmNlW2tleV0sIGtleSwgc291cmNlKSk7XHJcbiAgfVxyXG4gIHJldHVybiBzb3VyY2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGFzc2VkIGl0ZW0gaXMgaW4gdGhlIHBhc3NlZCBhcnJheSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKiBAcGFyYW0gYXJyIFRoZSBhcnJheS5cclxuICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0uXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGl0ZW0gaXMgaW4gdGhlIGFycmF5LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGluQXJyYXkgPSA8VCA9IGFueT4oYXJyOiBUW10gfCByZWFkb25seSBUW10sIGl0ZW06IFQpOiBib29sZWFuID0+XHJcbiAgYXJyLmluZGV4T2YoaXRlbSkgPj0gMDtcclxuXHJcbi8qKlxyXG4gKiBDb25jYXRzIHR3byBhcnJheXMgYW5kIHJldHVybnMgYW4gbmV3IGFycmF5IHdpdGhvdXQgbW9kaWZ5aW5nIGFueSBvZiB0aGUgcGFzc2VkIGFycmF5cy5cclxuICogQHBhcmFtIGEgQXJyYXkgQS5cclxuICogQHBhcmFtIGIgQXJyYXkgQi5cclxuICogQHJldHVybnMgQSBuZXcgYXJyYXkgd2hpY2ggaGFzIHRoZSBlbnRyaWVzIG9mIGJvdGggYXJyYXlzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IDxUPihhOiBUW10gfCBSZWFkb25seUFycmF5PFQ+LCBiOiBUW10gfCBSZWFkb25seUFycmF5PFQ+KTogVFtdID0+IGEuY29uY2F0KGIpO1xyXG5cclxuLyoqXHJcbiAqIFB1c2hlc2ggYWxsIGdpdmVuIGl0ZW1zIGludG8gdGhlIGdpdmVuIGFycmF5IGFuZCByZXR1cm5zIGl0LlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHRoZSBpdGVtcyBzaGFsbCBiZSBwdXNoZWQgaW50by5cclxuICogQHBhcmFtIGl0ZW1zIFRoZSBpdGVtcyB3aGljaCBzaGFsbCBiZSBwdXNoZWQgaW50byB0aGUgYXJyYXkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcHVzaCA9IDxUPihhcnJheTogVFtdLCBpdGVtczogVCB8IEFycmF5TGlrZTxUPiwgYXJyYXlJc1NpbmdsZUl0ZW0/OiBib29sZWFuKTogVFtdID0+IHtcclxuICBpZiAoIWFycmF5SXNTaW5nbGVJdGVtICYmICFpc1N0cmluZyhpdGVtcykgJiYgaXNBcnJheUxpa2UoaXRlbXMpKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheSwgaXRlbXMgYXMgVFtdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgYXJyYXkucHVzaChpdGVtcyBhcyBUKTtcclxuICB9XHJcbiAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzaGFsbG93LWNvcGllZCBBcnJheSBpbnN0YW5jZSBmcm9tIGFuIGFycmF5LWxpa2Ugb3IgaXRlcmFibGUgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYXJyIFRoZSBvYmplY3QgZnJvbSB3aGljaCB0aGUgYXJyYXkgaW5zdGFuY2Ugc2hhbGwgYmUgY3JlYXRlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBmcm9tID0gPFQgPSBhbnk+KGFycj86IEFycmF5TGlrZTxUPiB8IFNldDxUPikgPT4gQXJyYXkuZnJvbShhcnIgfHwgW10pO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXJyYXkgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBub3QgYW4gYXJyYXksIG9yIHJldHVybnMgdGhlIHZhbHVlIGlmIGl0IGlzLlxyXG4gKiBJZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGFycmF5IGxpa2Ugc3RydWN0dXJlIGFuZCBub3QgYSBzdHJpbmcgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhbiBhcnJheS5cclxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZS5cclxuICogQHJldHVybnMgQW4gYXJyYXkgd2hpY2ggcmVwcmVzZW50cyB0aGUgcGFzc2VkIHZhbHVlKHMpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU9yS2VlcEFycmF5ID0gPFQ+KHZhbHVlOiBUIHwgVFtdIHwgQXJyYXlMaWtlPFQ+KTogVFtdID0+IHtcclxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuICFpc1N0cmluZyh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpID8gZnJvbSh2YWx1ZSkgOiBbdmFsdWVdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHBhc3NlZCBhcnJheSBpcyBlbXB0eS5cclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzRW1wdHlBcnJheSA9IChhcnJheTogYW55W10gfCBudWxsIHwgdW5kZWZpbmVkKTogYm9vbGVhbiA9PiAhIWFycmF5ICYmICFhcnJheS5sZW5ndGg7XHJcblxyXG4vKipcclxuICogRGVkdXBsaWNhdGVzIGFsbCBpdGVtcyBvZiB0aGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgZGVkdXBsaWNhdGVkLlxyXG4gKiBAcmV0dXJucyBUaGUgZGVkdXBsaWNhdGVkIGFycmF5LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlZHVwbGljYXRlQXJyYXkgPSA8VCBleHRlbmRzIGFueVtdIHwgcmVhZG9ubHkgYW55W10+KGFycmF5OiBUKTogVCA9PlxyXG4gIGZyb20obmV3IFNldChhcnJheSkpIGFzIFQ7XHJcblxyXG4vKipcclxuICogQ2FsbHMgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgcGFzc2VkIGFycmF5L3NldCBvZiBmdW5jdGlvbnMuXHJcbiAqIEBwYXJhbSBhcnIgVGhlIGFycmF5IGZpbGxlZCB3aXRoIGZ1bmN0aW9uIHdoaWNoIHNoYWxsIGJlIGNhbGxlZC5cclxuICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3Mgd2l0aCB3aGljaCBlYWNoIGZ1bmN0aW9uIGlzIGNhbGxlZC5cclxuICogQHBhcmFtIGtlZXAgVHJ1ZSB3aGVuIHRoZSBTZXQgLyBhcnJheSBzaG91bGQgbm90IGJlIGNsZWFyZWQgYWZ0ZXJ3YXJkcywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJ1bkVhY2hBbmRDbGVhciA9IChhcnI6IFJ1bkVhY2hJdGVtW10sIGFyZ3M/OiBhbnlbXSwga2VlcD86IGJvb2xlYW4pOiB2b2lkID0+IHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxyXG4gIGNvbnN0IHJ1bkZuID0gKGZuOiBSdW5FYWNoSXRlbSkgPT4gKGZuID8gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzIHx8IFtdKSA6IHRydWUpOyAvLyByZXR1cm4gdHJ1ZSB3aGVuIGZuIGlzIGZhbHN5IHRvIG5vdCBicmVhayB0aGUgbG9vcFxyXG4gIGVhY2goYXJyLCBydW5Gbik7XHJcbiAgaWYgKCFrZWVwKSB7XHJcbiAgICAoYXJyIGFzIGFueVtdKS5sZW5ndGggPSAwO1xyXG4gIH1cclxufTtcclxuIiwiZXhwb3J0IGNvbnN0IHN0clBhZGRpbmdUb3AgPSAncGFkZGluZ1RvcCc7XHJcbmV4cG9ydCBjb25zdCBzdHJQYWRkaW5nUmlnaHQgPSAncGFkZGluZ1JpZ2h0JztcclxuZXhwb3J0IGNvbnN0IHN0clBhZGRpbmdMZWZ0ID0gJ3BhZGRpbmdMZWZ0JztcclxuZXhwb3J0IGNvbnN0IHN0clBhZGRpbmdCb3R0b20gPSAncGFkZGluZ0JvdHRvbSc7XHJcbmV4cG9ydCBjb25zdCBzdHJNYXJnaW5MZWZ0ID0gJ21hcmdpbkxlZnQnO1xyXG5leHBvcnQgY29uc3Qgc3RyTWFyZ2luUmlnaHQgPSAnbWFyZ2luUmlnaHQnO1xyXG5leHBvcnQgY29uc3Qgc3RyTWFyZ2luQm90dG9tID0gJ21hcmdpbkJvdHRvbSc7XHJcbmV4cG9ydCBjb25zdCBzdHJPdmVyZmxvd1ggPSAnb3ZlcmZsb3dYJztcclxuZXhwb3J0IGNvbnN0IHN0ck92ZXJmbG93WSA9ICdvdmVyZmxvd1knO1xyXG5leHBvcnQgY29uc3Qgc3RyV2lkdGggPSAnd2lkdGgnO1xyXG5leHBvcnQgY29uc3Qgc3RySGVpZ2h0ID0gJ2hlaWdodCc7XHJcbmV4cG9ydCBjb25zdCBzdHJWaXNpYmxlID0gJ3Zpc2libGUnO1xyXG5leHBvcnQgY29uc3Qgc3RySGlkZGVuID0gJ2hpZGRlbic7XHJcbmV4cG9ydCBjb25zdCBzdHJTY3JvbGwgPSAnc2Nyb2xsJztcclxuXHJcbmV4cG9ydCBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSAoc3RyOiBzdHJpbmcgfCBudW1iZXIgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGZpbmFsU3RyID0gU3RyaW5nKHN0ciB8fCAnJyk7XHJcbiAgcmV0dXJuIGZpbmFsU3RyID8gZmluYWxTdHJbMF0udG9VcHBlckNhc2UoKSArIGZpbmFsU3RyLnNsaWNlKDEpIDogJyc7XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgV0ggfSBmcm9tICcuLi9kb20vZGltZW5zaW9ucyc7XHJcbmltcG9ydCB0eXBlIHsgWFkgfSBmcm9tICcuLi9kb20vb2Zmc2V0JztcclxuaW1wb3J0IHR5cGUgeyBUUkJMIH0gZnJvbSAnLi4vZG9tL3N0eWxlJztcclxuaW1wb3J0IHR5cGUgeyBQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xyXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnLi9hcnJheSc7XHJcbmltcG9ydCB7IG1hdGhSb3VuZCB9IGZyb20gJy4vYWxpYXMnO1xyXG5pbXBvcnQgeyBzdHJIZWlnaHQsIHN0cldpZHRoIH0gZnJvbSAnLi9zdHJpbmdzJztcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gb2JqZWN0cyBhbmQgcmV0dXJucyB0cnVlIGlmIGFsbCB2YWx1ZXMgb2YgdGhlIHBhc3NlZCBwcm9wIG5hbWVzIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZSBvciBpZiBvbmUgb2YgdGhlIHR3byBvYmplY3QgaXMgZmFsc3kuXHJcbiAqIEBwYXJhbSBhIE9iamVjdCBhLlxyXG4gKiBAcGFyYW0gYiBPYmplY3QgYi5cclxuICogQHBhcmFtIHByb3BzIFRoZSBwcm9wcyB3aGljaCBzaGFsbCBiZSBjb21wYXJlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlcXVhbCA9IDxUIGV4dGVuZHMgUGxhaW5PYmplY3Q+KFxyXG4gIGE6IFQgfCB1bmRlZmluZWQsXHJcbiAgYjogVCB8IHVuZGVmaW5lZCxcclxuICBwcm9wczogQXJyYXk8a2V5b2YgVD4gfCBSZWFkb25seUFycmF5PGtleW9mIFQ+LFxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgcHJvcE11dGF0aW9uPzogKCh2YWx1ZTogYW55KSA9PiBhbnkpIHwgbnVsbCB8IGZhbHNlXHJcbik6IGJvb2xlYW4gPT4ge1xyXG4gIGlmIChhICYmIGIpIHtcclxuICAgIGxldCByZXN1bHQgPSB0cnVlO1xyXG4gICAgZWFjaChwcm9wcywgKHByb3ApID0+IHtcclxuICAgICAgY29uc3QgY29tcGFyZUEgPSBwcm9wTXV0YXRpb24gPyBwcm9wTXV0YXRpb24oYVtwcm9wXSkgOiBhW3Byb3BdO1xyXG4gICAgICBjb25zdCBjb21wYXJlQiA9IHByb3BNdXRhdGlvbiA/IHByb3BNdXRhdGlvbihiW3Byb3BdKSA6IGJbcHJvcF07XHJcbiAgICAgIGlmIChjb21wYXJlQSAhPT0gY29tcGFyZUIpIHtcclxuICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgb2JqZWN0IGEgd2l0aCBvYmplY3QgYiBhbmQgcmV0dXJucyB0cnVlIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBwcm9wZXJ0eSB2YWx1ZXMsIGZhbHNlIG90aGVyd2lzZS5cclxuICogQWxzbyByZXR1cm5zIGZhbHNlIGlmIG9uZSBvZiB0aGUgb2JqZWN0cyBpcyB1bmRlZmluZWQgb3IgbnVsbC5cclxuICogQHBhcmFtIGEgT2JqZWN0IGEuXHJcbiAqIEBwYXJhbSBiIE9iamVjdCBiLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVxdWFsV0ggPSA8VD4oYT86IFBhcnRpYWw8V0g8VD4+LCBiPzogUGFydGlhbDxXSDxUPj4pID0+XHJcbiAgZXF1YWw8UGFydGlhbDxXSDxUPj4+KGEsIGIsIFsndycsICdoJ10pO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIG9iamVjdCBhIHdpdGggb2JqZWN0IGIgYW5kIHJldHVybnMgdHJ1ZSBpZiBib3RoIGhhdmUgdGhlIHNhbWUgcHJvcGVydHkgdmFsdWVzLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqIEFsc28gcmV0dXJucyBmYWxzZSBpZiBvbmUgb2YgdGhlIG9iamVjdHMgaXMgdW5kZWZpbmVkIG9yIG51bGwuXHJcbiAqIEBwYXJhbSBhIE9iamVjdCBhLlxyXG4gKiBAcGFyYW0gYiBPYmplY3QgYi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlcXVhbFhZID0gPFQ+KGE/OiBQYXJ0aWFsPFhZPFQ+PiwgYj86IFBhcnRpYWw8WFk8VD4+KSA9PlxyXG4gIGVxdWFsPFBhcnRpYWw8WFk8VD4+PihhLCBiLCBbJ3gnLCAneSddKTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyBvYmplY3QgYSB3aXRoIG9iamVjdCBiIGFuZCByZXR1cm5zIHRydWUgaWYgYm90aCBoYXZlIHRoZSBzYW1lIHByb3BlcnR5IHZhbHVlcywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKiBBbHNvIHJldHVybnMgZmFsc2UgaWYgb25lIG9mIHRoZSBvYmplY3RzIGlzIHVuZGVmaW5lZCBvciBudWxsLlxyXG4gKiBAcGFyYW0gYSBPYmplY3QgYS5cclxuICogQHBhcmFtIGIgT2JqZWN0IGIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZXF1YWxUUkJMID0gKGE/OiBUUkJMLCBiPzogVFJCTCkgPT4gZXF1YWw8VFJCTD4oYSwgYiwgWyd0JywgJ3InLCAnYicsICdsJ10pO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBET00gUmVjdHMgZm9yIHRoZWlyIGVxdWFsaXR5IG9mIHRoZWlyIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xyXG4gKiBBbHNvIHJldHVybnMgZmFsc2UgaWYgb25lIG9mIHRoZSBET00gUmVjdHMgaXMgdW5kZWZpbmVkIG9yIG51bGwuXHJcbiAqIEBwYXJhbSBhIERPTSBSZWN0IGEuXHJcbiAqIEBwYXJhbSBiIERPTSBSZWN0IGIuXHJcbiAqIEBwYXJhbSByb3VuZCBXaGV0aGVyIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHJvdW5kZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZXF1YWxCQ1JXSCA9IChhPzogRE9NUmVjdCwgYj86IERPTVJlY3QsIHJvdW5kPzogYm9vbGVhbikgPT5cclxuICBlcXVhbDxET01SZWN0PihhLCBiLCBbc3RyV2lkdGgsIHN0ckhlaWdodF0sIHJvdW5kICYmICgodmFsdWUpID0+IG1hdGhSb3VuZCh2YWx1ZSkpKTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xyXG5pbXBvcnQgeyBpc051bWJlciwgaXNGdW5jdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9hcnJheSc7XHJcbmltcG9ydCB7IHJBRiwgY0FGLCBzZXRULCBjbGVhclQgfSBmcm9tICcuL2FsaWFzJztcclxuXHJcbnR5cGUgRGVib3VuY2VyRm4gPSAodGFzazogKCkgPT4gdm9pZCkgPT4gKCkgPT4gdm9pZDtcclxuXHJcbmV4cG9ydCB0eXBlIERlYm91bmNlVGltaW5nID0geyBfZGVib3VuY2VyOiBEZWJvdW5jZXJGbiB9IHwgbnVtYmVyIHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5leHBvcnQgdHlwZSBEZWJvdW5jZUxlYWRpbmcgPSBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGVib3VuY2VPcHRpb25zPEZ1bmN0aW9uVG9EZWJvdW5jZSBleHRlbmRzICguLi5hcmdzOiBhbnkpID0+IGFueT4ge1xyXG4gIC8qKlxyXG4gICAqIFRoZSB0aW1pbmcgZm9yIGRlYm91bmNpbmcuIElmIGZhbHNlLCBudWxsIG9yIHVuZGVmaW5lZCwgbm8gZGVib3VuY2UgaXMgYXBwbGllZC5cclxuICAgKi9cclxuICBfZGVib3VuY2VUaW1pbmc/OiBEZWJvdW5jZVRpbWluZyB8ICgoKSA9PiBEZWJvdW5jZVRpbWluZyk7XHJcbiAgLyoqXHJcbiAgICogVGhlIHRpbWluZyB3aGljaCBkZXRlcm1pbmVzIHdoZW4gdGhlIGRlYm91bmNlZCB3aWxsIGJlIGNhbGxlZCBldmVuIHdoZW4gdGhlIGRlYm91bmNlIHRpbWluZyBkaWQgbm90IGNhbGwgaXQgeWV0LlxyXG4gICAqL1xyXG4gIF9tYXhEZWJvdW5jZVRpbWluZz86IERlYm91bmNlVGltaW5nIHwgKCgpID0+IERlYm91bmNlVGltaW5nKTtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIHRoZSBjYWxsaW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXHJcbiAgICovXHJcbiAgX2xlYWRpbmc/OiBEZWJvdW5jZUxlYWRpbmcgfCAoKCkgPT4gRGVib3VuY2VMZWFkaW5nKTtcclxuICAvKipcclxuICAgKiBGdW5jdGlvbiB3aGljaCBtZXJnZXMgcGFyYW1ldGVycyBmb3IgZWFjaCBjYW5jZWxlZCBkZWJvdW5jZS5cclxuICAgKiBJZiBwYXJhbWV0ZXJzIGNhbid0IGJlIG1lcmdlZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gbnVsbCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgdGhlIG1lcmdlZCBwYXJhbWV0ZXJzLlxyXG4gICAqL1xyXG4gIF9tZXJnZVBhcmFtcz86IChcclxuICAgIHByZXY6IFBhcmFtZXRlcnM8RnVuY3Rpb25Ub0RlYm91bmNlPixcclxuICAgIGN1cnI6IFBhcmFtZXRlcnM8RnVuY3Rpb25Ub0RlYm91bmNlPlxyXG4gICkgPT4gUGFyYW1ldGVyczxGdW5jdGlvblRvRGVib3VuY2U+IHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERlYm91bmNlZDxGdW5jdGlvblRvRGVib3VuY2UgZXh0ZW5kcyAoLi4uYXJnczogYW55KSA9PiBhbnk+IHtcclxuICAoLi4uYXJnczogUGFyYW1ldGVyczxGdW5jdGlvblRvRGVib3VuY2U+KTogUmV0dXJuVHlwZTxGdW5jdGlvblRvRGVib3VuY2U+O1xyXG4gIF9mbHVzaCgpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYmluZCA9IDxBIGV4dGVuZHMgYW55W10sIEIgZXh0ZW5kcyBhbnlbXSwgUj4oXHJcbiAgZm46ICguLi5hcmdzOiBbLi4uQSwgLi4uQl0pID0+IFIsXHJcbiAgLi4uYXJnczogQVxyXG4pOiAoKC4uLmFyZ3M6IEIpID0+IFIpID0+IGZuLmJpbmQoMCwgLi4uYXJncyk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHRpbWVvdXQgYW5kIGNsZWFydGltZW91dCB0dXBsZS4gVGhlIHRpbWVvdXQgZnVuY3Rpb24gYWx3YXlzIGNsZWFycyB0aGUgcHJldmlvdXNseSBjcmVhdGVkIHRpbWVvdXQgYmVmb3JlIGl0IHJ1bnMuXHJcbiAqIEBwYXJhbSB0aW1lb3V0IFRoZSB0aW1lb3V0IGluIG1zLiBJZiBubyB0aW1lb3V0IChvciAwKSBpcyBwYXNzZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlzIHVzZWQgaW5zdGVhZCBvZiBzZXRUaW1lb3V0LlxyXG4gKiBAcmV0dXJucyBBIHR1cGxlIHdpdGggdGhlIHRpbWVvdXQgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHZhbHVlIGFuZCB0aGUgY2xlYXJUaW1lb3V0IGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgdmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VsZkNsZWFyVGltZW91dCA9ICh0aW1lb3V0PzogbnVtYmVyIHwgKCgpID0+IG51bWJlcikpID0+IHtcclxuICBsZXQgaWQ6IG51bWJlcjtcclxuICBjb25zdCBzZXRURm4gPSB0aW1lb3V0ID8gc2V0VCA6IHJBRiE7XHJcbiAgY29uc3QgY2xlYXJURm4gPSB0aW1lb3V0ID8gY2xlYXJUIDogY0FGITtcclxuICByZXR1cm4gW1xyXG4gICAgKGNhbGxiYWNrOiAoKSA9PiBhbnkpID0+IHtcclxuICAgICAgY2xlYXJURm4oaWQpO1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgaWQgPSBzZXRURm4oKCkgPT4gY2FsbGJhY2soKSwgaXNGdW5jdGlvbih0aW1lb3V0KSA/IHRpbWVvdXQoKSA6IHRpbWVvdXQpO1xyXG4gICAgfSxcclxuICAgICgpID0+IGNsZWFyVEZuKGlkKSxcclxuICBdIGFzIFt0aW1lb3V0OiAoY2FsbGJhY2s6ICgpID0+IGFueSkgPT4gdm9pZCwgY2xlYXI6ICgpID0+IHZvaWRdO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0RGVib3VuY2VyID0gKFxyXG4gIGRlYm91bmNlVGltaW5nOiBEZWJvdW5jZVRpbWluZyB8ICgoKSA9PiBEZWJvdW5jZVRpbWluZylcclxuKTogRGVib3VuY2VyRm4gfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkID0+IHtcclxuICBjb25zdCBkZWJvdW5jZVRpbWluZ1Jlc3VsdCA9IGlzRnVuY3Rpb24oZGVib3VuY2VUaW1pbmcpID8gZGVib3VuY2VUaW1pbmcoKSA6IGRlYm91bmNlVGltaW5nO1xyXG4gIGlmIChpc051bWJlcihkZWJvdW5jZVRpbWluZ1Jlc3VsdCkpIHtcclxuICAgIGNvbnN0IHNjaGVkdWxlID0gZGVib3VuY2VUaW1pbmdSZXN1bHQgPyBzZXRUISA6IHJBRiE7XHJcbiAgICBjb25zdCBjbGVhciA9IGRlYm91bmNlVGltaW5nUmVzdWx0ID8gY2xlYXJUIDogY0FGO1xyXG4gICAgcmV0dXJuICh0YXNrKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNjaGVkdWxlIShcclxuICAgICAgICAoKSA9PiB0YXNrKCksXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBkZWJvdW5jZVRpbWluZ1Jlc3VsdFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGNsZWFyISh0aW1lb3V0SWQpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkZWJvdW5jZVRpbWluZ1Jlc3VsdCAmJiBkZWJvdW5jZVRpbWluZ1Jlc3VsdC5fZGVib3VuY2VyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlYm91bmNlcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gZWl0aGVyIHdpdGggYSB0aW1lb3V0IG9yIGEgYW5pbWF0aW9uIGZyYW1lLlxyXG4gKiBAcGFyYW0gZnVuY3Rpb25Ub0RlYm91bmNlIFRoZSBmdW5jdGlvbiB3aGljaCBzaGFsbCBiZSBkZWJvdW5jZWQuXHJcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGRlYm91bmNpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGVib3VuY2UgPSA8RnVuY3Rpb25Ub0RlYm91bmNlIGV4dGVuZHMgKC4uLmFyZ3M6IGFueSkgPT4gYW55PihcclxuICBmdW5jdGlvblRvRGVib3VuY2U6IEZ1bmN0aW9uVG9EZWJvdW5jZSxcclxuICBvcHRpb25zPzogRGVib3VuY2VPcHRpb25zPEZ1bmN0aW9uVG9EZWJvdW5jZT5cclxuKTogRGVib3VuY2VkPEZ1bmN0aW9uVG9EZWJvdW5jZT4gPT4ge1xyXG4gIGNvbnN0IHtcclxuICAgIF9kZWJvdW5jZVRpbWluZzogX3RpbWVvdXQsXHJcbiAgICBfbWF4RGVib3VuY2VUaW1pbmc6IF9tYXhEZWxheSxcclxuICAgIF9sZWFkaW5nLFxyXG4gICAgX21lcmdlUGFyYW1zLFxyXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xyXG4gIGxldCBjYW5jZWxNYXhUaW1lb3V0RGVib3VuY2VyOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XHJcbiAgbGV0IGNhbmNlbFRpbWVvdXREZWJvdW5kZXI6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcclxuICBsZXQgcHJldkFyZ3VtZW50czogUGFyYW1ldGVyczxGdW5jdGlvblRvRGVib3VuY2U+IHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICBsZXQgbGVhZGluZ0ludm9rZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcblxyXG4gIGNvbnN0IGludm9rZUZ1bmN0aW9uVG9EZWJvdW5jZSA9IGZ1bmN0aW9uIChhcmdzOiBQYXJhbWV0ZXJzPEZ1bmN0aW9uVG9EZWJvdW5jZT4pIHtcclxuICAgIGlmIChjYW5jZWxUaW1lb3V0RGVib3VuZGVyKSB7XHJcbiAgICAgIGNhbmNlbFRpbWVvdXREZWJvdW5kZXIoKTtcclxuICAgIH1cclxuICAgIGlmIChjYW5jZWxNYXhUaW1lb3V0RGVib3VuY2VyKSB7XHJcbiAgICAgIGNhbmNlbE1heFRpbWVvdXREZWJvdW5jZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBsZWFkaW5nSW52b2tlZCA9IGNhbmNlbFRpbWVvdXREZWJvdW5kZXIgPSBjYW5jZWxNYXhUaW1lb3V0RGVib3VuY2VyID0gcHJldkFyZ3VtZW50cyA9IHVuZGVmaW5lZDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgZnVuY3Rpb25Ub0RlYm91bmNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IG1lcmdlUGFybXMgPSAoXHJcbiAgICBjdXJyOiBQYXJhbWV0ZXJzPEZ1bmN0aW9uVG9EZWJvdW5jZT5cclxuICApOiBQYXJhbWV0ZXJzPEZ1bmN0aW9uVG9EZWJvdW5jZT4gfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWQgPT5cclxuICAgIF9tZXJnZVBhcmFtcyAmJiBwcmV2QXJndW1lbnRzID8gX21lcmdlUGFyYW1zKHByZXZBcmd1bWVudHMsIGN1cnIpIDogY3VycjtcclxuXHJcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKGNhbmNlbFRpbWVvdXREZWJvdW5kZXIgJiYgcHJldkFyZ3VtZW50cykge1xyXG4gICAgICBpbnZva2VGdW5jdGlvblRvRGVib3VuY2UobWVyZ2VQYXJtcyhwcmV2QXJndW1lbnRzKSB8fCBwcmV2QXJndW1lbnRzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBkZWJvdW5jZWRGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcclxuICAgIGNvbnN0IGFyZ3M6IFBhcmFtZXRlcnM8RnVuY3Rpb25Ub0RlYm91bmNlPiA9IGZyb20oYXJndW1lbnRzKSBhcyBQYXJhbWV0ZXJzPEZ1bmN0aW9uVG9EZWJvdW5jZT47XHJcbiAgICBjb25zdCB0aW1lb3V0RGVib3VuY2VyID0gZ2V0RGVib3VuY2VyKF90aW1lb3V0KTtcclxuXHJcbiAgICBpZiAodGltZW91dERlYm91bmNlcikge1xyXG4gICAgICBjb25zdCBsZWFkaW5nID0gdHlwZW9mIF9sZWFkaW5nID09PSAnZnVuY3Rpb24nID8gX2xlYWRpbmcoKSA6IF9sZWFkaW5nO1xyXG4gICAgICBjb25zdCBtYXhEZWxheURlYm91bmNlciA9IGdldERlYm91bmNlcihfbWF4RGVsYXkpO1xyXG4gICAgICBjb25zdCBtZXJnZVBhcmFtc1Jlc3VsdCA9IG1lcmdlUGFybXMoYXJncyk7XHJcbiAgICAgIGNvbnN0IGludm9rZWRBcmdzID0gbWVyZ2VQYXJhbXNSZXN1bHQgfHwgYXJncztcclxuICAgICAgY29uc3QgYm91bmRJbnZva2UgPSBpbnZva2VGdW5jdGlvblRvRGVib3VuY2UuYmluZCgwLCBpbnZva2VkQXJncyk7XHJcblxyXG4gICAgICBpZiAoY2FuY2VsVGltZW91dERlYm91bmRlcikge1xyXG4gICAgICAgIGNhbmNlbFRpbWVvdXREZWJvdW5kZXIoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxlYWRpbmcgJiYgIWxlYWRpbmdJbnZva2VkKSB7XHJcbiAgICAgICAgYm91bmRJbnZva2UoKTtcclxuICAgICAgICBsZWFkaW5nSW52b2tlZCA9IHRydWU7XHJcbiAgICAgICAgY2FuY2VsVGltZW91dERlYm91bmRlciA9IHRpbWVvdXREZWJvdW5jZXIoKCkgPT4gKGxlYWRpbmdJbnZva2VkID0gdW5kZWZpbmVkKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FuY2VsVGltZW91dERlYm91bmRlciA9IHRpbWVvdXREZWJvdW5jZXIoYm91bmRJbnZva2UpO1xyXG5cclxuICAgICAgICBpZiAobWF4RGVsYXlEZWJvdW5jZXIgJiYgIWNhbmNlbE1heFRpbWVvdXREZWJvdW5jZXIpIHtcclxuICAgICAgICAgIGNhbmNlbE1heFRpbWVvdXREZWJvdW5jZXIgPSBtYXhEZWxheURlYm91bmNlcihmbHVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmV2QXJndW1lbnRzID0gaW52b2tlZEFyZ3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbnZva2VGdW5jdGlvblRvRGVib3VuY2UoYXJncyk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBkZWJvdW5jZWRGbi5fZmx1c2ggPSBmbHVzaDtcclxuXHJcbiAgcmV0dXJuIGRlYm91bmNlZEZuIGFzIERlYm91bmNlZDxGdW5jdGlvblRvRGVib3VuY2U+O1xyXG59O1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXHJcbmltcG9ydCB0eXBlIHsgUGxhaW5PYmplY3QgfSBmcm9tICcuLi8uLi90eXBpbmdzJztcclxuaW1wb3J0IHsgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNQbGFpbk9iamVjdCwgaXNOdWxsIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IGVhY2ggfSBmcm9tICcuL2FycmF5JztcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCBvYmplY3QgaGFzIGEgcHJvcGVydHkgd2l0aCB0aGUgcGFzc2VkIG5hbWUuXHJcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdC5cclxuICogQHBhcmFtIHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGhhc093blByb3BlcnR5ID0gKG9iajogYW55LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpOiBib29sZWFuID0+XHJcbiAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIGVudW1lcmFibGUgc3RyaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgYW4gb2JqZWN0LlxyXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3Qgb2Ygd2hpY2ggdGhlIHByb3BlcnRpZXMgc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qga2V5cyA9IChvYmo6IGFueSk6IEFycmF5PHN0cmluZz4gPT4gKG9iaiA/IE9iamVjdC5rZXlzKG9iaikgOiBbXSk7XHJcblxyXG50eXBlIEFzc2lnbkRlZXAgPSB7XHJcbiAgPFQsIFU+KHRhcmdldDogVCwgb2JqZWN0MTogVSk6IFQgJiBVO1xyXG4gIDxULCBVLCBWPih0YXJnZXQ6IFQsIG9iamVjdDE6IFUsIG9iamVjdDI6IFYpOiBUICYgVSAmIFY7XHJcbiAgPFQsIFUsIFYsIFc+KHRhcmdldDogVCwgb2JqZWN0MTogVSwgb2JqZWN0MjogViwgb2JqZWN0MzogVyk6IFQgJiBVICYgViAmIFc7XHJcbiAgPFQsIFUsIFYsIFcsIFg+KHRhcmdldDogVCwgb2JqZWN0MTogVSwgb2JqZWN0MjogViwgb2JqZWN0MzogVywgb2JqZWN0NDogWCk6IFQgJiBVICYgViAmIFcgJiBYO1xyXG4gIDxULCBVLCBWLCBXLCBYLCBZPihcclxuICAgIHRhcmdldDogVCxcclxuICAgIG9iamVjdDE6IFUsXHJcbiAgICBvYmplY3QyOiBWLFxyXG4gICAgb2JqZWN0MzogVyxcclxuICAgIG9iamVjdDQ6IFgsXHJcbiAgICBvYmplY3Q1OiBZXHJcbiAgKTogVCAmIFUgJiBWICYgVyAmIFggJiBZO1xyXG4gIDxULCBVLCBWLCBXLCBYLCBZLCBaPihcclxuICAgIHRhcmdldDogVCxcclxuICAgIG9iamVjdDE/OiBVLFxyXG4gICAgb2JqZWN0Mj86IFYsXHJcbiAgICBvYmplY3QzPzogVyxcclxuICAgIG9iamVjdDQ/OiBYLFxyXG4gICAgb2JqZWN0NT86IFksXHJcbiAgICBvYmplY3Q2PzogWlxyXG4gICk6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XHJcbn07XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvY29yZS5qcyNMMTE2XHJcbmV4cG9ydCBjb25zdCBhc3NpZ25EZWVwOiBBc3NpZ25EZWVwID0gPFQsIFUsIFYsIFcsIFgsIFksIFo+KFxyXG4gIHRhcmdldDogVCxcclxuICBvYmplY3QxPzogVSxcclxuICBvYmplY3QyPzogVixcclxuICBvYmplY3QzPzogVyxcclxuICBvYmplY3Q0PzogWCxcclxuICBvYmplY3Q1PzogWSxcclxuICBvYmplY3Q2PzogWlxyXG4pOiBUICYgVSAmIFYgJiBXICYgWCAmIFkgJiBaID0+IHtcclxuICBjb25zdCBzb3VyY2VzOiBBcnJheTxhbnk+ID0gW29iamVjdDEsIG9iamVjdDIsIG9iamVjdDMsIG9iamVjdDQsIG9iamVjdDUsIG9iamVjdDZdO1xyXG5cclxuICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcclxuICBpZiAoKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnIHx8IGlzTnVsbCh0YXJnZXQpKSAmJiAhaXNGdW5jdGlvbih0YXJnZXQpKSB7XHJcbiAgICB0YXJnZXQgPSB7fSBhcyBUO1xyXG4gIH1cclxuXHJcbiAgZWFjaChzb3VyY2VzLCAoc291cmNlKSA9PiB7XHJcbiAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XHJcbiAgICBlYWNoKHNvdXJjZSwgKF8sIGtleSkgPT4ge1xyXG4gICAgICBjb25zdCBjb3B5OiBhbnkgPSBzb3VyY2Vba2V5XTtcclxuXHJcbiAgICAgIC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cclxuICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxyXG4gICAgICBpZiAodGFyZ2V0ID09PSBjb3B5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNvcHlJc0FycmF5ID0gaXNBcnJheShjb3B5KTtcclxuXHJcbiAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xyXG4gICAgICBpZiAoY29weSAmJiBpc1BsYWluT2JqZWN0KGNvcHkpKSB7XHJcbiAgICAgICAgY29uc3Qgc3JjID0gdGFyZ2V0W2tleSBhcyBrZXlvZiBUXTtcclxuICAgICAgICBsZXQgY2xvbmU6IGFueSA9IHNyYztcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXHJcbiAgICAgICAgaWYgKGNvcHlJc0FycmF5ICYmICFpc0FycmF5KHNyYykpIHtcclxuICAgICAgICAgIGNsb25lID0gW107XHJcbiAgICAgICAgfSBlbHNlIGlmICghY29weUlzQXJyYXkgJiYgIWlzUGxhaW5PYmplY3Qoc3JjKSkge1xyXG4gICAgICAgICAgY2xvbmUgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxyXG4gICAgICAgIHRhcmdldFtrZXkgYXMga2V5b2YgVF0gPSBhc3NpZ25EZWVwKGNsb25lLCBjb3B5KSBhcyBhbnk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGFyZ2V0W2tleSBhcyBrZXlvZiBUXSA9IGNvcHlJc0FycmF5ID8gY29weS5zbGljZSgpIDogY29weTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XHJcbiAgcmV0dXJuIHRhcmdldCBhcyBhbnk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyA9IDxUIGV4dGVuZHMgUGxhaW5PYmplY3Q+KHRhcmdldDogVCwgZGVlcD86IGJvb2xlYW4pOiBUID0+XHJcbiAgZWFjaChhc3NpZ25EZWVwKHt9LCB0YXJnZXQpLCAodmFsdWUsIGtleSwgY29weSkgPT4ge1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZGVsZXRlIGNvcHlba2V5XTtcclxuICAgIH0gZWxzZSBpZiAoZGVlcCAmJiB2YWx1ZSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICBjb3B5W2tleSBhcyBrZXlvZiB0eXBlb2YgY29weV0gPSByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKHZhbHVlLCBkZWVwKSBhcyBhbnk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cclxuICogQHBhcmFtIG9iaiBUaGUgT2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzRW1wdHlPYmplY3QgPSAob2JqOiBhbnkpOiBib29sZWFuID0+ICFrZXlzKG9iaikubGVuZ3RoO1xyXG4iLCJleHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xyXG4iLCJpbXBvcnQgeyBtYXRoTWF4LCBtYXRoTWluIH0gZnJvbSAnLi9hbGlhcyc7XHJcblxyXG4vKipcclxuICogQ2FwcyB0aGUgcGFzc2VkIG51bWJlciBiZXR3ZWVuIHRoZSBgbWluYCBhbmQgYG1heGAgYm91bmRzLlxyXG4gKiBAcGFyYW0gbWluIFRoZSBtaW4gYm91bmQuXHJcbiAqIEBwYXJhbSBtYXggVGhlIG1heCBib3VuZC5cclxuICogQHBhcmFtIG51bWJlciBUaGUgbnVtYmVyIHRvIGJlIGNhcHBlZC5cclxuICogQHJldHVybnMgVGhlIGNhcHBlZCBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjYXBOdW1iZXIgPSAobWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBudW1iZXI6IG51bWJlcikgPT5cclxuICBtYXRoTWF4KG1pbiwgbWF0aE1pbihtYXgsIG51bWJlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IEhUTUxFbGVtZW50VGFyZ2V0IH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IGJpbmQsIGRlZHVwbGljYXRlQXJyYXksIGVhY2gsIGZyb20sIGlzQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XHJcblxyXG5leHBvcnQgdHlwZSBBdHRyaWJ1dGVFbGVtZW50VGFyZ2V0ID0gSFRNTEVsZW1lbnRUYXJnZXQgfCBFbGVtZW50O1xyXG5cclxuZXhwb3J0IHR5cGUgRG9tVG9rZW5zID0gc3RyaW5nIHwgc3RyaW5nW10gfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldERvbVRva2Vuc0FycmF5ID0gKHRva2VuczogRG9tVG9rZW5zKSA9PlxyXG4gIGRlZHVwbGljYXRlQXJyYXkoKGlzQXJyYXkodG9rZW5zKSA/IHRva2VucyA6ICh0b2tlbnMgfHwgJycpLnNwbGl0KCcgJykpLmZpbHRlcigodG9rZW4pID0+IHRva2VuKSk7XHJcblxyXG4vKipcclxuICogR2V0cyBhIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQgb2Ygd2hpY2ggdGhlIGF0dHJpYnV0ZSBzaGFsbCBiZSBnZXQuXHJcbiAqIEBwYXJhbSBhdHRyTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgd2hpY2ggc2hhbGwgYmUgZ2V0LlxyXG4gKiBAcmV0dXJucyBUaGUgYXR0cmlidXRlIHZhbHVlIG9yIGBudWxsYCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHNldCBvciBgZmFsc2VgIGlmIHRoZSBlbGVtZW50IGlzIHVuZGVmaW5lZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRBdHRyID0gKGVsbTogQXR0cmlidXRlRWxlbWVudFRhcmdldCwgYXR0ck5hbWU6IHN0cmluZykgPT5cclxuICBlbG0gJiYgZWxtLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZXhpc3RzIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gKiBAcGFyYW0gZWxtIFRoZSBlbGVtZW50LlxyXG4gKiBAcGFyYW0gYXR0ck5hbWUgVGhlIGF0dHJpYnV0ZS5cclxuICogQHJldHVybnMgQSBUcnV0aHkgdmFsdWUgaW5kaWNhdGVzIGEgcHJlc2VudCBhdHRydWJ0ZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBoYXNBdHRyID0gKGVsbTogQXR0cmlidXRlRWxlbWVudFRhcmdldCwgYXR0ck5hbWU6IHN0cmluZykgPT5cclxuICBlbG0gJiYgZWxtLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSk7XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudCBvZiB3aGljaCB0aGUgYXR0cmlidXRlcyBzaGFsbCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gYXR0ck5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lcyBzZXBhcmF0ZWQgYnkgYSBzcGFjZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXRBdHRycyA9IChcclxuICBlbG06IEF0dHJpYnV0ZUVsZW1lbnRUYXJnZXQsXHJcbiAgYXR0ck5hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSxcclxuICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkXHJcbikgPT4ge1xyXG4gIGVhY2goZ2V0RG9tVG9rZW5zQXJyYXkoYXR0ck5hbWVzKSwgKGF0dHJOYW1lKSA9PiB7XHJcbiAgICBpZiAoZWxtKSB7XHJcbiAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIFN0cmluZyh2YWx1ZSB8fCAnJykpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudCBvZiB3aGljaCB0aGUgYXR0cmlidXRlIHNoYWxsIGJlIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSBhdHRyTmFtZSBUaGUgYXR0cmlidXRlIG5hbWVzIHNlcGFyYXRlZCBieSBhIHNwYWNlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbW92ZUF0dHJzID0gKGVsbTogQXR0cmlidXRlRWxlbWVudFRhcmdldCwgYXR0ck5hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHZvaWQgPT4ge1xyXG4gIGVhY2goZ2V0RG9tVG9rZW5zQXJyYXkoYXR0ck5hbWVzKSwgKGF0dHJOYW1lKSA9PiBlbG0gJiYgZWxtLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRvbVRva2VuTGlzdEF0dHIgPSAoZWxtOiBBdHRyaWJ1dGVFbGVtZW50VGFyZ2V0LCBhdHRyTmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgY29uc3QgaW5pdGlhbEFyciA9IGdldERvbVRva2Vuc0FycmF5KGdldEF0dHIoZWxtLCBhdHRyTmFtZSkpO1xyXG4gIGNvbnN0IHNldEVsbUF0dHIgPSBiaW5kKHNldEF0dHJzLCBlbG0sIGF0dHJOYW1lKTtcclxuICBjb25zdCBkb21Ub2tlbkxpc3RPcGVyYXRpb24gPSAob3BlcmF0aW9uVG9rZW5zOiBEb21Ub2tlbnMsIG9wZXJhdGlvbjogJ2FkZCcgfCAnZGVsZXRlJykgPT4ge1xyXG4gICAgY29uc3QgaW5pdGlhbEFyclNldCA9IG5ldyBTZXQoaW5pdGlhbEFycik7XHJcbiAgICBlYWNoKGdldERvbVRva2Vuc0FycmF5KG9wZXJhdGlvblRva2VucyksICh0b2tlbikgPT4ge1xyXG4gICAgICBpbml0aWFsQXJyU2V0W29wZXJhdGlvbl0odG9rZW4pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZnJvbShpbml0aWFsQXJyU2V0KS5qb2luKCcgJyk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIF9yZW1vdmU6IChyZW1vdmVUb2tlbnM6IERvbVRva2VucykgPT4gc2V0RWxtQXR0cihkb21Ub2tlbkxpc3RPcGVyYXRpb24ocmVtb3ZlVG9rZW5zLCAnZGVsZXRlJykpLFxyXG4gICAgX2FkZDogKGFkZFRva2VuczogRG9tVG9rZW5zKSA9PiBzZXRFbG1BdHRyKGRvbVRva2VuTGlzdE9wZXJhdGlvbihhZGRUb2tlbnMsICdhZGQnKSksXHJcbiAgICBfaGFzOiAoaGFzVG9rZW5zOiBEb21Ub2tlbnMpID0+IHtcclxuICAgICAgY29uc3QgdG9rZW5TZXQgPSBnZXREb21Ub2tlbnNBcnJheShoYXNUb2tlbnMpO1xyXG4gICAgICByZXR1cm4gdG9rZW5TZXQucmVkdWNlKFxyXG4gICAgICAgIChib29sZWFuLCB0b2tlbikgPT4gYm9vbGVhbiAmJiBpbml0aWFsQXJyLmluY2x1ZGVzKHRva2VuKSxcclxuICAgICAgICB0b2tlblNldC5sZW5ndGggPiAwXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogVHJlYXRzIHRoZSBnaXZlbiBhdHRyaWJ1dGUgbGlrZSB0aGUgXCJjbGFzc1wiIGF0dHJpYnV0ZSBhbmQgcmVtb3ZlcyB0aGUgZ2l2ZW4gdmFsdWUgZnJvbSBpdC5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudC5cclxuICogQHBhcmFtIGF0dHJOYW1lIFRoZSBhdHRyaWJ1dGVOYW1lIHRvIHdoaWNoIHRoZSB2YWx1ZSBzaGFsbCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIHNoYWxsIGJlIHJlbW92ZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVtb3ZlQXR0ckNsYXNzID0gKFxyXG4gIGVsbTogQXR0cmlidXRlRWxlbWVudFRhcmdldCxcclxuICBhdHRyTmFtZTogc3RyaW5nLFxyXG4gIHZhbHVlOiBEb21Ub2tlbnNcclxuKTogKCgpID0+IHZvaWQpID0+IHtcclxuICBkb21Ub2tlbkxpc3RBdHRyKGVsbSwgYXR0ck5hbWUpLl9yZW1vdmUodmFsdWUpO1xyXG4gIHJldHVybiBiaW5kKGFkZEF0dHJDbGFzcywgZWxtLCBhdHRyTmFtZSwgdmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyZWF0cyB0aGUgZ2l2ZW4gYXR0cmlidXRlIGxpa2UgdGhlIFwiY2xhc3NcIiBhdHRyaWJ1dGUgYW5kIGFkZHMgdmFsdWUgdG8gaXQuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBhdHRyTmFtZSBUaGUgYXR0cmlidXRlTmFtZSB0byB3aGljaCB0aGUgdmFsdWUgc2hhbGwgYmUgYWRkZWQuXHJcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggc2hhbGwgYmUgYWRkZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWRkQXR0ckNsYXNzID0gKFxyXG4gIGVsbTogQXR0cmlidXRlRWxlbWVudFRhcmdldCxcclxuICBhdHRyTmFtZTogc3RyaW5nLFxyXG4gIHZhbHVlOiBEb21Ub2tlbnNcclxuKTogKCgpID0+IHZvaWQpID0+IHtcclxuICBkb21Ub2tlbkxpc3RBdHRyKGVsbSwgYXR0ck5hbWUpLl9hZGQodmFsdWUpO1xyXG4gIHJldHVybiBiaW5kKHJlbW92ZUF0dHJDbGFzcywgZWxtLCBhdHRyTmFtZSwgdmFsdWUpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFkZFJlbW92ZUF0dHJDbGFzcyA9IChcclxuICBlbG06IEF0dHJpYnV0ZUVsZW1lbnRUYXJnZXQsXHJcbiAgYXR0ck5hbWU6IHN0cmluZyxcclxuICB2YWx1ZTogRG9tVG9rZW5zLFxyXG4gIGFkZD86IGJvb2xlYW5cclxuKSA9PiAoYWRkID8gYWRkQXR0ckNsYXNzIDogcmVtb3ZlQXR0ckNsYXNzKShlbG0sIGF0dHJOYW1lLCB2YWx1ZSk7XHJcblxyXG4vKipcclxuICogVHJlYXRzIHRoZSBnaXZlbiBhdHRyaWJ1dGUgbGlrZSB0aGUgXCJjbGFzc1wiIGF0dHJpYnV0ZSBhbmQgY2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBpbiBpdC5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudC5cclxuICogQHBhcmFtIGF0dHJOYW1lIFRoZSBhdHRyaWJ1dGVOYW1lIGZyb20gd2hpY2ggdGhlIGNvbnRlbnQgc2hhbGwgYmUgY2hlY2tlZC5cclxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZS5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZ2l2ZW4gYXR0cmlidXRlIGhhcyB0aGUgdmFsdWUgaW4gaXQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBoYXNBdHRyQ2xhc3MgPSAoXHJcbiAgZWxtOiBBdHRyaWJ1dGVFbGVtZW50VGFyZ2V0LFxyXG4gIGF0dHJOYW1lOiBzdHJpbmcsXHJcbiAgdmFsdWU6IERvbVRva2Vuc1xyXG4pOiBib29sZWFuID0+IGRvbVRva2VuTGlzdEF0dHIoZWxtLCBhdHRyTmFtZSkuX2hhcyh2YWx1ZSk7XHJcbiIsImltcG9ydCB0eXBlIHsgQXR0cmlidXRlRWxlbWVudFRhcmdldCwgRG9tVG9rZW5zIH0gZnJvbSAnLi9hdHRyaWJ1dGUnO1xyXG5pbXBvcnQgeyBlYWNoLCBmcm9tIH0gZnJvbSAnLi4vdXRpbHMvYXJyYXknO1xyXG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb24nO1xyXG5pbXBvcnQgeyBkb21Ub2tlbkxpc3RBdHRyIH0gZnJvbSAnLi9hdHRyaWJ1dGUnO1xyXG5cclxuY29uc3QgY3JlYXRlRG9tVG9rZW5MaXN0Q2xhc3MgPSAoZWxtOiBBdHRyaWJ1dGVFbGVtZW50VGFyZ2V0KSA9PiBkb21Ub2tlbkxpc3RBdHRyKGVsbSwgJ2NsYXNzJyk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgdGhlIGdpdmVuIGNsYXNzIG5hbWUocykuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUocykuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaGFzQ2xhc3MgPSAoZWxtOiBBdHRyaWJ1dGVFbGVtZW50VGFyZ2V0LCBjbGFzc05hbWU6IERvbVRva2Vucyk6IGJvb2xlYW4gPT5cclxuICBjcmVhdGVEb21Ub2tlbkxpc3RDbGFzcyhlbG0pLl9oYXMoY2xhc3NOYW1lKTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBjbGFzcyBuYW1lKHMpIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUocykgd2hpY2ggc2hhbGwgYmUgcmVtb3ZlZC4gKHNlcGFyYXRlZCBieSBzcGFjZXMpXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3MgPSAoZWxtOiBBdHRyaWJ1dGVFbGVtZW50VGFyZ2V0LCBjbGFzc05hbWU6IERvbVRva2Vucyk6IHZvaWQgPT4ge1xyXG4gIGNyZWF0ZURvbVRva2VuTGlzdENsYXNzKGVsbSkuX3JlbW92ZShjbGFzc05hbWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgdGhlIGdpdmVuIGNsYXNzIG5hbWUocykgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUocykgd2hpY2ggc2hhbGwgYmUgYWRkZWQuIChzZXBhcmF0ZWQgYnkgc3BhY2VzKVxyXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHdoaWNoIHJlbW92ZXMgdGhlIGFkZGVkIGNsYXNzIG5hbWUocykuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWRkQ2xhc3MgPSAoZWxtOiBBdHRyaWJ1dGVFbGVtZW50VGFyZ2V0LCBjbGFzc05hbWU6IERvbVRva2Vucyk6ICgoKSA9PiB2b2lkKSA9PiB7XHJcbiAgY3JlYXRlRG9tVG9rZW5MaXN0Q2xhc3MoZWxtKS5fYWRkKGNsYXNzTmFtZSk7XHJcbiAgcmV0dXJuIGJpbmQocmVtb3ZlQ2xhc3MsIGVsbSwgY2xhc3NOYW1lKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUYWtlcyB0d28gY2xhc3NOYW1lIHN0cmluZ3MsIGNvbXBhcmVzIHRoZW0gYW5kIHJldHVybnMgdGhlIGRpZmZlcmVuY2UgYXMgYXJyYXkuXHJcbiAqIEBwYXJhbSBjbGFzc05hbWVBIENsYXNzTmFtZSBBLlxyXG4gKiBAcGFyYW0gY2xhc3NOYW1lQiBDbGFzc05hbWUgQi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBkaWZmQ2xhc3MgPSAoXHJcbiAgY2xhc3NOYW1lQTogc3RyaW5nIHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gIGNsYXNzTmFtZUI6IHN0cmluZyB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4pID0+IHtcclxuICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oY2xhc3NOYW1lQSA/IGNsYXNzTmFtZUEuc3BsaXQoJyAnKSA6IFtdKTtcclxuXHJcbiAgZWFjaChjbGFzc05hbWVCID8gY2xhc3NOYW1lQi5zcGxpdCgnICcpIDogW10sIChjbGFzc05hbWUpID0+IHtcclxuICAgIHNldFtzZXQuaGFzKGNsYXNzTmFtZSkgPyAnZGVsZXRlJyA6ICdhZGQnXShjbGFzc05hbWUpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZnJvbShzZXQpO1xyXG59O1xyXG4iLCJpbXBvcnQgdHlwZSB7IE5vZGVFbGVtZW50VGFyZ2V0IH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJztcclxuaW1wb3J0IHsgcHVzaCwgZnJvbSB9IGZyb20gJy4uL3V0aWxzL2FycmF5JztcclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFsbCBlbGVtZW50cyB3aXRoIHRoZSBwYXNzZWQgc2VsZWN0b3IsIG91dGdvaW5nIChhbmQgaW5jbHVkaW5nKSB0aGUgcGFzc2VkIGVsZW1lbnQgb3IgdGhlIGRvY3VtZW50IGlmIG5vIGVsZW1lbnQgd2FzIHByb3ZpZGVkLlxyXG4gKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHdoaWNoIGhhcyB0byBiZSBzZWFyY2hlZCBieS5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBzZWFyY2ggc2hhbGwgYmUgb3V0Z29pbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZmluZCA9IChzZWxlY3Rvcjogc3RyaW5nLCBlbG0/OiBOb2RlRWxlbWVudFRhcmdldCk6IEVsZW1lbnRbXSA9PiB7XHJcbiAgY29uc3Qgcm9vdEVsbSA9IGVsbSA/IGlzRWxlbWVudChlbG0pICYmIGVsbSA6IGRvY3VtZW50O1xyXG4gIHJldHVybiByb290RWxtID8gZnJvbShyb290RWxtLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSA6IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGUgcGFzc2VkIHNlbGVjdG9yLCBvdXRnb2luZyAoYW5kIGluY2x1ZGluZykgdGhlIHBhc3NlZCBlbGVtZW50IG9yIHRoZSBkb2N1bWVudCBpZiBubyBlbGVtZW50IHdhcyBwcm92aWRlZC5cclxuICogQHBhcmFtIHNlbGVjdG9yIFRoZSBzZWxlY3RvciB3aGljaCBoYXMgdG8gYmUgc2VhcmNoZWQgYnkuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgc2VhcmNoIHNoYWxsIGJlIG91dGdvaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZpbmRGaXJzdCA9IChzZWxlY3Rvcjogc3RyaW5nLCBlbG0/OiBOb2RlRWxlbWVudFRhcmdldCk6IE5vZGVFbGVtZW50VGFyZ2V0ID0+IHtcclxuICBjb25zdCByb290RWxtID0gZWxtID8gaXNFbGVtZW50KGVsbSkgJiYgZWxtIDogZG9jdW1lbnQ7XHJcbiAgcmV0dXJuIHJvb3RFbG0gJiYgcm9vdEVsbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCBlbGVtZW50IGlzIG1hdGNoaW5nIHdpdGggdGhlIHBhc3NlZCBzZWxlY3Rvci5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudCB3aGljaCBoYXMgdG8gYmUgY29tcGFyZWQgd2l0aCB0aGUgcGFzc2VkIHNlbGVjdG9yLlxyXG4gKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHdoaWNoIGhhcyB0byBiZSBjb21wYXJlZCB3aXRoIHRoZSBwYXNzZWQgZWxlbWVudC4gQWRkaXRpb25hbCBzZWxlY3RvcnM6ICc6dmlzaWJsZScgYW5kICc6aGlkZGVuJy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpcyA9IChlbG06IE5vZGVFbGVtZW50VGFyZ2V0LCBzZWxlY3Rvcjogc3RyaW5nKTogYm9vbGVhbiA9PlxyXG4gIGlzRWxlbWVudChlbG0pICYmIGVsbS5tYXRjaGVzKHNlbGVjdG9yKTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0JvZHlFbGVtZW50ID0gKGVsbTogTm9kZUVsZW1lbnRUYXJnZXQpID0+IGlzKGVsbSwgJ2JvZHknKTsgLy8gZG9uJ3QgZG8gdGFyZ2V0RWxlbWVudCA9PT0gb3duZXJEb2N1bWVudC5ib2R5IGluIGNhc2UgaW5pdGlhbGl6YXRpb24gaGFwcGVucyBpbiBtZW1vcnlcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiAobm8gdGV4dC1ub2RlcyBvciBjb21tZW50cykgb2YgdGhlIHBhc3NlZCBlbGVtZW50IHdoaWNoIGFyZSBtYXRjaGluZyB0aGUgcGFzc2VkIHNlbGVjdG9yLiBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgbnVsbC5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudCBvZiB3aGljaCB0aGUgY2hpbGRyZW4gc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSBzZWxlY3RvciBUaGUgc2VsZWN0b3Igd2hpY2ggbXVzdCBtYXRjaCB3aXRoIHRoZSBjaGlsZHJlbiBlbGVtZW50cy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaGlsZHJlbiA9IChlbG06IE5vZGVFbGVtZW50VGFyZ2V0LCBzZWxlY3Rvcj86IHN0cmluZyk6IFJlYWRvbmx5QXJyYXk8RWxlbWVudD4gPT4ge1xyXG4gIGNvbnN0IGNoaWxkczogQXJyYXk8RWxlbWVudD4gPSBbXTtcclxuXHJcbiAgcmV0dXJuIGlzRWxlbWVudChlbG0pXHJcbiAgICA/IHB1c2goXHJcbiAgICAgICAgY2hpbGRzLFxyXG4gICAgICAgIGZyb20oZWxtLmNoaWxkcmVuKS5maWx0ZXIoKGNoaWxkKSA9PiAoc2VsZWN0b3IgPyBpcyhjaGlsZCwgc2VsZWN0b3IpIDogY2hpbGQpKVxyXG4gICAgICApXHJcbiAgICA6IGNoaWxkcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjaGlsZE5vZGVzIChpbmNsLiB0ZXh0LW5vZGVzIG9yIGNvbW1lbnRzIGV0Yy4pIG9mIHRoZSBwYXNzZWQgZWxlbWVudC4gQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIG51bGwuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQgb2Ygd2hpY2ggdGhlIGNoaWxkTm9kZXMgc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29udGVudHMgPSAoZWxtOiBOb2RlRWxlbWVudFRhcmdldCk6IFJlYWRvbmx5QXJyYXk8Q2hpbGROb2RlPiA9PlxyXG4gIGVsbSA/IGZyb20oZWxtLmNoaWxkTm9kZXMpIDogW107XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIHBhc3NlZCBlbGVtZW50LCBvciBudWxsIGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBudWxsLlxyXG4gKiBAcGFyYW0gZWxtIFRoZSBlbGVtZW50IG9mIHdoaWNoIHRoZSBwYXJlbnQgZWxlbWVudCBzaGFsbCBiZSByZXR1cm5lZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBwYXJlbnQgPSAoZWxtOiBOb2RlRWxlbWVudFRhcmdldCk6IE5vZGVFbGVtZW50VGFyZ2V0ID0+IGVsbSAmJiBlbG0ucGFyZW50RWxlbWVudDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IGVsZW1lbnQgdG8gdGhlIHBhc3NlZCBlbGVtZW50IHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIHNlbGVjdG9yLlxyXG4gKiBAcGFyYW0gZWxtIFRoZSBlbGVtZW50LlxyXG4gKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgY2xvc2VzdCBlbGVtZW50IHRvIHRoZSBwYXNzZWQgZWxlbWVudCB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3Rvci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjbG9zZXN0ID0gKGVsbTogTm9kZUVsZW1lbnRUYXJnZXQsIHNlbGVjdG9yOiBzdHJpbmcpOiBOb2RlRWxlbWVudFRhcmdldCA9PlxyXG4gIGlzRWxlbWVudChlbG0pICYmIGVsbS5jbG9zZXN0KHNlbGVjdG9yKTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBmb2N1c2VkIGVsZW1lbnQgb2YgdGhlIHBhc3NlZCBvciBkZWZhdWx0IGRvY3VtZW50LlxyXG4gKiBAcmV0dXJucyBUaGUgZm9jdXNlZCBlbGVtZW50IG9mIHRoZSBwYXNzZWQgZG9jdW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0Rm9jdXNlZEVsZW1lbnQgPSAoZG9jPzogRG9jdW1lbnQpID0+IChkb2MgfHwgZG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQ7XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IGxpZXMgYmV0d2VlbiB0d28gc2VsZWN0b3JzIGluIHRoZSBET00uXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBoaWdoQm91bmRhcnlTZWxlY3RvciBUaGUgaGlnaCBib3VuZGFyeSBzZWxlY3Rvci5cclxuICogQHBhcmFtIGRlZXBCb3VuZGFyeVNlbGVjdG9yIFRoZSBkZWVwIGJvdW5kYXJ5IHNlbGVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxpZXNCZXR3ZWVuID0gKFxyXG4gIGVsbTogTm9kZUVsZW1lbnRUYXJnZXQsXHJcbiAgaGlnaEJvdW5kYXJ5U2VsZWN0b3I6IHN0cmluZyxcclxuICBkZWVwQm91bmRhcnlTZWxlY3Rvcjogc3RyaW5nXHJcbik6IGJvb2xlYW4gPT4ge1xyXG4gIGNvbnN0IGNsb3Nlc3RIaWdoQm91bmRhcnlFbG0gPSBjbG9zZXN0KGVsbSwgaGlnaEJvdW5kYXJ5U2VsZWN0b3IpO1xyXG4gIGNvbnN0IGNsb3Nlc3REZWVwQm91bmRhcnlFbG0gPSBlbG0gJiYgZmluZEZpcnN0KGRlZXBCb3VuZGFyeVNlbGVjdG9yLCBjbG9zZXN0SGlnaEJvdW5kYXJ5RWxtKTtcclxuICBjb25zdCBkZWVwQm91bmRhcnlJc1ZhbGlkID1cclxuICAgIGNsb3Nlc3QoY2xvc2VzdERlZXBCb3VuZGFyeUVsbSwgaGlnaEJvdW5kYXJ5U2VsZWN0b3IpID09PSBjbG9zZXN0SGlnaEJvdW5kYXJ5RWxtO1xyXG5cclxuICByZXR1cm4gY2xvc2VzdEhpZ2hCb3VuZGFyeUVsbSAmJiBjbG9zZXN0RGVlcEJvdW5kYXJ5RWxtXHJcbiAgICA/IGNsb3Nlc3RIaWdoQm91bmRhcnlFbG0gPT09IGVsbSB8fFxyXG4gICAgICAgIGNsb3Nlc3REZWVwQm91bmRhcnlFbG0gPT09IGVsbSB8fFxyXG4gICAgICAgIChkZWVwQm91bmRhcnlJc1ZhbGlkICYmXHJcbiAgICAgICAgICBjbG9zZXN0KGNsb3Nlc3QoZWxtLCBkZWVwQm91bmRhcnlTZWxlY3RvciksIGhpZ2hCb3VuZGFyeVNlbGVjdG9yKSAhPT1cclxuICAgICAgICAgICAgY2xvc2VzdEhpZ2hCb3VuZGFyeUVsbSlcclxuICAgIDogZmFsc2U7XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgTm9kZUVsZW1lbnRUYXJnZXQsIE5vZGVFbGVtZW50VGFyZ2V0Q29sbGVjdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBjcmVhdGVPcktlZXBBcnJheSwgZWFjaCB9IGZyb20gJy4uL3V0aWxzL2FycmF5JztcclxuaW1wb3J0IHsgcGFyZW50IH0gZnJvbSAnLi90cmF2ZXJzYWwnO1xyXG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIE5vZGVzIGZyb20gdGhlaXIgcGFyZW50LlxyXG4gKiBAcGFyYW0gbm9kZXMgVGhlIE5vZGVzIHdoaWNoIHNoYWxsIGJlIHJlbW92ZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVtb3ZlRWxlbWVudHMgPSAobm9kZXM6IE5vZGVFbGVtZW50VGFyZ2V0Q29sbGVjdGlvbik6IHZvaWQgPT4ge1xyXG4gIGVhY2goY3JlYXRlT3JLZWVwQXJyYXkobm9kZXMpLCAobm9kZSkgPT4ge1xyXG4gICAgY29uc3QgcGFyZW50RWxtID0gcGFyZW50KG5vZGUpO1xyXG4gICAgaWYgKG5vZGUgJiYgcGFyZW50RWxtKSB7XHJcbiAgICAgIHBhcmVudEVsbS5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBjaGlsZHJlbiBhdCB0aGUgZW5kIG9mIHRoZSBnaXZlbiBOb2RlLlxyXG4gKiBAcGFyYW0gbm9kZSBUaGUgTm9kZSB0byB3aGljaCB0aGUgY2hpbGRyZW4gc2hhbGwgYmUgYXBwZW5kZWQuXHJcbiAqIEBwYXJhbSBjaGlsZHJlbiBUaGUgTm9kZXMgd2hpY2ggc2hhbGwgYmUgYXBwZW5kZWQuXHJcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gd2hpY2ggcmVtb3ZlcyB0aGUgaW5zZXJ0ZWQgbm9kZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYXBwZW5kQ2hpbGRyZW4gPSAobm9kZTogTm9kZUVsZW1lbnRUYXJnZXQsIGNoaWxkcmVuOiBOb2RlRWxlbWVudFRhcmdldENvbGxlY3Rpb24pID0+XHJcbiAgYmluZChcclxuICAgIHJlbW92ZUVsZW1lbnRzLFxyXG4gICAgbm9kZSAmJlxyXG4gICAgICBjaGlsZHJlbiAmJlxyXG4gICAgICBlYWNoKGNyZWF0ZU9yS2VlcEFycmF5KGNoaWxkcmVuKSwgKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgKTtcclxuIiwiLy8gYXQgdGhlIHRpbWUgb2YgaW1wbGVtZW50YXRpb24gVHlwZVNjcmlwdCBkb2Vzbid0IG9mZmVyIGFueSBUcnVzdGVkVHlwZXMgdHlwZXNjcmlwdCBkZWZpbml0aW9uc1xyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMwMDI0XHJcbmxldCB0cnVzdGVkVHlwZVBvbGljeTogdW5rbm93biB8IHVuZGVmaW5lZDtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUcnVzdGVkVHlwZVBvbGljeSA9ICgpID0+IHRydXN0ZWRUeXBlUG9saWN5O1xyXG5leHBvcnQgY29uc3Qgc2V0VHJ1c3RlZFR5cGVQb2xpY3kgPSAobmV3VHJ1c3RlZFR5cGVQb2xpY3k6IHVua25vd24gfCB1bmRlZmluZWQpID0+IHtcclxuICB0cnVzdGVkVHlwZVBvbGljeSA9IG5ld1RydXN0ZWRUeXBlUG9saWN5O1xyXG59O1xyXG4iLCJpbXBvcnQgeyBlYWNoIH0gZnJvbSAnLi4vdXRpbHMvYXJyYXknO1xyXG5pbXBvcnQgeyBzZXRBdHRycyB9IGZyb20gJy4vYXR0cmlidXRlJztcclxuaW1wb3J0IHsgY29udGVudHMgfSBmcm9tICcuL3RyYXZlcnNhbCc7XHJcbmltcG9ydCB7IHJlbW92ZUVsZW1lbnRzIH0gZnJvbSAnLi9tYW5pcHVsYXRpb24nO1xyXG5pbXBvcnQgeyBnZXRUcnVzdGVkVHlwZVBvbGljeSB9IGZyb20gJy4uLy4uL3RydXN0ZWRUeXBlUG9saWN5JztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZGl2IERPTSBub2RlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZURpdiA9IChjbGFzc05hbWVzPzogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQgPT4ge1xyXG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIHNldEF0dHJzKGRpdiwgJ2NsYXNzJywgY2xhc3NOYW1lcyk7XHJcbiAgcmV0dXJuIGRpdjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTSBub2RlcyBtb2RlbGVkIGFmdGVyIHRoZSBwYXNzZWQgaHRtbCBzdHJpbmcgYW5kIHJldHVybnMgdGhlIHJvb3QgZG9tIG5vZGVzIGFzIGEgYXJyYXkuXHJcbiAqIEBwYXJhbSBodG1sIFRoZSBodG1sIHN0cmluZyBhZnRlciB3aGljaCB0aGUgRE9NIG5vZGVzIHNoYWxsIGJlIGNyZWF0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY3JlYXRlRE9NID0gKGh0bWw6IHN0cmluZyk6IFJlYWRvbmx5QXJyYXk8Tm9kZT4gPT4ge1xyXG4gIGNvbnN0IGNyZWF0ZWREaXYgPSBjcmVhdGVEaXYoKTtcclxuICBjb25zdCB0cnVzdGVkVHlwZXNQb2xpY3kgPSBnZXRUcnVzdGVkVHlwZVBvbGljeSgpO1xyXG4gIGNvbnN0IHRyaW1tZWRIdG1sID0gaHRtbC50cmltKCk7XHJcbiAgY3JlYXRlZERpdi5pbm5lckhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3lcclxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgKHRydXN0ZWRUeXBlc1BvbGljeSBhcyBhbnkpLmNyZWF0ZUhUTUwodHJpbW1lZEh0bWwpXHJcbiAgICA6IHRyaW1tZWRIdG1sO1xyXG5cclxuICByZXR1cm4gZWFjaChjb250ZW50cyhjcmVhdGVkRGl2KSwgKGVsbSkgPT4gcmVtb3ZlRWxlbWVudHMoZWxtKSk7XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgUGxhaW5PYmplY3QsIFN0eWxlT2JqZWN0LCBTdHlsZU9iamVjdEtleSwgU3R5bGVPYmplY3RWYWx1ZSB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xyXG5pbXBvcnQgdHlwZSB7IFhZIH0gZnJvbSAnLi9vZmZzZXQnO1xyXG5pbXBvcnQgdHlwZSB7IEhUTUxFbGVtZW50VGFyZ2V0IH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IHduZCB9IGZyb20gJy4uL3V0aWxzL2FsaWFzJztcclxuaW1wb3J0IHsgZWFjaCwgZnJvbSB9IGZyb20gJy4uL3V0aWxzL2FycmF5JztcclxuaW1wb3J0IHsgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc09iamVjdCwgaXNOdWxsLCBpc0Jvb2xlYW4gfSBmcm9tICcuLi91dGlscy90eXBlcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRSQkwge1xyXG4gIHQ6IG51bWJlcjtcclxuICByOiBudW1iZXI7XHJcbiAgYjogbnVtYmVyO1xyXG4gIGw6IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgZ2V0Q1NTVmFsID0gKGNvbXB1dGVkU3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24sIHByb3A6IFN0eWxlT2JqZWN0S2V5KTogc3RyaW5nID0+XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCkgfHwgY29tcHV0ZWRTdHlsZVtwcm9wIGFzIGFueV0gfHwgJyc7XHJcblxyXG5jb25zdCB2YWxpZEZpbml0ZU51bWJlciA9IChudW1iZXI6IG51bWJlcikgPT4ge1xyXG4gIGNvbnN0IG5vdE5hTiA9IG51bWJlciB8fCAwO1xyXG4gIHJldHVybiBpc0Zpbml0ZShub3ROYU4pID8gbm90TmFOIDogMDtcclxufTtcclxuXHJcbmNvbnN0IHBhcnNlVG9aZXJvT3JOdW1iZXIgPSAodmFsdWU/OiBzdHJpbmcpOiBudW1iZXIgPT4gdmFsaWRGaW5pdGVOdW1iZXIocGFyc2VGbG9hdCh2YWx1ZSB8fCAnJykpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHJvdW5kQ3NzTnVtYmVyID0gKHZhbHVlOiBudW1iZXIpID0+IE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMDtcclxuXHJcbmV4cG9ydCBjb25zdCByYXRpb1RvQ3NzUGVyY2VudCA9IChyYXRpbzogbnVtYmVyKSA9PlxyXG4gIGAke3JvdW5kQ3NzTnVtYmVyKHZhbGlkRmluaXRlTnVtYmVyKHJhdGlvKSAqIDEwMCl9JWA7XHJcblxyXG5leHBvcnQgY29uc3QgbnVtYmVyVG9Dc3NQeCA9IChudW1iZXI6IG51bWJlcikgPT4gYCR7cm91bmRDc3NOdW1iZXIodmFsaWRGaW5pdGVOdW1iZXIobnVtYmVyKSl9cHhgO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFN0eWxlcyhcclxuICBlbG06IEhUTUxFbGVtZW50VGFyZ2V0LFxyXG4gIHN0eWxlczogU3R5bGVPYmplY3QgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWRcclxuKTogdm9pZCB7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtZXhwcmVzc2lvbnNcclxuICBlbG0gJiZcclxuICAgIHN0eWxlcyAmJlxyXG4gICAgZWFjaChzdHlsZXMsIChyYXdWYWx1ZTogU3R5bGVPYmplY3RWYWx1ZSwgbmFtZSkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGVsbVN0eWxlID0gZWxtLnN0eWxlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID1cclxuICAgICAgICAgIGlzTnVsbChyYXdWYWx1ZSkgfHwgaXNCb29sZWFuKHJhd1ZhbHVlKVxyXG4gICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgIDogaXNOdW1iZXIocmF3VmFsdWUpXHJcbiAgICAgICAgICAgICAgPyBudW1iZXJUb0Nzc1B4KHJhd1ZhbHVlKVxyXG4gICAgICAgICAgICAgIDogcmF3VmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy0tJykgPT09IDApIHtcclxuICAgICAgICAgIGVsbVN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgIGVsbVN0eWxlW25hbWUgYXMgYW55XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcclxuICAgICAgfSBjYXRjaCB7fVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZXMoXHJcbiAgZWxtOiBIVE1MRWxlbWVudFRhcmdldCxcclxuICBzdHlsZXM6IEFycmF5PFN0eWxlT2JqZWN0S2V5PiB8IFJlYWRvbmx5QXJyYXk8U3R5bGVPYmplY3RLZXk+LFxyXG4gIHBzZXVkb0VsbT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWRcclxuKTogUGFydGlhbDxSZWNvcmQ8U3R5bGVPYmplY3RLZXksIHN0cmluZz4+O1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGVzKFxyXG4gIGVsbTogSFRNTEVsZW1lbnRUYXJnZXQsXHJcbiAgc3R5bGVzOiBTdHlsZU9iamVjdEtleSxcclxuICBwc2V1ZG9FbG0/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXHJcbik6IHN0cmluZztcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlcyhcclxuICBlbG06IEhUTUxFbGVtZW50VGFyZ2V0LFxyXG4gIHN0eWxlczogQXJyYXk8U3R5bGVPYmplY3RLZXk+IHwgUmVhZG9ubHlBcnJheTxTdHlsZU9iamVjdEtleT4gfCBTdHlsZU9iamVjdEtleSxcclxuICBwc2V1ZG9FbG0/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXHJcbik6IFBhcnRpYWw8UmVjb3JkPFN0eWxlT2JqZWN0S2V5LCBzdHJpbmc+PiB8IHN0cmluZyB7XHJcbiAgY29uc3QgZ2V0U2luZ2xlU3R5bGUgPSBpc1N0cmluZyhzdHlsZXMpO1xyXG4gIGxldCBnZXRTdHlsZXNSZXN1bHQ6IHN0cmluZyB8IFBsYWluT2JqZWN0ID0gZ2V0U2luZ2xlU3R5bGUgPyAnJyA6IHt9O1xyXG5cclxuICBpZiAoZWxtKSB7XHJcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd25kLmdldENvbXB1dGVkU3R5bGUoZWxtLCBwc2V1ZG9FbG0pIHx8IGVsbS5zdHlsZTtcclxuICAgIGdldFN0eWxlc1Jlc3VsdCA9IGdldFNpbmdsZVN0eWxlXHJcbiAgICAgID8gZ2V0Q1NTVmFsKGNvbXB1dGVkU3R5bGUsIHN0eWxlcylcclxuICAgICAgOiBmcm9tKHN0eWxlcykucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xyXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBnZXRDU1NWYWwoY29tcHV0ZWRTdHlsZSwga2V5KTtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSwgZ2V0U3R5bGVzUmVzdWx0IGFzIFBsYWluT2JqZWN0KTtcclxuICB9XHJcbiAgcmV0dXJuIGdldFN0eWxlc1Jlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHRvcCByaWdodCBib3R0b20gbGVmdCB2YWx1ZXMgb2YgdGhlIHBhc3NlZCBjc3MgcHJvcGVydHkuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQgb2Ygd2hpY2ggdGhlIHZhbHVlcyBzaGFsbCBiZSByZXR1cm5lZC5cclxuICogQHBhcmFtIHByb3BlcnR5UHJlZml4IFRoZSBjc3MgcHJvcGVydHkgcHJlZml4LiAoZS5nLiBcImJvcmRlclwiKVxyXG4gKiBAcGFyYW0gcHJvcGVydHlTdWZmaXggVGhlIGNzcyBwcm9wZXJ0eSBzdWZmaXguIChlLmcuIFwid2lkdGhcIilcclxuICovXHJcbmV4cG9ydCBjb25zdCB0b3BSaWdodEJvdHRvbUxlZnQgPSAoXHJcbiAgZWxtPzogSFRNTEVsZW1lbnRUYXJnZXQsXHJcbiAgcHJvcGVydHlQcmVmaXg/OiBzdHJpbmcsXHJcbiAgcHJvcGVydHlTdWZmaXg/OiBzdHJpbmdcclxuKTogVFJCTCA9PiB7XHJcbiAgY29uc3QgZmluYWxQcmVmaXggPSBwcm9wZXJ0eVByZWZpeCA/IGAke3Byb3BlcnR5UHJlZml4fS1gIDogJyc7XHJcbiAgY29uc3QgZmluYWxTdWZmaXggPSBwcm9wZXJ0eVN1ZmZpeCA/IGAtJHtwcm9wZXJ0eVN1ZmZpeH1gIDogJyc7XHJcbiAgY29uc3QgdG9wID0gYCR7ZmluYWxQcmVmaXh9dG9wJHtmaW5hbFN1ZmZpeH1gIGFzIFN0eWxlT2JqZWN0S2V5O1xyXG4gIGNvbnN0IHJpZ2h0ID0gYCR7ZmluYWxQcmVmaXh9cmlnaHQke2ZpbmFsU3VmZml4fWAgYXMgU3R5bGVPYmplY3RLZXk7XHJcbiAgY29uc3QgYm90dG9tID0gYCR7ZmluYWxQcmVmaXh9Ym90dG9tJHtmaW5hbFN1ZmZpeH1gIGFzIFN0eWxlT2JqZWN0S2V5O1xyXG4gIGNvbnN0IGxlZnQgPSBgJHtmaW5hbFByZWZpeH1sZWZ0JHtmaW5hbFN1ZmZpeH1gIGFzIFN0eWxlT2JqZWN0S2V5O1xyXG4gIGNvbnN0IHJlc3VsdCA9IGdldFN0eWxlcyhlbG0sIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdKTtcclxuICByZXR1cm4ge1xyXG4gICAgdDogcGFyc2VUb1plcm9Pck51bWJlcihyZXN1bHRbdG9wXSksXHJcbiAgICByOiBwYXJzZVRvWmVyb09yTnVtYmVyKHJlc3VsdFtyaWdodF0pLFxyXG4gICAgYjogcGFyc2VUb1plcm9Pck51bWJlcihyZXN1bHRbYm90dG9tXSksXHJcbiAgICBsOiBwYXJzZVRvWmVyb09yTnVtYmVyKHJlc3VsdFtsZWZ0XSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUcmFzZm9ybVRyYW5zbGF0ZVZhbHVlID0gKFxyXG4gIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBYWTxzdHJpbmcgfCBudW1iZXI+LFxyXG4gIGlzSG9yaXpvbnRhbD86IGJvb2xlYW5cclxuKSA9PlxyXG4gIGB0cmFuc2xhdGUke1xyXG4gICAgaXNPYmplY3QodmFsdWUpID8gYCgke3ZhbHVlLnh9LCR7dmFsdWUueX0pYCA6IGAke2lzSG9yaXpvbnRhbCA/ICdYJyA6ICdZJ30oJHt2YWx1ZX0pYFxyXG4gIH1gO1xyXG4iLCJpbXBvcnQgdHlwZSB7IEhUTUxFbGVtZW50VGFyZ2V0IH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IGdldFN0eWxlcyB9IGZyb20gJy4vc3R5bGUnO1xyXG5pbXBvcnQgeyBtYXRoUm91bmQsIHduZCB9IGZyb20gJy4uL3V0aWxzL2FsaWFzJztcclxuaW1wb3J0IHsgYmluZCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9uJztcclxuaW1wb3J0IHsgc3RySGVpZ2h0LCBzdHJXaWR0aCB9IGZyb20gJy4uL3V0aWxzL3N0cmluZ3MnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXSDxUID0gbnVtYmVyPiB7XHJcbiAgdzogVDtcclxuICBoOiBUO1xyXG59XHJcblxyXG5jb25zdCBlbGVtZW50SGFzRGltZW5zaW9ucyA9IChlbG06IEhUTUxFbGVtZW50KTogYm9vbGVhbiA9PlxyXG4gICEhKGVsbS5vZmZzZXRXaWR0aCB8fCBlbG0ub2Zmc2V0SGVpZ2h0IHx8IGVsbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XHJcbmNvbnN0IHplcm9PYmo6IFdIID0ge1xyXG4gIHc6IDAsXHJcbiAgaDogMCxcclxufTtcclxuXHJcbmNvbnN0IGdldEVsbVdpZHRoSGVpZ2h0UHJvcGVydHkgPSA8RSBleHRlbmRzIEhUTUxFbGVtZW50IHwgV2luZG93PihcclxuICBwcm9wZXJ0eTogRSBleHRlbmRzIEhUTUxFbGVtZW50ID8gJ2NsaWVudCcgfCAnb2Zmc2V0JyB8ICdzY3JvbGwnIDogJ2lubmVyJyxcclxuICBlbG06IEUgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWRcclxuKTogUmVhZG9ubHk8V0g+ID0+XHJcbiAgZWxtXHJcbiAgICA/IHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHc6IChlbG0gYXMgYW55KVtgJHtwcm9wZXJ0eX1XaWR0aGBdLFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgaDogKGVsbSBhcyBhbnkpW2Ake3Byb3BlcnR5fUhlaWdodGBdLFxyXG4gICAgICB9XHJcbiAgICA6IHplcm9PYmo7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgd2luZG93IGlubmVyLSB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFdpbmRvd1NpemUgPSAoY3VzdG9tV25kPzogV2luZG93KTogUmVhZG9ubHk8V0g+ID0+XHJcbiAgZ2V0RWxtV2lkdGhIZWlnaHRQcm9wZXJ0eSgnaW5uZXInLCBjdXN0b21XbmQgfHwgd25kKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGwtIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHBhc3NlZCBlbGVtZW50LiBJZiB0aGUgZWxlbWVudCBpcyBudWxsIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBhcmUgMC5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudCBvZiB3aGljaCB0aGUgc2Nyb2xsLSB3aWR0aCBhbmQgaGVpZ2h0IHNoYWxsIGJlIHJldHVybmVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldE9mZnNldFNpemUgPSBiaW5kKGdldEVsbVdpZHRoSGVpZ2h0UHJvcGVydHk8SFRNTEVsZW1lbnQ+LCAnb2Zmc2V0Jykgc2F0aXNmaWVzIChcclxuICBlbG06IEhUTUxFbGVtZW50VGFyZ2V0XHJcbikgPT4gUmVhZG9ubHk8V0g+O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNsaWVudC0gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGFzc2VkIGVsZW1lbnQuIElmIHRoZSBlbGVtZW50IGlzIG51bGwgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIGFyZSAwLlxyXG4gKiBAcGFyYW0gZWxtIFRoZSBlbGVtZW50IG9mIHdoaWNoIHRoZSBjbGllbnQtIHdpZHRoIGFuZCBoZWlnaHQgc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0Q2xpZW50U2l6ZSA9IGJpbmQoZ2V0RWxtV2lkdGhIZWlnaHRQcm9wZXJ0eTxIVE1MRWxlbWVudD4sICdjbGllbnQnKSBzYXRpc2ZpZXMgKFxyXG4gIGVsbTogSFRNTEVsZW1lbnRUYXJnZXRcclxuKSA9PiBSZWFkb25seTxXSD47XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY2xpZW50LSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBwYXNzZWQgZWxlbWVudC4gSWYgdGhlIGVsZW1lbnQgaXMgbnVsbCB0aGUgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgYXJlIDAuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQgb2Ygd2hpY2ggdGhlIGNsaWVudC0gd2lkdGggYW5kIGhlaWdodCBzaGFsbCBiZSByZXR1cm5lZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRTY3JvbGxTaXplID0gYmluZChnZXRFbG1XaWR0aEhlaWdodFByb3BlcnR5PEhUTUxFbGVtZW50PiwgJ3Njcm9sbCcpIHNhdGlzZmllcyAoXHJcbiAgZWxtOiBIVE1MRWxlbWVudFRhcmdldFxyXG4pID0+IFJlYWRvbmx5PFdIPjtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmcmFjdGlvbmFsLSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBwYXNzZWQgZWxlbWVudC4gSWYgdGhlIGVsZW1lbnQgaXMgbnVsbCB0aGUgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgYXJlIDAuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQgb2Ygd2hpY2ggdGhlIGZyYWN0aW9uYWwtIHdpZHRoIGFuZCBoZWlnaHQgc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RnJhY3Rpb25hbFNpemUgPSAoZWxtOiBIVE1MRWxlbWVudFRhcmdldCk6IFJlYWRvbmx5PFdIPiA9PiB7XHJcbiAgY29uc3QgY3NzV2lkdGggPSBwYXJzZUZsb2F0KGdldFN0eWxlcyhlbG0sIHN0cldpZHRoKSkgfHwgMDtcclxuICBjb25zdCBjc3NIZWlnaHQgPSBwYXJzZUZsb2F0KGdldFN0eWxlcyhlbG0sIHN0ckhlaWdodCkpIHx8IDA7XHJcbiAgcmV0dXJuIHtcclxuICAgIHc6IGNzc1dpZHRoIC0gbWF0aFJvdW5kKGNzc1dpZHRoKSxcclxuICAgIGg6IGNzc0hlaWdodCAtIG1hdGhSb3VuZChjc3NIZWlnaHQpLFxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgQm91bmRpbmdDbGllbnRSZWN0IG9mIHRoZSBwYXNzZWQgZWxlbWVudC5cclxuICogQHBhcmFtIGVsbSBUaGUgZWxlbWVudCBvZiB3aGljaCB0aGUgQm91bmRpbmdDbGllbnRSZWN0IHNoYWxsIGJlIHJldHVybmVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCA9IChlbG06IEhUTUxFbGVtZW50KTogRE9NUmVjdCA9PiBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgZWxlbWVudCBoYXMgYW55IGRpbWVuc2lvbnMuXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaGFzRGltZW5zaW9ucyA9IChlbG06IEhUTUxFbGVtZW50VGFyZ2V0KTogYm9vbGVhbiA9PlxyXG4gICEhZWxtICYmIGVsZW1lbnRIYXNEaW1lbnNpb25zKGVsbSk7XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgRE9NIFJlY3QgaGFzIGFueSBkaW1lbnNpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRvbVJlY3RIYXNEaW1lbnNpb25zID0gKHJlY3Q/OiBET01SZWN0UmVhZE9ubHkgfCBmYWxzZSB8IG51bGwpID0+XHJcbiAgISEocmVjdCAmJiAocmVjdFtzdHJIZWlnaHRdIHx8IHJlY3Rbc3RyV2lkdGhdKSk7XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGN1cnJlbnQgRE9NIFJlY3QgaGFzIGFwcGVhcmVkIGFjY29yZGluZyB0aGUgdGhlIHByZXZpb3VzIGRvbSByZWN0Li5cclxuICogQHBhcmFtIGN1cnJDb250ZW50UmVjdCBUaGUgY3VycmVudCBET00gUmVjdC5cclxuICogQHBhcmFtIHByZXZDb250ZW50UmVjdCBUaGUgcHJldmlvdXMgRE9NIFJlY3QuXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGRvbSByZWN0IGFwcGVhcmVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRvbVJlY3RBcHBlYXJlZCA9IChcclxuICBjdXJyQ29udGVudFJlY3Q6IERPTVJlY3RSZWFkT25seSB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICBwcmV2Q29udGVudFJlY3Q6IERPTVJlY3RSZWFkT25seSB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4pID0+IHtcclxuICBjb25zdCByZWN0SGFzRGltZW5zaW9ucyA9IGRvbVJlY3RIYXNEaW1lbnNpb25zKGN1cnJDb250ZW50UmVjdCk7XHJcbiAgY29uc3QgcmVjdEhhZERpbWVuc2lvbnMgPSBkb21SZWN0SGFzRGltZW5zaW9ucyhwcmV2Q29udGVudFJlY3QpO1xyXG4gIHJldHVybiAhcmVjdEhhZERpbWVuc2lvbnMgJiYgcmVjdEhhc0RpbWVuc2lvbnM7XHJcbn07XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuaW1wb3J0IHR5cGUgeyBEb21Ub2tlbnMgfSBmcm9tICcuL2F0dHJpYnV0ZSc7XHJcbmltcG9ydCB7IGVhY2gsIHJ1bkVhY2hBbmRDbGVhciB9IGZyb20gJy4uL3V0aWxzL2FycmF5JztcclxuaW1wb3J0IHsgYmluZCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9uJztcclxuaW1wb3J0IHsga2V5cyB9IGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHsgZ2V0RG9tVG9rZW5zQXJyYXkgfSBmcm9tICcuL2F0dHJpYnV0ZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50TGlzdGVuZXJPcHRpb25zIHtcclxuICBfY2FwdHVyZT86IGJvb2xlYW47XHJcbiAgX3Bhc3NpdmU/OiBib29sZWFuO1xyXG4gIF9vbmNlPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lclRhcmdldCA9IEV2ZW50VGFyZ2V0IHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lck1hcCA9IHtcclxuICBbZXZlbnROYW1lczogc3RyaW5nXTogKChldmVudDogYW55KSA9PiBhbnkpIHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIHBhc3NlZCBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHBhc3NlZCBldmVudCBuYW1lcyB3aXRoIHRoZSBwYXNzZWQgb3B0aW9ucy5cclxuICogQHBhcmFtIHRhcmdldCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBsaXN0ZW5lciBzaGFsbCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gZXZlbnROYW1lcyBUaGUgZXZlbnRzbmFtZXMgZm9yIHdoaWNoIHRoZSBsaXN0ZW5lciBzaGFsbCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHdoaWNoIHNoYWxsIGJlIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSBjYXB0dXJlIFRoZSBvcHRpb25zIG9mIHRoZSByZW1vdmVkIGxpc3RlbmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXIgPSA8VCBleHRlbmRzIEV2ZW50ID0gRXZlbnQ+KFxyXG4gIHRhcmdldDogRXZlbnRMaXN0ZW5lclRhcmdldCxcclxuICBldmVudE5hbWVzOiBEb21Ub2tlbnMsXHJcbiAgbGlzdGVuZXI6IChldmVudDogVCkgPT4gYW55LFxyXG4gIGNhcHR1cmU/OiBib29sZWFuXHJcbik6IHZvaWQgPT4ge1xyXG4gIGVhY2goZ2V0RG9tVG9rZW5zQXJyYXkoZXZlbnROYW1lcyksIChldmVudE5hbWUpID0+IHtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciBhcyBFdmVudExpc3RlbmVyLCBjYXB0dXJlKTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBwYXNzZWQgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBwYXNzZWQgZXZlbnQgbmFtZXMgd2l0aCB0aGUgcGFzc2VkIG9wdGlvbnMuXHJcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGxpc3RlbmVyIHNoYWxsIGJlIGFkZGVkLlxyXG4gKiBAcGFyYW0gZXZlbnROYW1lcyBUaGUgZXZlbnRzbmFtZXMgZm9yIHdoaWNoIHRoZSBsaXN0ZW5lciBzaGFsbCBiZSBjYWxsZWQuXHJcbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgd2hpY2ggaXMgY2FsbGVkIG9uIHRoZSBldmVudG5hbWVzLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvZiB0aGUgYWRkZWQgbGlzdGVuZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IDxUIGV4dGVuZHMgRXZlbnQgPSBFdmVudD4oXHJcbiAgdGFyZ2V0OiBFdmVudExpc3RlbmVyVGFyZ2V0LFxyXG4gIGV2ZW50TmFtZXM6IERvbVRva2VucyxcclxuICBsaXN0ZW5lcjogKChldmVudDogVCkgPT4gYW55KSB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICBvcHRpb25zPzogRXZlbnRMaXN0ZW5lck9wdGlvbnNcclxuKTogKCgpID0+IHZvaWQpID0+IHtcclxuICBjb25zdCBwYXNzaXZlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5fcGFzc2l2ZSkgPz8gdHJ1ZTtcclxuICBjb25zdCBjYXB0dXJlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FwdHVyZSkgfHwgZmFsc2U7XHJcbiAgY29uc3Qgb25jZSA9IChvcHRpb25zICYmIG9wdGlvbnMuX29uY2UpIHx8IGZhbHNlO1xyXG4gIGNvbnN0IG5hdGl2ZU9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zID0ge1xyXG4gICAgcGFzc2l2ZSxcclxuICAgIGNhcHR1cmUsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGJpbmQoXHJcbiAgICBydW5FYWNoQW5kQ2xlYXIsXHJcbiAgICBnZXREb21Ub2tlbnNBcnJheShldmVudE5hbWVzKS5tYXAoKGV2ZW50TmFtZSkgPT4ge1xyXG4gICAgICBjb25zdCBmaW5hbExpc3RlbmVyID0gKFxyXG4gICAgICAgIG9uY2VcclxuICAgICAgICAgID8gKGV2dDogVCkgPT4ge1xyXG4gICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGZpbmFsTGlzdGVuZXIsIGNhcHR1cmUpO1xyXG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZ0KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIDogbGlzdGVuZXJcclxuICAgICAgKSBhcyBFdmVudExpc3RlbmVyO1xyXG5cclxuICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZmluYWxMaXN0ZW5lciwgbmF0aXZlT3B0aW9ucyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBiaW5kKHJlbW92ZUV2ZW50TGlzdGVuZXIsIHRhcmdldCwgZXZlbnROYW1lLCBmaW5hbExpc3RlbmVyLCBjYXB0dXJlKTtcclxuICAgIH0pXHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBwYXNzZWQgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgcGFzc2VkIGV2ZW50IG5hbWVzIHdpdGggdGhlIHBhc3NlZCBvcHRpb25zLlxyXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBsaXN0ZW5lciBzaGFsbCBiZSBhZGRlZC5cclxuICogQHBhcmFtIGV2ZW50TGlzdGVuZXJNYXAgQSBtYXAgd2hpY2ggZGVzY2lyYmVzIHRoZSBldmVudCBuYW1lcyBhbmQgZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGFkZGVkLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvZiB0aGUgYWRkZWQgbGlzdGVuZXJzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFkZEV2ZW50TGlzdGVuZXJzID0gKFxyXG4gIHRhcmdldDogRXZlbnRMaXN0ZW5lclRhcmdldCxcclxuICBldmVudExpc3RlbmVyTWFwOiBFdmVudExpc3RlbmVyTWFwLFxyXG4gIG9wdGlvbnM/OiBFdmVudExpc3RlbmVyT3B0aW9uc1xyXG4pOiAoKCkgPT4gdm9pZCkgPT5cclxuICBiaW5kKFxyXG4gICAgcnVuRWFjaEFuZENsZWFyLFxyXG4gICAga2V5cyhldmVudExpc3RlbmVyTWFwKS5tYXAoKGV2ZW50TmFtZXMpID0+XHJcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWVzLCBldmVudExpc3RlbmVyTWFwW2V2ZW50TmFtZXNdLCBvcHRpb25zKVxyXG4gICAgKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogU2hvcnRoYW5kIGZvciB0aGUgc3RvcFByb3BhZ2F0aW9uIGV2ZW50IE1ldGhvZC5cclxuICogQHBhcmFtIGV2dCBUaGUgZXZlbnQgb2Ygd2hpY2ggdGhlIHN0b3BQcm9wYWdhdGlvbiBtZXRob2Qgc2hhbGwgYmUgY2FsbGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0b3BQcm9wYWdhdGlvbiA9IChldnQ6IEV2ZW50KTogdm9pZCA9PiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4vKipcclxuICogU2hvcnRoYW5kIGZvciB0aGUgcHJldmVudERlZmF1bHQgZXZlbnQgTWV0aG9kLlxyXG4gKiBAcGFyYW0gZXZ0IFRoZSBldmVudCBvZiB3aGljaCB0aGUgcHJldmVudERlZmF1bHQgbWV0aG9kIHNoYWxsIGJlIGNhbGxlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQ6IEV2ZW50KTogdm9pZCA9PiBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbi8qKlxyXG4gKiBTaG9ydGhhbmQgZm9yIHRoZSBzdG9wUHJvcGFnYXRpb24gYW5kIHByZXZlbnREZWZhdWx0IGV2ZW50IE1ldGhvZC5cclxuICogQHBhcmFtIGV2dCBUaGUgZXZlbnQgb2Ygd2hpY2ggdGhlIHN0b3BQcm9wYWdhdGlvbiBhbmQgcHJldmVudERlZmF1bHQgbWV0aG9kcyBzaGFsbCBiZSBjYWxsZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RvcEFuZFByZXZlbnQgPSAoZXZ0OiBFdmVudCk6IHZvaWQgPT5cclxuICAoc3RvcFByb3BhZ2F0aW9uKGV2dCkgYXMgdW5kZWZpbmVkKSB8fCAocHJldmVudERlZmF1bHQoZXZ0KSBhcyB1bmRlZmluZWQpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IFhZIH0gZnJvbSAnLi9vZmZzZXQnO1xyXG5pbXBvcnQgdHlwZSB7IFdIIH0gZnJvbSAnLi9kaW1lbnNpb25zJztcclxuaW1wb3J0IHsgY2FwTnVtYmVyLCBpc051bWJlciwgbWF0aEFicywgbWF0aFNpZ24gfSBmcm9tICcuLi91dGlscyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbENvb3JkaW5hdGVzIHtcclxuICAvKiogVGhlIHN0YXJ0IChvcmlnaW4pIHNjcm9sbCBjb29yZGluYXRlcyBmb3IgZWFjaCBheGlzLiAqL1xyXG4gIF9zdGFydDogWFk8bnVtYmVyPjtcclxuICAvKiogVGhlIGVuZCBzY3JvbGwgY29vcmRpbmF0ZXMgZm9yIGVhY2ggYXhpcy4gKi9cclxuICBfZW5kOiBYWTxudW1iZXI+O1xyXG59XHJcblxyXG4vKipcclxuICogU2Nyb2xsIHRoZSBwYXNzZWQgZWxlbWVudCB0byB0aGUgcGFzc2VkIHBvc2l0aW9uLlxyXG4gKiBAcGFyYW0gZWxtIFRoZSBlbGVtZW50IHRvIGJlIHNjcm9sbGVkLlxyXG4gKiBAcGFyYW0gcG9zaXRpb24gVGhlIHNjcm9sbCBwb3NpdGlvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzY3JvbGxFbGVtZW50VG8gPSAoXHJcbiAgZWxtOiBIVE1MRWxlbWVudCxcclxuICBwb3NpdGlvbjogUGFydGlhbDxYWTxudW1iZXIgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWQ+PiB8IG51bWJlciB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4pOiB2b2lkID0+IHtcclxuICBjb25zdCB7IHgsIHkgfSA9IGlzTnVtYmVyKHBvc2l0aW9uKSA/IHsgeDogcG9zaXRpb24sIHk6IHBvc2l0aW9uIH0gOiBwb3NpdGlvbiB8fCB7fTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC1leHByZXNzaW9uc1xyXG4gIGlzTnVtYmVyKHgpICYmIChlbG0uc2Nyb2xsTGVmdCA9IHgpO1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLWV4cHJlc3Npb25zXHJcbiAgaXNOdW1iZXIoeSkgJiYgKGVsbS5zY3JvbGxUb3AgPSB5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGwgdGhlIHBhc3NlZCBlbGVtZW50IHRvIHRoZSBwYXNzZWQgcG9zaXRpb24uXHJcbiAqIEBwYXJhbSBlbG0gVGhlIGVsZW1lbnQgdG8gYmUgc2Nyb2xsZWQuXHJcbiAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgc2Nyb2xsIHBvc2l0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRTY3JvbGwgPSAoZWxtOiBIVE1MRWxlbWVudCk6IFJlYWRvbmx5PFhZPiA9PiAoe1xyXG4gIHg6IGVsbS5zY3JvbGxMZWZ0LFxyXG4gIHk6IGVsbS5zY3JvbGxUb3AsXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbCBDb29yZGluYXRlcyB3aGljaCBhcmUgMC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRaZXJvU2Nyb2xsQ29vcmRpbmF0ZXMgPSAoKTogU2Nyb2xsQ29vcmRpbmF0ZXMgPT4gKHtcclxuICBfc3RhcnQ6IHsgeDogMCwgeTogMCB9LFxyXG4gIF9lbmQ6IHsgeDogMCwgeTogMCB9LFxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTYW5hdGl6ZXMgcmF3IHNjcm9sbCBjb29yZGluYXRlcy5cclxuICogVGhlIHBhc3NlZCBgb3ZlcmZsb3dBbW91bnRgIGlzIHVzZWQgYXMgdGhlIFwibWF4XCIgdmFsdWUgZm9yIGVhY2ggYXhpcyBpZiB0aGUgc2lnbiBvZiB0aGUgcmF3IG1heCB2YWx1ZSBpcyBub3QgYDBgLlxyXG4gKiBNYWtlcyBzdXJlIHRoYXQgZWFjaCBheGlzIGhhcyBgMGAgZWl0aGVyIGluIHRoZSBzdGFydCBvciBlbmQgY29vcmRpbmF0ZXMuXHJcbiAqIEBwYXJhbSByYXdTY3JvbGxDb29yZGluYXRlcyBUaGUgcmF3IHNjcm9sbCBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIG92ZXJmbG93QW1vdW50IFRoZSBvdmVyZmxvdyBhbW91bnQuXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2FuaXRpemVTY3JvbGxDb29yZGluYXRlcyA9IChcclxuICByYXdTY3JvbGxDb29yZGluYXRlczogU2Nyb2xsQ29vcmRpbmF0ZXMsXHJcbiAgb3ZlcmZsb3dBbW91bnQ6IFdIPG51bWJlcj5cclxuKSA9PiB7XHJcbiAgY29uc3QgeyBfc3RhcnQsIF9lbmQgfSA9IHJhd1Njcm9sbENvb3JkaW5hdGVzO1xyXG4gIGNvbnN0IHsgdywgaCB9ID0gb3ZlcmZsb3dBbW91bnQ7XHJcbiAgY29uc3Qgc2FuaXRpemVBeGlzID0gKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBhbW91bnQ6IG51bWJlcikgPT4ge1xyXG4gICAgbGV0IG5ld1N0YXJ0ID0gbWF0aFNpZ24oc3RhcnQpICogYW1vdW50O1xyXG4gICAgbGV0IG5ld0VuZCA9IG1hdGhTaWduKGVuZCkgKiBhbW91bnQ7XHJcblxyXG4gICAgaWYgKG5ld1N0YXJ0ID09PSBuZXdFbmQpIHtcclxuICAgICAgY29uc3Qgc3RhcnRBYnMgPSBtYXRoQWJzKHN0YXJ0KTtcclxuICAgICAgY29uc3QgZW5kQWJzID0gbWF0aEFicyhlbmQpO1xyXG5cclxuICAgICAgbmV3RW5kID0gc3RhcnRBYnMgPiBlbmRBYnMgPyAwIDogbmV3RW5kO1xyXG4gICAgICBuZXdTdGFydCA9IHN0YXJ0QWJzIDwgZW5kQWJzID8gMCA6IG5ld1N0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluIGRvdWJ0IHNldCBzdGFydCB0byAwXHJcbiAgICBuZXdTdGFydCA9IG5ld1N0YXJ0ID09PSBuZXdFbmQgPyAwIDogbmV3U3RhcnQ7XHJcblxyXG4gICAgcmV0dXJuIFtuZXdTdGFydCArIDAsIG5ld0VuZCArIDBdIGFzIGNvbnN0OyAvLyBcIisgMFwiIHByZXZlbnRzIFwiLTBcIiB0byBiZSBpbiB0aGUgcmVzdWx0XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgW3N0YXJ0WCwgZW5kWF0gPSBzYW5pdGl6ZUF4aXMoX3N0YXJ0LngsIF9lbmQueCwgdyk7XHJcbiAgY29uc3QgW3N0YXJ0WSwgZW5kWV0gPSBzYW5pdGl6ZUF4aXMoX3N0YXJ0LnksIF9lbmQueSwgaCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBfc3RhcnQ6IHtcclxuICAgICAgeDogc3RhcnRYLFxyXG4gICAgICB5OiBzdGFydFksXHJcbiAgICB9LFxyXG4gICAgX2VuZDoge1xyXG4gICAgICB4OiBlbmRYLFxyXG4gICAgICB5OiBlbmRZLFxyXG4gICAgfSxcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGFzc2VkIHNjcm9sbCBjb29yZGluYXRlcyByZXByZXNlbnQgdGhlIGJyb3dzZXJzIGRlZmF1bHQgc2Nyb2xsIGRpcmVjdGlvbi5cclxuICogRm9yIHRoZSBkZWZhdWx0IHNjcm9sbCBkaXJlY3Rpb24gdGhlIGZvbGxvd2luZyBtdXN0IGJlIHRydWU6XHJcbiAqIDEuIFN0YXJ0IHZhbHVlIGlzIGAwYC5cclxuICogMi4gRW5kIHZhbHVlIDw9IFN0YXJ0IHZhbHVlLlxyXG4gKiBAcGFyYW0gc2Nyb2xsQ29vcmRpbmF0ZXMgVGhlIHNjcm9sbCBjb29yZGluYXRlcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpc0RlZmF1bHREaXJlY3Rpb25TY3JvbGxDb29yZGluYXRlcyA9ICh7XHJcbiAgX3N0YXJ0LFxyXG4gIF9lbmQsXHJcbn06IFNjcm9sbENvb3JkaW5hdGVzKTogWFk8Ym9vbGVhbj4gPT4ge1xyXG4gIGNvbnN0IGdldEF4aXMgPSAoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IHN0YXJ0ID09PSAwICYmIHN0YXJ0IDw9IGVuZDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IGdldEF4aXMoX3N0YXJ0LngsIF9lbmQueCksXHJcbiAgICB5OiBnZXRBeGlzKF9zdGFydC55LCBfZW5kLnkpLFxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgY3VycmVudCBzY3JvbGwgcGVyY2VudCBiZXR3ZWVuIDAuLjEgZm9yIGVhY2ggYXhpcy5cclxuICogQHBhcmFtIHNjcm9sbENvb3JkaW5hdGVzIFRoZSBzY3JvbGwgY29vcmRpbmF0ZXMuXHJcbiAqIEBwYXJhbSBjdXJyZW50U2Nyb2xsIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRTY3JvbGxDb29yZGluYXRlc1BlcmNlbnQgPSAoXHJcbiAgeyBfc3RhcnQsIF9lbmQgfTogU2Nyb2xsQ29vcmRpbmF0ZXMsXHJcbiAgY3VycmVudFNjcm9sbDogWFk8bnVtYmVyPlxyXG4pID0+IHtcclxuICBjb25zdCBnZXRBeGlzID0gKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBjdXJyZW50OiBudW1iZXIpID0+XHJcbiAgICBjYXBOdW1iZXIoMCwgMSwgKHN0YXJ0IC0gY3VycmVudCkgLyAoc3RhcnQgLSBlbmQpIHx8IDApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgeDogZ2V0QXhpcyhfc3RhcnQueCwgX2VuZC54LCBjdXJyZW50U2Nyb2xsLngpLFxyXG4gICAgeTogZ2V0QXhpcyhfc3RhcnQueSwgX2VuZC55LCBjdXJyZW50U2Nyb2xsLnkpLFxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBwZXJjZW50LlxyXG4gKiBAcGFyYW0gc2Nyb2xsQ29vcmRpbmF0ZXMgVGhlIHNjcm9sbCBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHBlcmNlbnQgVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHNjcm9sbC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRTY3JvbGxDb29yZGluYXRlc1Bvc2l0aW9uID0gKFxyXG4gIHsgX3N0YXJ0LCBfZW5kIH06IFNjcm9sbENvb3JkaW5hdGVzLFxyXG4gIHBlcmNlbnQ6IFhZPG51bWJlcj5cclxuKSA9PiB7XHJcbiAgY29uc3QgZ2V0QXhpcyA9IChzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgcDogbnVtYmVyKSA9PiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBwO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgeDogZ2V0QXhpcyhfc3RhcnQueCwgX2VuZC54LCBwZXJjZW50LngpLFxyXG4gICAgeTogZ2V0QXhpcyhfc3RhcnQueSwgX2VuZC55LCBwZXJjZW50LnkpLFxyXG4gIH07XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgTm9kZUVsZW1lbnRUYXJnZXQgfSBmcm9tICcuL3R5cGVzJztcclxuLy8gaW1wb3J0IHsgZ2V0QXR0ciwgcmVtb3ZlQXR0cnMsIHNldEF0dHJzIH0gZnJvbSAnLi9hdHRyaWJ1dGUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZvY3VzRWxlbWVudCA9IChlbGVtZW50OiBOb2RlRWxlbWVudFRhcmdldCAvKiwgZm9yY2VUYWJJbmRleD86IGJvb2xlYW4qLykgPT4ge1xyXG4gIGlmIChlbGVtZW50ICYmIChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5mb2N1cykge1xyXG4gICAgLy8gY29uc3QgdGFiSW5kZXhTdHIgPSAndGFiaW5kZXgnO1xyXG4gICAgLy8gY29uc3Qgb3JpZ2luYWxUYWJJbmRleCA9IGdldEF0dHIoZWxlbWVudCBhcyBIVE1MRWxlbWVudCwgdGFiSW5kZXhTdHIpO1xyXG4gICAgLy8gaWYgKGZvcmNlVGFiSW5kZXgpIHtcclxuICAgIC8vICAgc2V0QXR0cnMoZWxlbWVudCBhcyBIVE1MRWxlbWVudCwgdGFiSW5kZXhTdHIsICctMScpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5mb2N1cyh7XHJcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWUsXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICBmb2N1c1Zpc2libGU6IGZhbHNlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaWYgKGZvcmNlVGFiSW5kZXgpIHtcclxuICAgIC8vICAgaWYgKG9yaWdpbmFsVGFiSW5kZXgpIHtcclxuICAgIC8vICAgICBzZXRBdHRycyhlbGVtZW50IGFzIEhUTUxFbGVtZW50LCB0YWJJbmRleFN0ciwgb3JpZ2luYWxUYWJJbmRleCk7XHJcbiAgICAvLyAgIH0gZWxzZSB7XHJcbiAgICAvLyAgICAgcmVtb3ZlQXR0cnMoZWxlbWVudCBhcyBIVE1MRWxlbWVudCwgdGFiSW5kZXhTdHIpO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcbiAgfVxyXG59O1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXHJcbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuL3V0aWxzL3R5cGVzJztcclxuaW1wb3J0IHsga2V5cyB9IGZyb20gJy4vdXRpbHMvb2JqZWN0JztcclxuaW1wb3J0IHsgZWFjaCwgcHVzaCwgZnJvbSwgaXNFbXB0eUFycmF5LCBydW5FYWNoQW5kQ2xlYXIsIGNyZWF0ZU9yS2VlcEFycmF5IH0gZnJvbSAnLi91dGlscy9hcnJheSc7XHJcbmltcG9ydCB7IGJpbmQgfSBmcm9tICcuL3V0aWxzL2Z1bmN0aW9uJztcclxuXHJcbmV4cG9ydCB0eXBlIEV2ZW50TGlzdGVuZXI8RXZlbnRBcmdzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55W10+LCBOIGV4dGVuZHMga2V5b2YgRXZlbnRBcmdzPiA9IChcclxuICAuLi5hcmdzOiBFdmVudEFyZ3NbTl1cclxuKSA9PiB2b2lkO1xyXG5cclxuZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lcnM8RXZlbnRBcmdzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55W10+PiA9IHtcclxuICBbSyBpbiBrZXlvZiBFdmVudEFyZ3NdPzogRXZlbnRMaXN0ZW5lcjxFdmVudEFyZ3MsIEs+IHwgRXZlbnRMaXN0ZW5lcjxFdmVudEFyZ3MsIEs+W10gfCBudWxsO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUmVtb3ZlRXZlbnQ8RXZlbnRBcmdzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55W10+PiA9IHtcclxuICA8TiBleHRlbmRzIGtleW9mIEV2ZW50QXJncz4obmFtZT86IE4sIGxpc3RlbmVyPzogRXZlbnRMaXN0ZW5lcjxFdmVudEFyZ3MsIE4+KTogdm9pZDtcclxuICA8TiBleHRlbmRzIGtleW9mIEV2ZW50QXJncz4obmFtZT86IE4sIGxpc3RlbmVyPzogRXZlbnRMaXN0ZW5lcjxFdmVudEFyZ3MsIE4+W10pOiB2b2lkO1xyXG4gIDxOIGV4dGVuZHMga2V5b2YgRXZlbnRBcmdzPihcclxuICAgIG5hbWU/OiBOLFxyXG4gICAgbGlzdGVuZXI/OiBFdmVudExpc3RlbmVyPEV2ZW50QXJncywgTj4gfCBFdmVudExpc3RlbmVyPEV2ZW50QXJncywgTj5bXVxyXG4gICk6IHZvaWQ7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBBZGRFdmVudDxFdmVudEFyZ3MgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4+ID0ge1xyXG4gIChldmVudExpc3RlbmVyczogRXZlbnRMaXN0ZW5lcnM8RXZlbnRBcmdzPiwgcHVyZT86IGJvb2xlYW4pOiAoKSA9PiB2b2lkO1xyXG4gIDxOIGV4dGVuZHMga2V5b2YgRXZlbnRBcmdzPihuYW1lOiBOLCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFdmVudEFyZ3MsIE4+KTogKCkgPT4gdm9pZDtcclxuICA8TiBleHRlbmRzIGtleW9mIEV2ZW50QXJncz4obmFtZTogTiwgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8RXZlbnRBcmdzLCBOPltdKTogKCkgPT4gdm9pZDtcclxuICA8TiBleHRlbmRzIGtleW9mIEV2ZW50QXJncz4oXHJcbiAgICBuYW1lT3JFdmVudExpc3RlbmVyczogTiB8IEV2ZW50TGlzdGVuZXJzPEV2ZW50QXJncz4sXHJcbiAgICBsaXN0ZW5lcj86IEV2ZW50TGlzdGVuZXI8RXZlbnRBcmdzLCBOPiB8IEV2ZW50TGlzdGVuZXI8RXZlbnRBcmdzLCBOPltdIHwgYm9vbGVhblxyXG4gICk6ICgpID0+IHZvaWQ7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBUcmlnZ2VyRXZlbnQ8RXZlbnRBcmdzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55W10+PiA9IHtcclxuICA8TiBleHRlbmRzIGtleW9mIEV2ZW50QXJncz4obmFtZTogTiwgYXJnczogRXZlbnRBcmdzW05dKTogdm9pZDtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEV2ZW50TGlzdGVuZXJIdWI8RXZlbnRBcmdzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55W10+PiA9IFtcclxuICBBZGRFdmVudDxFdmVudEFyZ3M+LFxyXG4gIFJlbW92ZUV2ZW50PEV2ZW50QXJncz4sXHJcbiAgVHJpZ2dlckV2ZW50PEV2ZW50QXJncz4sXHJcbl07XHJcblxyXG5jb25zdCBtYW5hZ2VMaXN0ZW5lciA9IDxFdmVudEFyZ3MgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4sIE4gZXh0ZW5kcyBrZXlvZiBFdmVudEFyZ3M+KFxyXG4gIGNhbGxiYWNrOiAobGlzdGVuZXI/OiBFdmVudExpc3RlbmVyPEV2ZW50QXJncywgTj4pID0+IHZvaWQsXHJcbiAgbGlzdGVuZXI/OiBFdmVudExpc3RlbmVyPEV2ZW50QXJncywgTj4gfCBFdmVudExpc3RlbmVyPEV2ZW50QXJncywgTj5bXVxyXG4pID0+IHtcclxuICBlYWNoKGNyZWF0ZU9yS2VlcEFycmF5KGxpc3RlbmVyKSwgY2FsbGJhY2spO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUV2ZW50TGlzdGVuZXJIdWIgPSA8RXZlbnRBcmdzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55W10+PihcclxuICBpbml0aWFsRXZlbnRMaXN0ZW5lcnM/OiBFdmVudExpc3RlbmVyczxFdmVudEFyZ3M+XHJcbik6IEV2ZW50TGlzdGVuZXJIdWI8RXZlbnRBcmdzPiA9PiB7XHJcbiAgY29uc3QgZXZlbnRzID0gbmV3IE1hcDxrZXlvZiBFdmVudEFyZ3MsIFNldDxFdmVudExpc3RlbmVyPEV2ZW50QXJncywga2V5b2YgRXZlbnRBcmdzPj4+KCk7XHJcblxyXG4gIGNvbnN0IHJlbW92ZUV2ZW50OiBSZW1vdmVFdmVudDxFdmVudEFyZ3M+ID0gKG5hbWUsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICBjb25zdCBldmVudFNldCA9IGV2ZW50cy5nZXQobmFtZSk7XHJcbiAgICAgIG1hbmFnZUxpc3RlbmVyKChjdXJyTGlzdGVuZXIpID0+IHtcclxuICAgICAgICBpZiAoZXZlbnRTZXQpIHtcclxuICAgICAgICAgIGV2ZW50U2V0W2N1cnJMaXN0ZW5lciA/ICdkZWxldGUnIDogJ2NsZWFyJ10oY3Vyckxpc3RlbmVyISBhcyBhbnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgbGlzdGVuZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50U2V0KSA9PiB7XHJcbiAgICAgICAgZXZlbnRTZXQuY2xlYXIoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGV2ZW50cy5jbGVhcigpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGFkZEV2ZW50OiBBZGRFdmVudDxFdmVudEFyZ3M+ID0gKFxyXG4gICAgbmFtZU9yRXZlbnRMaXN0ZW5lcnM6IGtleW9mIEV2ZW50QXJncyB8IEV2ZW50TGlzdGVuZXJzPEV2ZW50QXJncz4sXHJcbiAgICBsaXN0ZW5lck9yUHVyZT86XHJcbiAgICAgIHwgRXZlbnRMaXN0ZW5lcjxFdmVudEFyZ3MsIGtleW9mIEV2ZW50QXJncz5cclxuICAgICAgfCBFdmVudExpc3RlbmVyPEV2ZW50QXJncywga2V5b2YgRXZlbnRBcmdzPltdXHJcbiAgICAgIHwgYm9vbGVhblxyXG4gICkgPT4ge1xyXG4gICAgaWYgKGlzU3RyaW5nKG5hbWVPckV2ZW50TGlzdGVuZXJzKSkge1xyXG4gICAgICBjb25zdCBldmVudFNldCA9IGV2ZW50cy5nZXQobmFtZU9yRXZlbnRMaXN0ZW5lcnMpIHx8IG5ldyBTZXQoKTtcclxuICAgICAgZXZlbnRzLnNldChuYW1lT3JFdmVudExpc3RlbmVycywgZXZlbnRTZXQpO1xyXG5cclxuICAgICAgbWFuYWdlTGlzdGVuZXIoXHJcbiAgICAgICAgKGN1cnJMaXN0ZW5lcikgPT4ge1xyXG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY3Vyckxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICBldmVudFNldC5hZGQoY3Vyckxpc3RlbmVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpc3RlbmVyT3JQdXJlIGFzIEV4Y2x1ZGU8dHlwZW9mIGxpc3RlbmVyT3JQdXJlLCBib29sZWFuPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIGJpbmQoXHJcbiAgICAgICAgcmVtb3ZlRXZlbnQsXHJcbiAgICAgICAgbmFtZU9yRXZlbnRMaXN0ZW5lcnMsXHJcbiAgICAgICAgbGlzdGVuZXJPclB1cmUgYXMgRXhjbHVkZTx0eXBlb2YgbGlzdGVuZXJPclB1cmUsIGJvb2xlYW4+XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCb29sZWFuKGxpc3RlbmVyT3JQdXJlKSAmJiBsaXN0ZW5lck9yUHVyZSkge1xyXG4gICAgICByZW1vdmVFdmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJLZXlzID0ga2V5cyhuYW1lT3JFdmVudExpc3RlbmVycykgYXMgKGtleW9mIEV2ZW50TGlzdGVuZXJzPEV2ZW50QXJncz4pW107XHJcbiAgICBjb25zdCBvZmZGbnM6ICgoKSA9PiB2b2lkKVtdID0gW107XHJcbiAgICBlYWNoKGV2ZW50TGlzdGVuZXJLZXlzLCAoa2V5KSA9PiB7XHJcbiAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSAobmFtZU9yRXZlbnRMaXN0ZW5lcnMgYXMgRXZlbnRMaXN0ZW5lcnM8RXZlbnRBcmdzPilba2V5XTtcclxuICAgICAgaWYgKGV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICBwdXNoKG9mZkZucywgYWRkRXZlbnQoa2V5LCBldmVudExpc3RlbmVyKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBiaW5kKHJ1bkVhY2hBbmRDbGVhciwgb2ZmRm5zKTtcclxuICB9O1xyXG5cclxuICBjb25zdCB0cmlnZ2VyRXZlbnQ6IFRyaWdnZXJFdmVudDxFdmVudEFyZ3M+ID0gKG5hbWUsIGFyZ3MpID0+IHtcclxuICAgIGVhY2goZnJvbShldmVudHMuZ2V0KG5hbWUpKSwgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChhcmdzICYmICFpc0VtcHR5QXJyYXkoYXJncykpIHtcclxuICAgICAgICAoZXZlbnQgYXMgKC4uLmV2ZW50QXJnczogRXZlbnRBcmdzW2tleW9mIEV2ZW50QXJnc10pID0+IHZvaWQpLmFwcGx5KDAsIGFyZ3MpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIChldmVudCBhcyAoKSA9PiB2b2lkKSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBhZGRFdmVudChpbml0aWFsRXZlbnRMaXN0ZW5lcnMgfHwge30pO1xyXG5cclxuICByZXR1cm4gW2FkZEV2ZW50LCByZW1vdmVFdmVudCwgdHJpZ2dlckV2ZW50XTtcclxufTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xyXG5pbXBvcnQgdHlwZSB7IE92ZXJsYXlTY3JvbGxiYXJzLCBPdmVybGF5U2Nyb2xsYmFyc1N0YXRpYyB9IGZyb20gJy4uL292ZXJsYXlzY3JvbGxiYXJzJztcclxuaW1wb3J0IHR5cGUgeyBFdmVudExpc3RlbmVyLCBFdmVudExpc3RlbmVyQXJncywgRXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuLi9ldmVudExpc3RlbmVycyc7XHJcbmltcG9ydCB7IGVhY2gsIGtleXMgfSBmcm9tICcuLi9zdXBwb3J0JztcclxuXHJcbmV4cG9ydCB0eXBlIFBsdWdpbk1vZHVsZUluc3RhbmNlID0gUmVjb3JkPHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgYW55PjtcclxuXHJcbmV4cG9ydCB0eXBlIEluc3RhbmNlUGx1Z2luRXZlbnQgPSB7XHJcbiAgLyoqXHJcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSBldmVudExpc3RlbmVycyBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGFkZGVkIGxpc3RlbmVycy5cclxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcmVtb3ZlcyB0aGUgYWRkZWQgbGlzdGVuZXJzLlxyXG4gICAqL1xyXG4gIChldmVudExpc3RlbmVyczogRXZlbnRMaXN0ZW5lcnMpOiAoKSA9PiB2b2lkO1xyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHdoaWNoIGlzIGludm9rZWQgb24gdGhhdCBldmVudC5cclxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcmVtb3ZlcyB0aGUgYWRkZWQgbGlzdGVuZXJzLlxyXG4gICAqL1xyXG4gIDxOIGV4dGVuZHMga2V5b2YgRXZlbnRMaXN0ZW5lckFyZ3M+KG5hbWU6IE4sIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPE4+KTogKCkgPT4gdm9pZDtcclxuICAvKipcclxuICAgKiBBZGRzIG11bHRpcGxlIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXJzIHdoaWNoIGFyZSBpbnZva2VkIG9uIHRoYXQgZXZlbnQuXHJcbiAgICogQHJldHVybnMgUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHJlbW92ZXMgdGhlIGFkZGVkIGxpc3RlbmVycy5cclxuICAgKi9cclxuICA8TiBleHRlbmRzIGtleW9mIEV2ZW50TGlzdGVuZXJBcmdzPihuYW1lOiBOLCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxOPltdKTogKCkgPT4gdm9pZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBPdmVybGF5U2Nyb2xsYmFycyBwbHVnaW4gbW9kdWxlLlxyXG4gKiBQbHVnaW4gbW9kdWxlcyBtdXN0IGJlIHNpZGUtZWZmZWN0IGZyZWUgYW5kIGRldGVybWluaXN0aWMuIChzYW1lIGlucHV0IHByb2R1Y2VzIHNhbWUgb3V0cHV0KVxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUGx1Z2luTW9kdWxlPFxyXG4gIFMgZXh0ZW5kcyBQbHVnaW5Nb2R1bGVJbnN0YW5jZSB8IHZvaWQgPSBQbHVnaW5Nb2R1bGVJbnN0YW5jZSB8IHZvaWQsXHJcbiAgSSBleHRlbmRzIFBsdWdpbk1vZHVsZUluc3RhbmNlIHwgdm9pZCA9IFBsdWdpbk1vZHVsZUluc3RhbmNlIHwgdm9pZCxcclxuPiA9IChTIGV4dGVuZHMgUGx1Z2luTW9kdWxlSW5zdGFuY2VcclxuICA/IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIENyZWF0ZXMgYSBwbHVnaW4gd2hpY2ggaXMgYm91bmQgdG8gdGhlIHN0YXRpYyBvYmplY3QuXHJcbiAgICAgICAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmNlIHdpdGggdGhlIHN0YXRpYyBvYmplY3QgYXMgc29vbiBhcyB0aGUgcGx1Z2luIGlzIHJlZ2lzdGVyZWQuXHJcbiAgICAgICAqIFRoZSBwbHVnaW4gY2FuIGFkZCBuZXcgbWV0aG9kcyBvciBmaWVsZHMgdG8gdGhlIHBhc3NlZCBzdGF0aWMgb2JqZWN0LlxyXG4gICAgICAgKiBAcGFyYW0gb3NTdGF0aWMgVGhlIHN0YXRpYyBvYmplY3QgdGhlIHBsdWdpbiBpcyBib3VuZCB0by5cclxuICAgICAgICogQHJldHVybnMgVGhlIHBsdWdpbnMgaW5zdGFuY2Ugb2JqZWN0IG9yIGEgZmFsc3kgdmFsdWUgaWYgdGhlIHBsdWdpbiBkb2Vzbid0IG5lZWQgYW55IGluc3RhbmNlIG9iamVjdC5cclxuICAgICAgICovXHJcbiAgICAgIHN0YXRpYzogKG9zU3RhdGljOiBPdmVybGF5U2Nyb2xsYmFyc1N0YXRpYykgPT4gUyB8IHZvaWQ7XHJcbiAgICB9XHJcbiAgOiBvYmplY3QpICZcclxuICAoSSBleHRlbmRzIFBsdWdpbk1vZHVsZUluc3RhbmNlXHJcbiAgICA/IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgQSBwbHVnaW4gd2hpY2ggaXMgYm91bmQgdG8gYW4gaW5zdGFuY2UuXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGVhY2ggdGltZSBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkLlxyXG4gICAgICAgICAqIFRoZSBwbHVnaW4gY2FuIGFkZCBuZXcgbWV0aG9kcyBvciBmaWVsZHMgdG8gdGhlIHBhc3NlZCBpbnN0YW5jZSBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIG9zSW5zdGFuY2UgVGhlIGluc3RhbmNlIG9iamVjdCB0aGUgcGx1Z2luIGlzIGJvdW5kIHRvLlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBBIGZ1bmN0aW9uIHdoaWNoIGFkZHMgZXZlbnRzIHRvIHRoZSBpbnN0YW5jZSB3aGljaCBjYW4ndCBiZSByZW1vdmVkIGZyb20gb3V0c2lkZSB0aGUgcGx1Z2luLiAoaW5zdGFuY2UgZXZlbnRzIGFkZGVkIHdpdGggdGhlIGBvbmAgZnVuY3Rpb24gY2FuIGJlIHJlbW92ZWQgd2l0aCB0aGUgb3B0aW9uYWwgYHB1cmVgIHBhcmFtZXRlcilcclxuICAgICAgICAgKiBAcGFyYW0gb3NTdGF0aWMgVGhlIHN0YXRpYyBvYmplY3QgdGhlIHBsdWdpbiBpcyBib3VuZCB0by5cclxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgcGx1Z2lucyBpbnN0YW5jZSBvYmplY3Qgb3IgYSBmYWxzeSB2YWx1ZSBpZiB0aGUgcGx1Z2luIGRvZXNuJ3QgbmVlZCBhbnkgaW5zdGFuY2Ugb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluc3RhbmNlOiAoXHJcbiAgICAgICAgICBvc0luc3RhbmNlOiBPdmVybGF5U2Nyb2xsYmFycyxcclxuICAgICAgICAgIGV2ZW50OiBJbnN0YW5jZVBsdWdpbkV2ZW50LFxyXG4gICAgICAgICAgb3NTdGF0aWM6IE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljXHJcbiAgICAgICAgKSA9PiBJIHwgdm9pZDtcclxuICAgICAgfVxyXG4gICAgOiBvYmplY3QpO1xyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIE92ZXJsYXlTY3JvbGxiYXIgcGx1Z2luLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUGx1Z2luPFxyXG4gIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXHJcbiAgUyBleHRlbmRzIFBsdWdpbk1vZHVsZUluc3RhbmNlIHwgdm9pZCA9IFBsdWdpbk1vZHVsZUluc3RhbmNlIHwgdm9pZCxcclxuICBJIGV4dGVuZHMgUGx1Z2luTW9kdWxlSW5zdGFuY2UgfCB2b2lkID0gUGx1Z2luTW9kdWxlSW5zdGFuY2UgfCB2b2lkLFxyXG4+ID0ge1xyXG4gIC8qKiBUaGUgZmllbGQgaXMgdGhlIHBsdWdpbnMgbmFtZS4gUGx1Z2luIG5hbWVzIG11c3QgYmUgZ2xvYmFsbHkgdW5pcXVlLCBwbGVhc2UgY2hvb3NlIHdpc2VseS4gKi9cclxuICBbcGx1Z2luTmFtZSBpbiBOYW1lXTogUGx1Z2luTW9kdWxlPFMsIEk+O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIE92ZXJsYXlTY3JvbGxiYXIgcGx1Z2luIHdoaWNoIGhhcyBvbmx5IGEgc3RhdGljIG1vZHVsZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIFN0YXRpY1BsdWdpbjxcclxuICBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxyXG4gIFQgZXh0ZW5kcyBQbHVnaW5Nb2R1bGVJbnN0YW5jZSA9IFBsdWdpbk1vZHVsZUluc3RhbmNlLFxyXG4+ID0gUGx1Z2luPE5hbWUsIFQsIHZvaWQ+O1xyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIE92ZXJsYXlTY3JvbGxiYXIgcGx1Z2luIHdoaWNoIGhhcyBvbmx5IGEgaW5zdGFuY2UgbW9kdWxlLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgSW5zdGFuY2VQbHVnaW48XHJcbiAgTmFtZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcclxuICBUIGV4dGVuZHMgUGx1Z2luTW9kdWxlSW5zdGFuY2UgPSBQbHVnaW5Nb2R1bGVJbnN0YW5jZSxcclxuPiA9IFBsdWdpbjxOYW1lLCB2b2lkLCBUPjtcclxuXHJcbi8qKlxyXG4gKiBJbmZlcnMgdGhlIHR5cGUgb2YgdGhlIHN0YXRpYyBtb2R1bGVzIGluc3RhbmNlIG9mIHRoZSBwYXNzZWQgcGx1Z2luLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgSW5mZXJTdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZTxUIGV4dGVuZHMgU3RhdGljUGx1Z2luPiA9XHJcbiAgVCBleHRlbmRzIFN0YXRpY1BsdWdpbjxpbmZlciBOYW1lPlxyXG4gICAgPyBUW05hbWVdWydzdGF0aWMnXSBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55XHJcbiAgICAgID8gUmV0dXJuVHlwZTxUW05hbWVdWydzdGF0aWMnXT5cclxuICAgICAgOiB2b2lkXHJcbiAgICA6IHZvaWQ7XHJcblxyXG4vKipcclxuICogSW5mZXJzIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSBtb2R1bGVzIGluc3RhbmNlIG9mIHRoZSBwYXNzZWQgcGx1Z2luLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgSW5mZXJJbnN0YW5jZVBsdWdpbk1vZHVsZUluc3RhbmNlPFQgZXh0ZW5kcyBJbnN0YW5jZVBsdWdpbj4gPVxyXG4gIFQgZXh0ZW5kcyBJbnN0YW5jZVBsdWdpbjxpbmZlciBOYW1lPlxyXG4gICAgPyBUW05hbWVdWydpbnN0YW5jZSddIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnlcclxuICAgICAgPyBSZXR1cm5UeXBlPFRbTmFtZV1bJ2luc3RhbmNlJ10+XHJcbiAgICAgIDogdm9pZFxyXG4gICAgOiB2b2lkO1xyXG5cclxuLyoqIEFsbCByZWdpc3RlcmVkIHBsdWdpbiBtb2R1bGVzLiAqL1xyXG5leHBvcnQgY29uc3QgcGx1Z2luTW9kdWxlczogUmVjb3JkPHN0cmluZywgUGx1Z2luTW9kdWxlPiA9IHt9O1xyXG5cclxuLyoqIEFsbCBzdGF0aWMgcGx1Z2luIG1vZHVsZSBpbnN0YW5jZXMuICovXHJcbmV4cG9ydCBjb25zdCBzdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZXM6IFJlY29yZDxzdHJpbmcsIFBsdWdpbk1vZHVsZUluc3RhbmNlIHwgdm9pZD4gPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHBsdWdpbnMuXHJcbiAqIEBwYXJhbSBhZGRlZFBsdWdpbiBUaGUgcGx1Z2luKHMpIHRvIGFkZC5cclxuICogQHJldHVybnMgVGhlIGFkZGVkIHBsdWdpbiBtb2R1bGVzIG9mIHRoZSByZWdpc3RlcmVkIHBsdWdpbnMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWRkUGx1Z2lucyA9IChhZGRlZFBsdWdpbjogUGx1Z2luW10pID0+IHtcclxuICBlYWNoKGFkZGVkUGx1Z2luLCAocGx1Z2luKSA9PlxyXG4gICAgZWFjaChwbHVnaW4sIChfLCBrZXkpID0+IHtcclxuICAgICAgcGx1Z2luTW9kdWxlc1trZXldID0gcGx1Z2luW2tleV07XHJcbiAgICB9KVxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJQbHVnaW5Nb2R1bGVJbnN0YW5jZXMgPSAoXHJcbiAgcGx1Z2luOiBQbHVnaW4sXHJcbiAgc3RhdGljT2JqOiBPdmVybGF5U2Nyb2xsYmFyc1N0YXRpYyxcclxuICBpbnN0YW5jZUluZm8/OiBbXHJcbiAgICBpbnN0YW5jZU9iajogT3ZlcmxheVNjcm9sbGJhcnMsXHJcbiAgICBldmVudDogSW5zdGFuY2VQbHVnaW5FdmVudCxcclxuICAgIGluc3RhbmNlUGx1Z2luTWFwPzogUmVjb3JkPHN0cmluZywgUGx1Z2luTW9kdWxlSW5zdGFuY2U+LFxyXG4gIF1cclxuKTogQXJyYXk8UGx1Z2luTW9kdWxlSW5zdGFuY2UgfCB2b2lkPiA9PlxyXG4gIGtleXMocGx1Z2luKS5tYXAoKG5hbWUpID0+IHtcclxuICAgIGNvbnN0IHsgc3RhdGljOiBvc1N0YXRpYywgaW5zdGFuY2U6IG9zSW5zdGFuY2UgfSA9IChcclxuICAgICAgcGx1Z2luIGFzIFBsdWdpbjxzdHJpbmcsIFBsdWdpbk1vZHVsZUluc3RhbmNlLCBQbHVnaW5Nb2R1bGVJbnN0YW5jZT5cclxuICAgIClbbmFtZV07XHJcbiAgICBjb25zdCBbaW5zdGFuY2VPYmosIGV2ZW50LCBpbnN0YW5jZVBsdWdpbk1hcF0gPSBpbnN0YW5jZUluZm8gfHwgW107XHJcbiAgICBjb25zdCBjdG9yID0gaW5zdGFuY2VJbmZvID8gb3NJbnN0YW5jZSA6IG9zU3RhdGljO1xyXG4gICAgaWYgKGN0b3IpIHtcclxuICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZUluZm9cclxuICAgICAgICA/IChcclxuICAgICAgICAgICAgY3RvciBhcyBFeHRyYWN0PFxyXG4gICAgICAgICAgICAgIHR5cGVvZiBjdG9yLFxyXG4gICAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgIG9zSW5zdGFuY2U6IE92ZXJsYXlTY3JvbGxiYXJzLFxyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IEluc3RhbmNlUGx1Z2luRXZlbnQsXHJcbiAgICAgICAgICAgICAgICBvc1N0YXRpYzogT3ZlcmxheVNjcm9sbGJhcnNTdGF0aWNcclxuICAgICAgICAgICAgICApID0+IFBsdWdpbk1vZHVsZUluc3RhbmNlIHwgdm9pZFxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICApKGluc3RhbmNlT2JqISwgZXZlbnQhLCBzdGF0aWNPYmopXHJcbiAgICAgICAgOiAoXHJcbiAgICAgICAgICAgIGN0b3IgYXMgRXh0cmFjdDxcclxuICAgICAgICAgICAgICB0eXBlb2YgY3RvcixcclxuICAgICAgICAgICAgICAob3NTdGF0aWM6IE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljKSA9PiBQbHVnaW5Nb2R1bGVJbnN0YW5jZSB8IHZvaWRcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgKShzdGF0aWNPYmopO1xyXG4gICAgICByZXR1cm4gKChpbnN0YW5jZVBsdWdpbk1hcCB8fCBzdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZXMpW25hbWVdID0gaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1BsdWdpbk1vZHVsZUluc3RhbmNlID0gPFQgZXh0ZW5kcyBTdGF0aWNQbHVnaW4+KFxyXG4gIHBsdWdpbk1vZHVsZU5hbWU6IFQgZXh0ZW5kcyBTdGF0aWNQbHVnaW48aW5mZXIgTj4gPyBOIDogbmV2ZXJcclxuKTogSW5mZXJTdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZTxUPiB8IHVuZGVmaW5lZCA9PlxyXG4gIHN0YXRpY1BsdWdpbk1vZHVsZUluc3RhbmNlc1twbHVnaW5Nb2R1bGVOYW1lXSBhcyBJbmZlclN0YXRpY1BsdWdpbk1vZHVsZUluc3RhbmNlPFQ+IHwgdW5kZWZpbmVkO1xyXG4iLCJpbXBvcnQgdHlwZSB7XHJcbiAgT3B0aW9ucyxcclxuICBQYXJ0aWFsT3B0aW9ucyxcclxuICBPdmVyZmxvd0JlaGF2aW9yLFxyXG4gIFNjcm9sbGJhcnNWaXNpYmlsaXR5QmVoYXZpb3IsXHJcbiAgU2Nyb2xsYmFyc0F1dG9IaWRlQmVoYXZpb3IsXHJcbiAgU2Nyb2xsYmFyc0NsaWNrU2Nyb2xsQmVoYXZpb3IsXHJcbn0gZnJvbSAnLi4vLi4vb3B0aW9ucyc7XHJcbmltcG9ydCB0eXBlIHsgT3B0aW9uc1RlbXBsYXRlLCBPcHRpb25zVGVtcGxhdGVWYWx1ZSB9IGZyb20gJy4vdmFsaWRhdGlvbic7XHJcbmltcG9ydCB0eXBlIHsgU3RhdGljUGx1Z2luIH0gZnJvbSAnLi4vcGx1Z2lucyc7XHJcbmltcG9ydCB7IHZhbGlkYXRlT3B0aW9ucywgb3B0aW9uc1RlbXBsYXRlVHlwZXMgYXMgb1R5cGVzIH0gZnJvbSAnLi92YWxpZGF0aW9uJztcclxuXHJcbmV4cG9ydCBjb25zdCBvcHRpb25zVmFsaWRhdGlvblBsdWdpbk1vZHVsZU5hbWUgPSAnX19vc09wdGlvbnNWYWxpZGF0aW9uUGx1Z2luJztcclxuXHJcbmV4cG9ydCBjb25zdCBPcHRpb25zVmFsaWRhdGlvblBsdWdpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcclxuICBbb3B0aW9uc1ZhbGlkYXRpb25QbHVnaW5Nb2R1bGVOYW1lXToge1xyXG4gICAgc3RhdGljOiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG51bWJlckFsbG93ZWRWYWx1ZXM6IE9wdGlvbnNUZW1wbGF0ZVZhbHVlPG51bWJlcj4gPSBvVHlwZXMubnVtYmVyO1xyXG4gICAgICBjb25zdCBib29sZWFuQWxsb3dlZFZhbHVlczogT3B0aW9uc1RlbXBsYXRlVmFsdWU8Ym9vbGVhbj4gPSBvVHlwZXMuYm9vbGVhbjtcclxuICAgICAgY29uc3QgYXJyYXlOdWxsVmFsdWVzOiBPcHRpb25zVGVtcGxhdGVWYWx1ZTxBcnJheTx1bmtub3duPiB8IG51bGw+ID0gW1xyXG4gICAgICAgIG9UeXBlcy5hcnJheSxcclxuICAgICAgICBvVHlwZXMubnVsbCxcclxuICAgICAgXTtcclxuICAgICAgY29uc3Qgb3ZlcmZsb3dBbGxvd2VkVmFsdWVzOiBPcHRpb25zVGVtcGxhdGVWYWx1ZTxPdmVyZmxvd0JlaGF2aW9yPiA9XHJcbiAgICAgICAgJ2hpZGRlbiBzY3JvbGwgdmlzaWJsZSB2aXNpYmxlLWhpZGRlbic7XHJcbiAgICAgIGNvbnN0IHNjcm9sbGJhcnNWaXNpYmlsaXR5QWxsb3dlZFZhbHVlczogT3B0aW9uc1RlbXBsYXRlVmFsdWU8U2Nyb2xsYmFyc1Zpc2liaWxpdHlCZWhhdmlvcj4gPVxyXG4gICAgICAgICd2aXNpYmxlIGhpZGRlbiBhdXRvJztcclxuICAgICAgY29uc3Qgc2Nyb2xsYmFyc0F1dG9IaWRlQWxsb3dlZFZhbHVlczogT3B0aW9uc1RlbXBsYXRlVmFsdWU8U2Nyb2xsYmFyc0F1dG9IaWRlQmVoYXZpb3I+ID1cclxuICAgICAgICAnbmV2ZXIgc2Nyb2xsIGxlYXZlbW92ZSc7XHJcbiAgICAgIGNvbnN0IHNjcm9sbGJhcnNDbGlja1Njcm9sbEFsbG93ZWRWYWx1ZXM6IE9wdGlvbnNUZW1wbGF0ZVZhbHVlPFNjcm9sbGJhcnNDbGlja1Njcm9sbEJlaGF2aW9yPiA9XHJcbiAgICAgICAgW2Jvb2xlYW5BbGxvd2VkVmFsdWVzLCBvVHlwZXMuc3RyaW5nXTtcclxuXHJcbiAgICAgIGNvbnN0IG9wdGlvbnNUZW1wbGF0ZTogT3B0aW9uc1RlbXBsYXRlPE9wdGlvbnM+ID0ge1xyXG4gICAgICAgIHBhZGRpbmdBYnNvbHV0ZTogYm9vbGVhbkFsbG93ZWRWYWx1ZXMsIC8vIHRydWUgfHwgZmFsc2VcclxuICAgICAgICBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzOiBib29sZWFuQWxsb3dlZFZhbHVlcywgLy8gdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgZWxlbWVudEV2ZW50czogYXJyYXlOdWxsVmFsdWVzLCAvLyBhcnJheSBvZiB0dXBsZXMgfHwgbnVsbFxyXG4gICAgICAgICAgYXR0cmlidXRlczogYXJyYXlOdWxsVmFsdWVzLFxyXG4gICAgICAgICAgZGVib3VuY2U6IFtvVHlwZXMubnVtYmVyLCBvVHlwZXMuYXJyYXksIG9UeXBlcy5vYmplY3QsIG9UeXBlcy5udWxsXSwgLy8gbnVtYmVyIHx8IG51bWJlciBhcnJheSB8fCBvYmplY3QgfHwgbnVsbFxyXG4gICAgICAgICAgaWdub3JlTXV0YXRpb246IFtvVHlwZXMuZnVuY3Rpb24sIG9UeXBlcy5udWxsXSwgLy8gZnVuY3Rpb24gfHwgbnVsbFxyXG4gICAgICAgICAgZmxvd0RpcmVjdGlvblN0eWxlczogW29UeXBlcy5mdW5jdGlvbiwgb1R5cGVzLm51bGxdLCAvLyBmdW5jdGlvbiB8fCBudWxsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvdmVyZmxvdzoge1xyXG4gICAgICAgICAgeDogb3ZlcmZsb3dBbGxvd2VkVmFsdWVzLCAvLyB2aXNpYmxlLWhpZGRlbiAgfHwgdmlzaWJsZS1zY3JvbGwgfHwgaGlkZGVuIHx8IHNjcm9sbFxyXG4gICAgICAgICAgeTogb3ZlcmZsb3dBbGxvd2VkVmFsdWVzLCAvLyB2aXNpYmxlLWhpZGRlbiAgfHwgdmlzaWJsZS1zY3JvbGwgfHwgaGlkZGVuIHx8IHNjcm9sbFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2Nyb2xsYmFyczoge1xyXG4gICAgICAgICAgdGhlbWU6IFtvVHlwZXMuc3RyaW5nLCBvVHlwZXMubnVsbF0sIC8vIHN0cmluZyB8fCBudWxsXHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBzY3JvbGxiYXJzVmlzaWJpbGl0eUFsbG93ZWRWYWx1ZXMsIC8vIHZpc2libGUgfHwgaGlkZGVuIHx8IGF1dG9cclxuICAgICAgICAgIGF1dG9IaWRlOiBzY3JvbGxiYXJzQXV0b0hpZGVBbGxvd2VkVmFsdWVzLCAvLyBuZXZlciB8fCBzY3JvbGwgfHwgbGVhdmUgfHwgbW92ZSB8fFxyXG4gICAgICAgICAgYXV0b0hpZGVEZWxheTogbnVtYmVyQWxsb3dlZFZhbHVlcywgLy8gbnVtYmVyXHJcbiAgICAgICAgICBhdXRvSGlkZVN1c3BlbmQ6IGJvb2xlYW5BbGxvd2VkVmFsdWVzLCAvLyB0cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICBkcmFnU2Nyb2xsOiBib29sZWFuQWxsb3dlZFZhbHVlcywgLy8gdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgY2xpY2tTY3JvbGw6IHNjcm9sbGJhcnNDbGlja1Njcm9sbEFsbG93ZWRWYWx1ZXMsIC8vIHRydWUgfHwgZmFsc2UgfHwgaW5zdGFudFxyXG4gICAgICAgICAgcG9pbnRlcnM6IFtvVHlwZXMuYXJyYXksIG9UeXBlcy5udWxsXSwgLy8gc3RyaW5nIGFycmF5XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgIHRleHRhcmVhOiB7XHJcbiAgICAgICAgICBkeW5XaWR0aDogYm9vbGVhbkFsbG93ZWRWYWx1ZXMsIC8vIHRydWUgfHwgZmFsc2VcclxuICAgICAgICAgIGR5bkhlaWdodDogYm9vbGVhbkFsbG93ZWRWYWx1ZXMsIC8vIHRydWUgfHwgZmFsc2VcclxuICAgICAgICAgIGluaGVyaXRlZEF0dHJzOiBzdHJpbmdBcnJheU51bGxBbGxvd2VkVmFsdWVzLCAvLyBzdHJpbmcgfHwgYXJyYXkgfHwgbnVsXHJcbiAgICAgICAgfSxcclxuICAgICAgICAqL1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gKG9wdGlvbnM6IFBhcnRpYWxPcHRpb25zLCBkb1dyaXRlRXJyb3JzPzogYm9vbGVhbik6IFBhcnRpYWxPcHRpb25zID0+IHtcclxuICAgICAgICBjb25zdCBbdmFsaWRhdGVkLCBmb3JlaWduXSA9IHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zVGVtcGxhdGUsIG9wdGlvbnMsIGRvV3JpdGVFcnJvcnMpO1xyXG4gICAgICAgIHJldHVybiB7IC4uLmZvcmVpZ24sIC4uLnZhbGlkYXRlZCB9O1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICB9LFxyXG59KSkoKSBzYXRpc2ZpZXMgU3RhdGljUGx1Z2luPHR5cGVvZiBvcHRpb25zVmFsaWRhdGlvblBsdWdpbk1vZHVsZU5hbWU+O1xyXG4iLCJpbXBvcnQgeyBzdHJPdmVyZmxvd1gsIHN0ck92ZXJmbG93WSB9IGZyb20gJy4vc3VwcG9ydCc7XHJcblxyXG5jb25zdCBkYXRhQXR0cmlidXRlUHJlZml4ID0gYGRhdGEtb3ZlcmxheXNjcm9sbGJhcnNgO1xyXG5cclxuLy8gZW52aXJvbm1lbnRcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZUVudmlyb25tZW50ID0gJ29zLWVudmlyb25tZW50JztcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZUVudmlyb25tZW50U2Nyb2xsYmFySGlkZGVuID0gYCR7Y2xhc3NOYW1lRW52aXJvbm1lbnR9LXNjcm9sbGJhci1oaWRkZW5gO1xyXG5cclxuLy8gaW5pdGlhbGl6ZVxyXG5leHBvcnQgY29uc3QgZGF0YUF0dHJpYnV0ZUluaXRpYWxpemUgPSBgJHtkYXRhQXR0cmlidXRlUHJlZml4fS1pbml0aWFsaXplYDtcclxuXHJcbi8vIHNoYXJlZFxyXG5leHBvcnQgY29uc3QgZGF0YVZhbHVlTm9DbGlwcGluZyA9ICdub0NsaXBwaW5nJztcclxuXHJcbi8vIGJvZHlcclxuZXhwb3J0IGNvbnN0IGRhdGFBdHRyaWJ1dGVIdG1sQm9keSA9IGAke2RhdGFBdHRyaWJ1dGVQcmVmaXh9LWJvZHlgO1xyXG5cclxuLy8gaG9zdFxyXG5leHBvcnQgY29uc3QgZGF0YUF0dHJpYnV0ZUhvc3QgPSBkYXRhQXR0cmlidXRlUHJlZml4O1xyXG5leHBvcnQgY29uc3QgZGF0YVZhbHVlSG9zdElzSG9zdCA9ICdob3N0JztcclxuXHJcbi8vIHZpZXdwb3J0XHJcbmV4cG9ydCBjb25zdCBkYXRhQXR0cmlidXRlVmlld3BvcnQgPSBgJHtkYXRhQXR0cmlidXRlUHJlZml4fS12aWV3cG9ydGA7XHJcbmV4cG9ydCBjb25zdCBkYXRhVmFsdWVWaWV3cG9ydE92ZXJmbG93WFByZWZpeCA9IHN0ck92ZXJmbG93WDtcclxuZXhwb3J0IGNvbnN0IGRhdGFWYWx1ZVZpZXdwb3J0T3ZlcmZsb3dZUHJlZml4ID0gc3RyT3ZlcmZsb3dZO1xyXG5leHBvcnQgY29uc3QgZGF0YVZhbHVlVmlld3BvcnRBcnJhbmdlID0gJ2FycmFuZ2UnO1xyXG5leHBvcnQgY29uc3QgZGF0YVZhbHVlVmlld3BvcnRNZWFzdXJpbmcgPSAnbWVhc3VyaW5nJztcclxuZXhwb3J0IGNvbnN0IGRhdGFWYWx1ZVZpZXdwb3J0U2Nyb2xsaW5nID0gJ3Njcm9sbGluZyc7XHJcbmV4cG9ydCBjb25zdCBkYXRhVmFsdWVWaWV3cG9ydFNjcm9sbGJhckhpZGRlbiA9ICdzY3JvbGxiYXJIaWRkZW4nO1xyXG5leHBvcnQgY29uc3QgZGF0YVZhbHVlVmlld3BvcnROb0NvbnRlbnQgPSAnbm9Db250ZW50JztcclxuXHJcbi8vIHBhZGRpbmdcclxuZXhwb3J0IGNvbnN0IGRhdGFBdHRyaWJ1dGVQYWRkaW5nID0gYCR7ZGF0YUF0dHJpYnV0ZVByZWZpeH0tcGFkZGluZ2A7XHJcblxyXG4vLyBjb250ZW50XHJcbmV4cG9ydCBjb25zdCBkYXRhQXR0cmlidXRlQ29udGVudCA9IGAke2RhdGFBdHRyaWJ1dGVQcmVmaXh9LWNvbnRlbnRgO1xyXG5cclxuLy8gc2l6ZSBvYnNlcnZlclxyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2l6ZU9ic2VydmVyID0gJ29zLXNpemUtb2JzZXJ2ZXInO1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2l6ZU9ic2VydmVyQXBwZWFyID0gYCR7Y2xhc3NOYW1lU2l6ZU9ic2VydmVyfS1hcHBlYXJgO1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2l6ZU9ic2VydmVyTGlzdGVuZXIgPSBgJHtjbGFzc05hbWVTaXplT2JzZXJ2ZXJ9LWxpc3RlbmVyYDtcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZVNpemVPYnNlcnZlckxpc3RlbmVyU2Nyb2xsID0gYCR7Y2xhc3NOYW1lU2l6ZU9ic2VydmVyTGlzdGVuZXJ9LXNjcm9sbGA7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lckl0ZW0gPSBgJHtjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lcn0taXRlbWA7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lckl0ZW1GaW5hbCA9IGAke2NsYXNzTmFtZVNpemVPYnNlcnZlckxpc3RlbmVySXRlbX0tZmluYWxgO1xyXG5cclxuLy8gdHJpbnNpYyBvYnNlcnZlclxyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lVHJpbnNpY09ic2VydmVyID0gJ29zLXRyaW5zaWMtb2JzZXJ2ZXInO1xyXG5cclxuLy8gc2Nyb2xsYmFyc1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2Nyb2xsYmFyVGhlbWVOb25lID0gJ29zLXRoZW1lLW5vbmUnO1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2Nyb2xsYmFyID0gJ29zLXNjcm9sbGJhcic7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTY3JvbGxiYXJSdGwgPSBgJHtjbGFzc05hbWVTY3JvbGxiYXJ9LXJ0bGA7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTY3JvbGxiYXJIb3Jpem9udGFsID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyfS1ob3Jpem9udGFsYDtcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZVNjcm9sbGJhclZlcnRpY2FsID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyfS12ZXJ0aWNhbGA7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTY3JvbGxiYXJUcmFjayA9IGAke2NsYXNzTmFtZVNjcm9sbGJhcn0tdHJhY2tgO1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyfS1oYW5kbGVgO1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2Nyb2xsYmFyVmlzaWJsZSA9IGAke2NsYXNzTmFtZVNjcm9sbGJhcn0tdmlzaWJsZWA7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJsZXNzID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyfS1jb3JuZXJsZXNzYDtcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZVNjcm9sbGJhclRyYW5zaXRpb25sZXNzID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyfS10cmFuc2l0aW9ubGVzc2A7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTY3JvbGxiYXJJbnRlcmFjdGlvbiA9IGAke2NsYXNzTmFtZVNjcm9sbGJhcn0taW50ZXJhY3Rpb25gO1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2Nyb2xsYmFyVW51c2FibGUgPSBgJHtjbGFzc05hbWVTY3JvbGxiYXJ9LXVudXNhYmxlYDtcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRlID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyfS1hdXRvLWhpZGVgO1xyXG5leHBvcnQgY29uc3QgY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGVIaWRkZW4gPSBgJHtjbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZX0taGlkZGVuYDtcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZVNjcm9sbGJhcldoZWVsID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyfS13aGVlbGA7XHJcbmV4cG9ydCBjb25zdCBjbGFzc05hbWVTY3JvbGxiYXJUcmFja0ludGVyYWN0aXZlID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2t9LWludGVyYWN0aXZlYDtcclxuZXhwb3J0IGNvbnN0IGNsYXNzTmFtZVNjcm9sbGJhckhhbmRsZUludGVyYWN0aXZlID0gYCR7Y2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlfS1pbnRlcmFjdGl2ZWA7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuaW1wb3J0IHR5cGUgeyBTdGF0aWNQbHVnaW4gfSBmcm9tICcuLi9wbHVnaW5zJztcclxuaW1wb3J0IHtcclxuICBjcmVhdGVET00sXHJcbiAgYXBwZW5kQ2hpbGRyZW4sXHJcbiAgZ2V0T2Zmc2V0U2l6ZSxcclxuICBhZGRFdmVudExpc3RlbmVyLFxyXG4gIGFkZENsYXNzLFxyXG4gIGVxdWFsV0gsXHJcbiAgY0FGLFxyXG4gIHJBRixcclxuICBzdG9wUHJvcGFnYXRpb24sXHJcbiAgYmluZCxcclxuICBzY3JvbGxFbGVtZW50VG8sXHJcbiAgc3RyV2lkdGgsXHJcbiAgc3RySGVpZ2h0LFxyXG4gIHNldFN0eWxlcyxcclxufSBmcm9tICcuLi8uLi9zdXBwb3J0JztcclxuaW1wb3J0IHtcclxuICBjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lclNjcm9sbCxcclxuICBjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lckl0ZW0sXHJcbiAgY2xhc3NOYW1lU2l6ZU9ic2VydmVyTGlzdGVuZXJJdGVtRmluYWwsXHJcbn0gZnJvbSAnLi4vLi4vY2xhc3NuYW1lcyc7XHJcblxyXG5leHBvcnQgY29uc3Qgc2l6ZU9ic2VydmVyUGx1Z2luTmFtZSA9ICdfX29zU2l6ZU9ic2VydmVyUGx1Z2luJztcclxuXHJcbmV4cG9ydCBjb25zdCBTaXplT2JzZXJ2ZXJQbHVnaW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XHJcbiAgW3NpemVPYnNlcnZlclBsdWdpbk5hbWVdOiB7XHJcbiAgICBzdGF0aWM6XHJcbiAgICAgICgpID0+XHJcbiAgICAgIChcclxuICAgICAgICBsaXN0ZW5lckVsZW1lbnQ6IEhUTUxFbGVtZW50LFxyXG4gICAgICAgIG9uU2l6ZUNoYW5nZWRDYWxsYmFjazogKGFwcGVhcjogYm9vbGVhbikgPT4gYW55LFxyXG4gICAgICAgIG9ic2VydmVBcHBlYXJDaGFuZ2U6IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkXHJcbiAgICAgICk6IFthcHBlYXJDYWxsYmFjazogKCkgPT4gdm9pZCwgb2ZmRm5zOiAoKCkgPT4gYW55KVtdXSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gMzMzMzMzMztcclxuICAgICAgICBjb25zdCBzY3JvbGxFdmVudE5hbWUgPSAnc2Nyb2xsJztcclxuICAgICAgICBjb25zdCBvYnNlcnZlckVsZW1lbnRDaGlsZHJlbiA9IGNyZWF0ZURPTShcclxuICAgICAgICAgIGA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lckl0ZW19XCIgZGlyPVwibHRyXCI+PGRpdiBjbGFzcz1cIiR7Y2xhc3NOYW1lU2l6ZU9ic2VydmVyTGlzdGVuZXJJdGVtfVwiPjxkaXYgY2xhc3M9XCIke2NsYXNzTmFtZVNpemVPYnNlcnZlckxpc3RlbmVySXRlbUZpbmFsfVwiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCIke2NsYXNzTmFtZVNpemVPYnNlcnZlckxpc3RlbmVySXRlbX1cIj48ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lckl0ZW1GaW5hbH1cIiBzdHlsZT1cIndpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCVcIj48L2Rpdj48L2Rpdj48L2Rpdj5gXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBvYnNlcnZlckVsZW1lbnRDaGlsZHJlblJvb3QgPSBvYnNlcnZlckVsZW1lbnRDaGlsZHJlblswXSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBjb25zdCBzaHJpbmtFbGVtZW50ID0gb2JzZXJ2ZXJFbGVtZW50Q2hpbGRyZW5Sb290Lmxhc3RDaGlsZCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBjb25zdCBleHBhbmRFbGVtZW50ID0gb2JzZXJ2ZXJFbGVtZW50Q2hpbGRyZW5Sb290LmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgZXhwYW5kRWxlbWVudENoaWxkID0gZXhwYW5kRWxlbWVudD8uZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudDtcclxuXHJcbiAgICAgICAgbGV0IGNhY2hlU2l6ZSA9IGdldE9mZnNldFNpemUob2JzZXJ2ZXJFbGVtZW50Q2hpbGRyZW5Sb290KTtcclxuICAgICAgICBsZXQgY3VyclNpemUgPSBjYWNoZVNpemU7XHJcbiAgICAgICAgbGV0IGlzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICBsZXQgckFGSWQ6IG51bWJlcjtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICBzY3JvbGxFbGVtZW50VG8oZXhwYW5kRWxlbWVudCwgc2Nyb2xsQW1vdW50KTtcclxuICAgICAgICAgIHNjcm9sbEVsZW1lbnRUbyhzaHJpbmtFbGVtZW50LCBzY3JvbGxBbW91bnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgb25SZXNpemVkID0gKGFwcGVhcj86IHVua25vd24pID0+IHtcclxuICAgICAgICAgIHJBRklkID0gMDtcclxuICAgICAgICAgIGlmIChpc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGNhY2hlU2l6ZSA9IGN1cnJTaXplO1xyXG4gICAgICAgICAgICBvblNpemVDaGFuZ2VkQ2FsbGJhY2soYXBwZWFyID09PSB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG9uU2Nyb2xsID0gKHNjcm9sbEV2ZW50PzogRXZlbnQgfCBmYWxzZSkgPT4ge1xyXG4gICAgICAgICAgY3VyclNpemUgPSBnZXRPZmZzZXRTaXplKG9ic2VydmVyRWxlbWVudENoaWxkcmVuUm9vdCk7XHJcbiAgICAgICAgICBpc0RpcnR5ID0gIXNjcm9sbEV2ZW50IHx8ICFlcXVhbFdIKGN1cnJTaXplLCBjYWNoZVNpemUpO1xyXG5cclxuICAgICAgICAgIGlmIChzY3JvbGxFdmVudCkge1xyXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oc2Nyb2xsRXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzRGlydHkgJiYgIXJBRklkKSB7XHJcbiAgICAgICAgICAgICAgY0FGIShyQUZJZCk7XHJcbiAgICAgICAgICAgICAgckFGSWQgPSByQUYhKG9uUmVzaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9uUmVzaXplZChzY3JvbGxFdmVudCA9PT0gZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZXN0cm95Rm5zID0gW1xyXG4gICAgICAgICAgYXBwZW5kQ2hpbGRyZW4obGlzdGVuZXJFbGVtZW50LCBvYnNlcnZlckVsZW1lbnRDaGlsZHJlbiksXHJcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV4cGFuZEVsZW1lbnQsIHNjcm9sbEV2ZW50TmFtZSwgb25TY3JvbGwpLFxyXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihzaHJpbmtFbGVtZW50LCBzY3JvbGxFdmVudE5hbWUsIG9uU2Nyb2xsKSxcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBhZGRDbGFzcyhsaXN0ZW5lckVsZW1lbnQsIGNsYXNzTmFtZVNpemVPYnNlcnZlckxpc3RlbmVyU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgLy8gbGV0cyBhc3N1bWUgdGhhdCB0aGUgZGl2cyB3aWxsIG5ldmVyIGJlIHRoYXQgbGFyZ2UgYW5kIGEgY29uc3RhbnQgdmFsdWUgaXMgZW5vdWdoXHJcbiAgICAgICAgc2V0U3R5bGVzKGV4cGFuZEVsZW1lbnRDaGlsZCwge1xyXG4gICAgICAgICAgW3N0cldpZHRoXTogc2Nyb2xsQW1vdW50LFxyXG4gICAgICAgICAgW3N0ckhlaWdodF06IHNjcm9sbEFtb3VudCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgckFGIShyZXNldCk7XHJcblxyXG4gICAgICAgIHJldHVybiBbb2JzZXJ2ZUFwcGVhckNoYW5nZSA/IGJpbmQob25TY3JvbGwsIGZhbHNlKSA6IHJlc2V0LCBkZXN0cm95Rm5zXTtcclxuICAgICAgfSxcclxuICB9LFxyXG59KSkoKSBzYXRpc2ZpZXMgU3RhdGljUGx1Z2luPHR5cGVvZiBzaXplT2JzZXJ2ZXJQbHVnaW5OYW1lPjtcclxuIiwiaW1wb3J0IHR5cGUgeyBFbnYgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XHJcbmltcG9ydCB0eXBlIHsgT3B0aW9ucywgT3B0aW9uc0NoZWNrRm4sIE92ZXJmbG93QmVoYXZpb3IgfSBmcm9tICcuLi8uLi9vcHRpb25zJztcclxuaW1wb3J0IHR5cGUgeyBPdmVyZmxvd1N0eWxlIH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XHJcbmltcG9ydCB7XHJcbiAgZ2V0U3R5bGVzLFxyXG4gIHN0ckhpZGRlbixcclxuICBzdHJPdmVyZmxvd1gsXHJcbiAgc3RyT3ZlcmZsb3dZLFxyXG4gIHN0clNjcm9sbCxcclxuICBzdHJWaXNpYmxlLFxyXG4gIFhZLFxyXG59IGZyb20gJy4uLy4uL3N1cHBvcnQnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFNob3dOYXRpdmVPdmVybGFpZFNjcm9sbGJhcnMgPSAoY2hlY2tPcHRpb246IE9wdGlvbnNDaGVja0ZuPE9wdGlvbnM+LCBlbnY6IEVudikgPT4ge1xyXG4gIGNvbnN0IHsgX25hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCB9ID0gZW52O1xyXG4gIGNvbnN0IFtzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzT3B0aW9uLCBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzQ2hhbmdlZF0gPSBjaGVja09wdGlvbihcclxuICAgICdzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzJ1xyXG4gICk7XHJcblxyXG4gIHJldHVybiBbXHJcbiAgICBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzT3B0aW9uICYmXHJcbiAgICAgIF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQueCAmJlxyXG4gICAgICBfbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLnksXHJcbiAgICBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzQ2hhbmdlZCxcclxuICBdIGFzIGNvbnN0O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG92ZXJmbG93SXNWaXNpYmxlID0gKG92ZXJmbG93OiBzdHJpbmcpID0+IG92ZXJmbG93LmluZGV4T2Yoc3RyVmlzaWJsZSkgPT09IDA7XHJcblxyXG5leHBvcnQgY29uc3Qgb3ZlcmZsb3dCZWhhdmlvclRvT3ZlcmZsb3dTdHlsZSA9IChcclxuICBvdmVyZmxvd0JlaGF2aW9yOiBPdmVyZmxvd0JlaGF2aW9yXHJcbik6IE92ZXJmbG93U3R5bGUgPT4gb3ZlcmZsb3dCZWhhdmlvci5yZXBsYWNlKGAke3N0clZpc2libGV9LWAsICcnKSBhcyBPdmVyZmxvd1N0eWxlO1xyXG5cclxuZXhwb3J0IGNvbnN0IG92ZXJmbG93Q3NzVmFsdWVUb092ZXJmbG93U3R5bGUgPSAoXHJcbiAgY3NzVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcclxuICBoYXNPdmVyZmxvdz86IGJvb2xlYW5cclxuKTogT3ZlcmZsb3dTdHlsZSA9PiB7XHJcbiAgaWYgKGNzc1ZhbHVlID09PSAnYXV0bycpIHtcclxuICAgIHJldHVybiBoYXNPdmVyZmxvdyA/IHN0clNjcm9sbCA6IHN0ckhpZGRlbjtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZpbmFsQ3NzVmFsdWUgPSBjc3NWYWx1ZSB8fCBzdHJIaWRkZW47XHJcbiAgcmV0dXJuIFtzdHJIaWRkZW4sIHN0clNjcm9sbCwgc3RyVmlzaWJsZV0uaW5jbHVkZXMoZmluYWxDc3NWYWx1ZSlcclxuICAgID8gKGZpbmFsQ3NzVmFsdWUgYXMgT3ZlcmZsb3dTdHlsZSlcclxuICAgIDogc3RySGlkZGVuO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRPdmVyZmxvd1N0eWxlID0gKFxyXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxyXG4gIGhhc092ZXJmbG93OiBQYXJ0aWFsPFhZPGJvb2xlYW4+PlxyXG4pOiBYWTxPdmVyZmxvd1N0eWxlPiA9PiB7XHJcbiAgY29uc3QgeyBvdmVyZmxvd1gsIG92ZXJmbG93WSB9ID0gZ2V0U3R5bGVzKGVsZW1lbnQsIFtzdHJPdmVyZmxvd1gsIHN0ck92ZXJmbG93WV0pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgeDogb3ZlcmZsb3dDc3NWYWx1ZVRvT3ZlcmZsb3dTdHlsZShvdmVyZmxvd1gsIGhhc092ZXJmbG93LngpLFxyXG4gICAgeTogb3ZlcmZsb3dDc3NWYWx1ZVRvT3ZlcmZsb3dTdHlsZShvdmVyZmxvd1ksIGhhc092ZXJmbG93LnkpLFxyXG4gIH07XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgT2JzZXJ2ZXJzU2V0dXBTdGF0ZSB9IGZyb20gJy4uLy4uL3NldHVwcyc7XHJcbmltcG9ydCB0eXBlIHsgT3B0aW9ucywgT3B0aW9uc0NoZWNrRm4gfSBmcm9tICcuLi8uLi9vcHRpb25zJztcclxuaW1wb3J0IHR5cGUgeyBTdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzT2JqIH0gZnJvbSAnLi4vLi4vc2V0dXBzL3N0cnVjdHVyZVNldHVwL3N0cnVjdHVyZVNldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHR5cGUgeyBFbnYgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XHJcbmltcG9ydCB0eXBlIHsgV0gsIFhZIH0gZnJvbSAnLi4vLi4vc3VwcG9ydCc7XHJcbmltcG9ydCB0eXBlIHsgT3ZlcmZsb3dTdHlsZSwgU3R5bGVPYmplY3QsIFN0eWxlT2JqZWN0S2V5IH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XHJcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlU2V0dXBTdGF0ZSB9IGZyb20gJy4uLy4uL3NldHVwcy9zdHJ1Y3R1cmVTZXR1cCc7XHJcbmltcG9ydCB0eXBlIHsgU3RhdGljUGx1Z2luIH0gZnJvbSAnLi4vcGx1Z2lucyc7XHJcbmltcG9ydCB7XHJcbiAgZ2V0U2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFycyxcclxuICBnZXRFbGVtZW50T3ZlcmZsb3dTdHlsZSxcclxufSBmcm9tICcuLi8uLi9zZXR1cHMvc3RydWN0dXJlU2V0dXAvc3RydWN0dXJlU2V0dXAudXRpbHMnO1xyXG5pbXBvcnQgeyBkYXRhVmFsdWVWaWV3cG9ydEFycmFuZ2UsIGRhdGFBdHRyaWJ1dGVWaWV3cG9ydCB9IGZyb20gJy4uLy4uL2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQge1xyXG4gIGtleXMsXHJcbiAgbm9vcCxcclxuICBlYWNoLFxyXG4gIGFzc2lnbkRlZXAsXHJcbiAgc3RyTWFyZ2luQm90dG9tLFxyXG4gIHN0ck1hcmdpbkxlZnQsXHJcbiAgc3RyTWFyZ2luUmlnaHQsXHJcbiAgc3RyUGFkZGluZ0JvdHRvbSxcclxuICBzdHJQYWRkaW5nTGVmdCxcclxuICBzdHJQYWRkaW5nUmlnaHQsXHJcbiAgc3RyUGFkZGluZ1RvcCxcclxuICBnZXRTdHlsZXMsXHJcbiAgc2V0U3R5bGVzLFxyXG4gIHJlbW92ZUF0dHJDbGFzcyxcclxuICBzdHJXaWR0aCxcclxuICBzdHJTY3JvbGwsXHJcbn0gZnJvbSAnLi4vLi4vc3VwcG9ydCc7XHJcblxyXG5leHBvcnQgY29uc3Qgc2Nyb2xsYmFyc0hpZGluZ1BsdWdpbk5hbWUgPSAnX19vc1Njcm9sbGJhcnNIaWRpbmdQbHVnaW4nO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNjcm9sbGJhcnNIaWRpbmdQbHVnaW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XHJcbiAgW3Njcm9sbGJhcnNIaWRpbmdQbHVnaW5OYW1lXToge1xyXG4gICAgc3RhdGljOiAoKSA9PiAoe1xyXG4gICAgICBfdmlld3BvcnRBcnJhbmdlbWVudDogKFxyXG4gICAgICAgIHN0cnVjdHVyZVNldHVwRWxlbWVudHM6IFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmosXHJcbiAgICAgICAgc3RydWN0dXJlU2V0dXBTdGF0ZTogU3RydWN0dXJlU2V0dXBTdGF0ZSxcclxuICAgICAgICBvYnNlcnZlcnNTZXR1cFN0YXRlOiBPYnNlcnZlcnNTZXR1cFN0YXRlLFxyXG4gICAgICAgIGVudjogRW52LFxyXG4gICAgICAgIGNoZWNrT3B0aW9uczogT3B0aW9uc0NoZWNrRm48T3B0aW9ucz5cclxuICAgICAgKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBfdmlld3BvcnRJc1RhcmdldCwgX3ZpZXdwb3J0IH0gPSBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzO1xyXG4gICAgICAgIGNvbnN0IHsgX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmcsIF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQsIF9uYXRpdmVTY3JvbGxiYXJzU2l6ZSB9ID0gZW52O1xyXG4gICAgICAgIGNvbnN0IGRvVmlld3BvcnRBcnJhbmdlID1cclxuICAgICAgICAgICFfdmlld3BvcnRJc1RhcmdldCAmJlxyXG4gICAgICAgICAgIV9uYXRpdmVTY3JvbGxiYXJzSGlkaW5nICYmXHJcbiAgICAgICAgICAoX25hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC54IHx8IF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQueSk7XHJcbiAgICAgICAgY29uc3QgW3Nob3dOYXRpdmVPdmVybGFpZFNjcm9sbGJhcnNdID0gZ2V0U2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFycyhjaGVja09wdGlvbnMsIGVudik7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGhpZGUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBwYXNzZWQgb3ZlcmZsb3cgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHZpZXdwb3J0T3ZlcmZsb3dTdGF0ZSBUaGUgb3ZlcmZsb3cgc3RhdGUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgX2dldFZpZXdwb3J0T3ZlcmZsb3dIaWRlT2Zmc2V0ID0gKHZpZXdwb3J0T3ZlcmZsb3dTdHlsZTogWFk8T3ZlcmZsb3dTdHlsZT4pID0+IHtcclxuICAgICAgICAgIGNvbnN0IGFycmFuZ2VIaWRlT2Zmc2V0ID1cclxuICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmcgfHwgc2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFycyA/IDAgOiA0MjtcclxuXHJcbiAgICAgICAgICBjb25zdCBnZXRIaWRlT2Zmc2V0UGVyQXhpcyA9IChcclxuICAgICAgICAgICAgaXNPdmVybGFpZDogYm9vbGVhbixcclxuICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGw6IGJvb2xlYW4sXHJcbiAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhclNpemU6IG51bWJlclxyXG4gICAgICAgICAgKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vblNjcm9sbGJhclN0eWxpbmdIaWRlT2Zmc2V0ID0gaXNPdmVybGFpZFxyXG4gICAgICAgICAgICAgID8gYXJyYW5nZUhpZGVPZmZzZXRcclxuICAgICAgICAgICAgICA6IG5hdGl2ZVNjcm9sbGJhclNpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbGJhcnNIaWRlT2Zmc2V0ID1cclxuICAgICAgICAgICAgICBvdmVyZmxvd1Njcm9sbCAmJiAhX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmcgPyBub25TY3JvbGxiYXJTdHlsaW5nSGlkZU9mZnNldCA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbGJhcnNIaWRlT2Zmc2V0QXJyYW5nZSA9IGlzT3ZlcmxhaWQgJiYgISFhcnJhbmdlSGlkZU9mZnNldDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbc2Nyb2xsYmFyc0hpZGVPZmZzZXQsIHNjcm9sbGJhcnNIaWRlT2Zmc2V0QXJyYW5nZV0gYXMgY29uc3Q7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IFt4U2Nyb2xsYmFyc0hpZGVPZmZzZXQsIHhTY3JvbGxiYXJzSGlkZU9mZnNldEFycmFuZ2VdID0gZ2V0SGlkZU9mZnNldFBlckF4aXMoXHJcbiAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQueCxcclxuICAgICAgICAgICAgdmlld3BvcnRPdmVyZmxvd1N0eWxlLnggPT09IHN0clNjcm9sbCxcclxuICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhcnNTaXplLnhcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjb25zdCBbeVNjcm9sbGJhcnNIaWRlT2Zmc2V0LCB5U2Nyb2xsYmFyc0hpZGVPZmZzZXRBcnJhbmdlXSA9IGdldEhpZGVPZmZzZXRQZXJBeGlzKFxyXG4gICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLnksXHJcbiAgICAgICAgICAgIHZpZXdwb3J0T3ZlcmZsb3dTdHlsZS55ID09PSBzdHJTY3JvbGwsXHJcbiAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJzU2l6ZS55XHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF9zY3JvbGxiYXJzSGlkZU9mZnNldDoge1xyXG4gICAgICAgICAgICAgIHg6IHhTY3JvbGxiYXJzSGlkZU9mZnNldCxcclxuICAgICAgICAgICAgICB5OiB5U2Nyb2xsYmFyc0hpZGVPZmZzZXQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9zY3JvbGxiYXJzSGlkZU9mZnNldEFycmFuZ2U6IHtcclxuICAgICAgICAgICAgICB4OiB4U2Nyb2xsYmFyc0hpZGVPZmZzZXRBcnJhbmdlLFxyXG4gICAgICAgICAgICAgIHk6IHlTY3JvbGxiYXJzSGlkZU9mZnNldEFycmFuZ2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhpZGVzIHRoZSBuYXRpdmUgc2Nyb2xsYmFycyBhY2NvcmRpbmcgdG8gdGhlIHBhc3NlZCBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB2aWV3cG9ydE92ZXJmbG93U3R5bGUgVGhlIHZpZXdwb3J0IG92ZXJmbG93IHN0eWxlLlxyXG4gICAgICAgICAqIEBwYXJhbSBkaXJlY3Rpb25Jc1JUTCBXaGV0aGVyIHRoZSBkaXJlY3Rpb24gaXMgUlRMIG9yIG5vdC5cclxuICAgICAgICAgKiBAcGFyYW0gdmlld3BvcnRBcnJhbmdlIFdoZXRoZXIgc3BlY2lhbCBzdHlsZXMgcmVsYXRlZCB0byB0aGUgdmlld3BvcnQgYXJyYW5nZSBzdHJhdGVneSBzaGFsbCBiZSBhcHBsaWVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB2aWV3cG9ydFN0eWxlT2JqIFRoZSB2aWV3cG9ydCBzdHlsZSBvYmplY3QgdG8gd2hpY2ggdGhlIG5lZWRlZCBzdHlsZXMgc2hhbGwgYmUgYXBwbGllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBfaGlkZU5hdGl2ZVNjcm9sbGJhcnMgPSAoXHJcbiAgICAgICAgICB2aWV3cG9ydE92ZXJmbG93U3R5bGU6IFhZPE92ZXJmbG93U3R5bGU+XHJcbiAgICAgICAgKTogU3R5bGVPYmplY3QgfCB1bmRlZmluZWQgPT4ge1xyXG4gICAgICAgICAgaWYgKCFfdmlld3BvcnRJc1RhcmdldCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IF9kaXJlY3Rpb25Jc1JUTCB9ID0gb2JzZXJ2ZXJzU2V0dXBTdGF0ZTtcclxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRTdHlsZU9iajogU3R5bGVPYmplY3QgPSBhc3NpZ25EZWVwKFxyXG4gICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFtzdHJNYXJnaW5SaWdodF06IDAsXHJcbiAgICAgICAgICAgICAgICBbc3RyTWFyZ2luQm90dG9tXTogMCxcclxuICAgICAgICAgICAgICAgIFtzdHJNYXJnaW5MZWZ0XTogMCxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgX3Njcm9sbGJhcnNIaWRlT2Zmc2V0LCBfc2Nyb2xsYmFyc0hpZGVPZmZzZXRBcnJhbmdlIH0gPVxyXG4gICAgICAgICAgICAgIF9nZXRWaWV3cG9ydE92ZXJmbG93SGlkZU9mZnNldCh2aWV3cG9ydE92ZXJmbG93U3R5bGUpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHg6IGFycmFuZ2VYLCB5OiBhcnJhbmdlWSB9ID0gX3Njcm9sbGJhcnNIaWRlT2Zmc2V0QXJyYW5nZTtcclxuICAgICAgICAgICAgY29uc3QgeyB4OiBoaWRlT2Zmc2V0WCwgeTogaGlkZU9mZnNldFkgfSA9IF9zY3JvbGxiYXJzSGlkZU9mZnNldDtcclxuICAgICAgICAgICAgY29uc3QgeyBfdmlld3BvcnRQYWRkaW5nU3R5bGUgfSA9IHN0cnVjdHVyZVNldHVwU3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWxNYXJnaW5LZXk6IGtleW9mIFN0eWxlT2JqZWN0ID0gX2RpcmVjdGlvbklzUlRMXHJcbiAgICAgICAgICAgICAgPyBzdHJNYXJnaW5MZWZ0XHJcbiAgICAgICAgICAgICAgOiBzdHJNYXJnaW5SaWdodDtcclxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRIb3Jpem9udGFsUGFkZGluZ0tleToga2V5b2YgU3R5bGVPYmplY3QgPSBfZGlyZWN0aW9uSXNSVExcclxuICAgICAgICAgICAgICA/IHN0clBhZGRpbmdMZWZ0XHJcbiAgICAgICAgICAgICAgOiBzdHJQYWRkaW5nUmlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWxNYXJnaW5WYWx1ZSA9IF92aWV3cG9ydFBhZGRpbmdTdHlsZVtob3Jpem9udGFsTWFyZ2luS2V5XSBhcyBudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsTWFyZ2luVmFsdWUgPSBfdmlld3BvcnRQYWRkaW5nU3R5bGVbc3RyTWFyZ2luQm90dG9tXSBhcyBudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWxQYWRkaW5nVmFsdWUgPSBfdmlld3BvcnRQYWRkaW5nU3R5bGVbXHJcbiAgICAgICAgICAgICAgdmlld3BvcnRIb3Jpem9udGFsUGFkZGluZ0tleVxyXG4gICAgICAgICAgICBdIGFzIG51bWJlcjtcclxuICAgICAgICAgICAgY29uc3QgdmVydGljYWxQYWRkaW5nVmFsdWUgPSBfdmlld3BvcnRQYWRkaW5nU3R5bGVbc3RyUGFkZGluZ0JvdHRvbV0gYXMgbnVtYmVyO1xyXG5cclxuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICB2aWV3cG9ydFN0eWxlT2JqW3N0cldpZHRoXSA9IGBjYWxjKDEwMCUgKyAke1xyXG4gICAgICAgICAgICAgIGhpZGVPZmZzZXRZICsgaG9yaXpvbnRhbE1hcmdpblZhbHVlICogLTFcclxuICAgICAgICAgICAgfXB4KWA7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0U3R5bGVPYmpbaG9yaXpvbnRhbE1hcmdpbktleV0gPSAtaGlkZU9mZnNldFkgKyBob3Jpem9udGFsTWFyZ2luVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICB2aWV3cG9ydFN0eWxlT2JqW3N0ck1hcmdpbkJvdHRvbV0gPSAtaGlkZU9mZnNldFggKyB2ZXJ0aWNhbE1hcmdpblZhbHVlO1xyXG5cclxuICAgICAgICAgICAgLy8gdmlld3BvcnQgYXJyYW5nZSBhZGRpdGlvbmFsIHN0eWxlc1xyXG4gICAgICAgICAgICBpZiAoZG9WaWV3cG9ydEFycmFuZ2UpIHtcclxuICAgICAgICAgICAgICB2aWV3cG9ydFN0eWxlT2JqW3ZpZXdwb3J0SG9yaXpvbnRhbFBhZGRpbmdLZXldID1cclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxQYWRkaW5nVmFsdWUgKyAoYXJyYW5nZVkgPyBoaWRlT2Zmc2V0WSA6IDApO1xyXG4gICAgICAgICAgICAgIHZpZXdwb3J0U3R5bGVPYmpbc3RyUGFkZGluZ0JvdHRvbV0gPVxyXG4gICAgICAgICAgICAgICAgdmVydGljYWxQYWRkaW5nVmFsdWUgKyAoYXJyYW5nZVggPyBoaWRlT2Zmc2V0WCA6IDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmlld3BvcnRTdHlsZU9iajtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBzdHlsZXMgb2YgdGhlIHZpZXdwb3J0IGFycmFuZ2UgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0gdmlld3BvcnRPdmVyZmxvd1N0eWxlIFRoZSB2aWV3cG9ydCBvdmVyZmxvdyBzdHlsZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIHNjcm9sbGJhcnMgc2hhbGwgYmUgaGlkZGVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB2aWV3cG9ydFNjcm9sbFNpemUgVGhlIGNvbnRlbnQgc2Nyb2xsIHNpemUuXHJcbiAgICAgICAgICogQHBhcmFtIGRpcmVjdGlvbklzUlRMIFdoZXRoZXIgdGhlIGRpcmVjdGlvbiBpcyBSVEwgb3Igbm90LlxyXG4gICAgICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdmlld3BvcnQgYXJyYW5nZSBlbGVtZW50IHdhcyBhZGp1c3RlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBfYXJyYW5nZVZpZXdwb3J0ID0gKFxyXG4gICAgICAgICAgdmlld3BvcnRPdmVyZmxvd1N0eWxlOiBYWTxPdmVyZmxvd1N0eWxlPixcclxuICAgICAgICAgIHZpZXdwb3J0U2Nyb2xsU2l6ZTogV0g8bnVtYmVyPixcclxuICAgICAgICAgIHNpemVGcmFjdGlvbjogV0g8bnVtYmVyPlxyXG4gICAgICAgICkgPT4ge1xyXG4gICAgICAgICAgaWYgKGRvVmlld3BvcnRBcnJhbmdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgX3ZpZXdwb3J0UGFkZGluZ1N0eWxlIH0gPSBzdHJ1Y3R1cmVTZXR1cFN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCB7IF9zY3JvbGxiYXJzSGlkZU9mZnNldCwgX3Njcm9sbGJhcnNIaWRlT2Zmc2V0QXJyYW5nZSB9ID1cclxuICAgICAgICAgICAgICBfZ2V0Vmlld3BvcnRPdmVyZmxvd0hpZGVPZmZzZXQodmlld3BvcnRPdmVyZmxvd1N0eWxlKTtcclxuICAgICAgICAgICAgY29uc3QgeyB4OiBhcnJhbmdlWCwgeTogYXJyYW5nZVkgfSA9IF9zY3JvbGxiYXJzSGlkZU9mZnNldEFycmFuZ2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeDogaGlkZU9mZnNldFgsIHk6IGhpZGVPZmZzZXRZIH0gPSBfc2Nyb2xsYmFyc0hpZGVPZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgX2RpcmVjdGlvbklzUlRMIH0gPSBvYnNlcnZlcnNTZXR1cFN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydEFycmFuZ2VIb3Jpem9udGFsUGFkZGluZ0tleToga2V5b2YgU3R5bGVPYmplY3QgPSBfZGlyZWN0aW9uSXNSVExcclxuICAgICAgICAgICAgICA/IHN0clBhZGRpbmdSaWdodFxyXG4gICAgICAgICAgICAgIDogc3RyUGFkZGluZ0xlZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0QXJyYW5nZUhvcml6b250YWxQYWRkaW5nVmFsdWUgPSBfdmlld3BvcnRQYWRkaW5nU3R5bGVbXHJcbiAgICAgICAgICAgICAgdmlld3BvcnRBcnJhbmdlSG9yaXpvbnRhbFBhZGRpbmdLZXlcclxuICAgICAgICAgICAgXSBhcyBudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0QXJyYW5nZVZlcnRpY2FsUGFkZGluZ1ZhbHVlID0gX3ZpZXdwb3J0UGFkZGluZ1N0eWxlLnBhZGRpbmdUb3AgYXMgbnVtYmVyO1xyXG4gICAgICAgICAgICBjb25zdCBmcmFjdGlvbmFsQ29udGVudFdpZHRoID0gdmlld3BvcnRTY3JvbGxTaXplLncgKyBzaXplRnJhY3Rpb24udztcclxuICAgICAgICAgICAgY29uc3QgZnJhY3Rpb25hbENvbnRlbkhlaWdodCA9IHZpZXdwb3J0U2Nyb2xsU2l6ZS5oICsgc2l6ZUZyYWN0aW9uLmg7XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmFuZ2VTaXplID0ge1xyXG4gICAgICAgICAgICAgIHc6XHJcbiAgICAgICAgICAgICAgICBoaWRlT2Zmc2V0WSAmJiBhcnJhbmdlWVxyXG4gICAgICAgICAgICAgICAgICA/IGAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgaGlkZU9mZnNldFkgKyBmcmFjdGlvbmFsQ29udGVudFdpZHRoIC0gdmlld3BvcnRBcnJhbmdlSG9yaXpvbnRhbFBhZGRpbmdWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1weGBcclxuICAgICAgICAgICAgICAgICAgOiAnJyxcclxuICAgICAgICAgICAgICBoOlxyXG4gICAgICAgICAgICAgICAgaGlkZU9mZnNldFggJiYgYXJyYW5nZVhcclxuICAgICAgICAgICAgICAgICAgPyBgJHtcclxuICAgICAgICAgICAgICAgICAgICAgIGhpZGVPZmZzZXRYICsgZnJhY3Rpb25hbENvbnRlbkhlaWdodCAtIHZpZXdwb3J0QXJyYW5nZVZlcnRpY2FsUGFkZGluZ1ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfXB4YFxyXG4gICAgICAgICAgICAgICAgICA6ICcnLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2V0U3R5bGVzKF92aWV3cG9ydCwge1xyXG4gICAgICAgICAgICAgICctLW9zLXZhdyc6IGFycmFuZ2VTaXplLncsXHJcbiAgICAgICAgICAgICAgJy0tb3MtdmFoJzogYXJyYW5nZVNpemUuaCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGRvVmlld3BvcnRBcnJhbmdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIHN0eWxlcyBhcHBsaWVkIGJlY2F1c2Ugb2YgdGhlIHZpZXdwb3J0IGFycmFuZ2Ugc3RyYXRlZ3kuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgX3VuZG9WaWV3cG9ydEFycmFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZG9WaWV3cG9ydEFycmFuZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBfaGFzT3ZlcmZsb3csIF92aWV3cG9ydFBhZGRpbmdTdHlsZTogdmlld3BvcnRQYWRkaW5nU3R5bGUgfSA9XHJcbiAgICAgICAgICAgICAgc3RydWN0dXJlU2V0dXBTdGF0ZTtcclxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRPdmVyZmxvd1N0eWxlID0gZ2V0RWxlbWVudE92ZXJmbG93U3R5bGUoX3ZpZXdwb3J0LCBfaGFzT3ZlcmZsb3cpO1xyXG4gICAgICAgICAgICBjb25zdCB7IF9zY3JvbGxiYXJzSGlkZU9mZnNldEFycmFuZ2UgfSA9XHJcbiAgICAgICAgICAgICAgX2dldFZpZXdwb3J0T3ZlcmZsb3dIaWRlT2Zmc2V0KHZpZXdwb3J0T3ZlcmZsb3dTdHlsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeDogYXJyYW5nZVgsIHk6IGFycmFuZ2VZIH0gPSBfc2Nyb2xsYmFyc0hpZGVPZmZzZXRBcnJhbmdlO1xyXG4gICAgICAgICAgICBjb25zdCBmaW5hbFBhZGRpbmdTdHlsZTogU3R5bGVPYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgY29uc3QgYXNzaWduUHJvcHMgPSAocHJvcHM6IHN0cmluZ1tdKSA9PlxyXG4gICAgICAgICAgICAgIGVhY2gocHJvcHMsIChwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbFBhZGRpbmdTdHlsZVtwcm9wIGFzIFN0eWxlT2JqZWN0S2V5XSA9XHJcbiAgICAgICAgICAgICAgICAgIHZpZXdwb3J0UGFkZGluZ1N0eWxlW3Byb3AgYXMgU3R5bGVPYmplY3RLZXldO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycmFuZ2VYKSB7XHJcbiAgICAgICAgICAgICAgYXNzaWduUHJvcHMoW3N0ck1hcmdpbkJvdHRvbSwgc3RyUGFkZGluZ1RvcCwgc3RyUGFkZGluZ0JvdHRvbV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyYW5nZVkpIHtcclxuICAgICAgICAgICAgICBhc3NpZ25Qcm9wcyhbc3RyTWFyZ2luTGVmdCwgc3RyTWFyZ2luUmlnaHQsIHN0clBhZGRpbmdMZWZ0LCBzdHJQYWRkaW5nUmlnaHRdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcHJldlN0eWxlID0gZ2V0U3R5bGVzKF92aWV3cG9ydCwga2V5cyhmaW5hbFBhZGRpbmdTdHlsZSkgYXMgU3R5bGVPYmplY3RLZXlbXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZEFycmFuZ2UgPSByZW1vdmVBdHRyQ2xhc3MoXHJcbiAgICAgICAgICAgICAgX3ZpZXdwb3J0LFxyXG4gICAgICAgICAgICAgIGRhdGFBdHRyaWJ1dGVWaWV3cG9ydCxcclxuICAgICAgICAgICAgICBkYXRhVmFsdWVWaWV3cG9ydEFycmFuZ2VcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHNldFN0eWxlcyhfdmlld3BvcnQsIGZpbmFsUGFkZGluZ1N0eWxlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgc2V0U3R5bGVzKFxyXG4gICAgICAgICAgICAgICAgX3ZpZXdwb3J0LFxyXG4gICAgICAgICAgICAgICAgYXNzaWduRGVlcCh7fSwgcHJldlN0eWxlLCBfaGlkZU5hdGl2ZVNjcm9sbGJhcnModmlld3BvcnRPdmVyZmxvd1N0eWxlKSlcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIGFkZEFycmFuZ2UoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBfYXJyYW5nZVZpZXdwb3J0LFxyXG4gICAgICAgICAgX3VuZG9WaWV3cG9ydEFycmFuZ2UsXHJcbiAgICAgICAgICBfaGlkZU5hdGl2ZVNjcm9sbGJhcnMsXHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gIH0sXHJcbn0pKSgpIHNhdGlzZmllcyBTdGF0aWNQbHVnaW48dHlwZW9mIHNjcm9sbGJhcnNIaWRpbmdQbHVnaW5OYW1lPjtcclxuIiwiaW1wb3J0IHR5cGUgeyBTdGF0aWNQbHVnaW4gfSBmcm9tICcuLi9wbHVnaW5zJztcclxuaW1wb3J0IHsgYW5pbWF0ZU51bWJlciwgbm9vcCwgc2VsZkNsZWFyVGltZW91dCB9IGZyb20gJy4uLy4uL3N1cHBvcnQnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNsaWNrU2Nyb2xsUGx1Z2luTW9kdWxlTmFtZSA9ICdfX29zQ2xpY2tTY3JvbGxQbHVnaW4nO1xyXG5cclxuZXhwb3J0IGNvbnN0IENsaWNrU2Nyb2xsUGx1Z2luID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xyXG4gIFtjbGlja1Njcm9sbFBsdWdpbk1vZHVsZU5hbWVdOiB7XHJcbiAgICBzdGF0aWM6XHJcbiAgICAgICgpID0+XHJcbiAgICAgIChcclxuICAgICAgICBtb3ZlSGFuZGxlUmVsYXRpdmU6IChkZWx0YU1vdmVtZW50OiBudW1iZXIpID0+IHZvaWQsXHJcbiAgICAgICAgdGFyZ2V0T2Zmc2V0OiBudW1iZXIsXHJcbiAgICAgICAgaGFuZGxlTGVuZ3RoOiBudW1iZXIsXHJcbiAgICAgICAgb25DbGlja1Njcm9sbENvbXBsZXRlZDogKHN0b3BwZWQ6IGJvb2xlYW4pID0+IHZvaWRcclxuICAgICAgKSA9PiB7XHJcbiAgICAgICAgLy8gY2xpY2sgc2Nyb2xsIGFuaW1hdGlvbiBoYXMgMiBtYWluIHBhcnRzOlxyXG4gICAgICAgIC8vIDEuIHRoZSBcImNsaWNrXCIgd2hpY2ggc2Nyb2xscyAxMDAlIG9mIHRoZSB2aWV3cG9ydCBpbiBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWVcclxuICAgICAgICAvLyAyLiB0aGUgXCJwcmVzc1wiIHdoaWNoIHNjcm9sbHMgdG8gdGhlIHBvaW50IHdoZXJlIHRoZSBjdXJzb3IgaXMgbG9jYXRlZCwgdGhlIFwicHJlc3NcIiBhbHdheXMgd2FpdHMgZm9yIHRoZSBcImNsaWNrXCIgdG8gZmluaXNoXHJcbiAgICAgICAgLy8gVGhlIFwiY2xpY2tcIiBzaG91bGQgbm90IGJlIGNhbmNlbGVkIGJ5IGEgXCJwb2ludGVydXBcIiBldmVudCBiZWNhdXNlIHZlcnkgZmFzdCBjbGlja3Mgb3IgdGFwcyB3b3VsZCBjYW5jZWwgaXQgdG9vIGZhc3RcclxuICAgICAgICAvLyBUaGUgXCJjbGlja1wiIHNob3VsZCBvbmx5IGJlIGNhbmNlbGVkIGJ5IGEgc3Vic2VxdWVudCBcInBvaW50ZXJkb3duXCIgZXZlbnQgYmVjYXVzZSBvdGhlcndpc2UgMiBhbmltYXRpb25zIHdvdWxkIHJ1blxyXG4gICAgICAgIC8vIFRoZSBcInByZXNzXCIgc2hvdWxkIGJlIGNhbmNlbGQgYnkgdGhlIG5leHQgXCJwb2ludGVydXBcIiBldmVudFxyXG5cclxuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBzdG9wUHJlc3NBbmltYXRpb24gPSBub29wO1xyXG4gICAgICAgIGNvbnN0IGxpbmVhclNjcm9sbE1zID0gMTMzO1xyXG4gICAgICAgIGNvbnN0IGVhc2VkU2Nyb2xsTXMgPSAyMjI7XHJcbiAgICAgICAgY29uc3QgW3NldFByZXNzQW5pbWF0aW9uVGltZW91dCwgY2xlYXJQcmVzc0FuaW1hdGlvblRpbWVvdXRdID1cclxuICAgICAgICAgIHNlbGZDbGVhclRpbWVvdXQobGluZWFyU2Nyb2xsTXMpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE9mZnNldFNpZ24gPSBNYXRoLnNpZ24odGFyZ2V0T2Zmc2V0KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVMZW5ndGhXaXRoVGFyZ2V0U2lnbiA9IGhhbmRsZUxlbmd0aCAqIHRhcmdldE9mZnNldFNpZ247XHJcbiAgICAgICAgY29uc3QgaGFuZGxlTGVuZ3RoV2l0aFRhcmdldFNpZ25IYWxmID0gaGFuZGxlTGVuZ3RoV2l0aFRhcmdldFNpZ24gLyAyO1xyXG4gICAgICAgIGNvbnN0IGVhc2luZyA9ICh4OiBudW1iZXIpID0+IDEgLSAoMSAtIHgpICogKDEgLSB4KTsgLy8gZWFzZU91dFF1YWQ7XHJcbiAgICAgICAgY29uc3QgZWFzZWRFbmRQcmVzc0FuaW1hdGlvbiA9IChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+XHJcbiAgICAgICAgICBhbmltYXRlTnVtYmVyKGZyb20sIHRvLCBlYXNlZFNjcm9sbE1zLCBtb3ZlSGFuZGxlUmVsYXRpdmUsIGVhc2luZyk7XHJcbiAgICAgICAgY29uc3QgbGluZWFyUHJlc3NBbmltYXRpb24gPSAobGluZWFyRnJvbTogbnVtYmVyLCBtc0ZhY3RvcjogbnVtYmVyKSA9PlxyXG4gICAgICAgICAgYW5pbWF0ZU51bWJlcihcclxuICAgICAgICAgICAgbGluZWFyRnJvbSxcclxuICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0IC0gaGFuZGxlTGVuZ3RoV2l0aFRhcmdldFNpZ24sXHJcbiAgICAgICAgICAgIGxpbmVhclNjcm9sbE1zICogbXNGYWN0b3IsXHJcbiAgICAgICAgICAgIChwcm9ncmVzcywgXywgY29tcGxldGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgbW92ZUhhbmRsZVJlbGF0aXZlKHByb2dyZXNzKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgc3RvcFByZXNzQW5pbWF0aW9uID0gZWFzZWRFbmRQcmVzc0FuaW1hdGlvbihwcm9ncmVzcywgdGFyZ2V0T2Zmc2V0KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgY29uc3Qgc3RvcENsaWNrQW5pbWF0aW9uID0gYW5pbWF0ZU51bWJlcihcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBoYW5kbGVMZW5ndGhXaXRoVGFyZ2V0U2lnbixcclxuICAgICAgICAgIGVhc2VkU2Nyb2xsTXMsXHJcbiAgICAgICAgICAoY2xpY2tBbmltYXRpb25Qcm9ncmVzcywgXywgY2xpY2tBbmltYXRpb25Db21wbGV0ZWQpID0+IHtcclxuICAgICAgICAgICAgbW92ZUhhbmRsZVJlbGF0aXZlKGNsaWNrQW5pbWF0aW9uUHJvZ3Jlc3MpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNsaWNrQW5pbWF0aW9uQ29tcGxldGVkKSB7XHJcbiAgICAgICAgICAgICAgb25DbGlja1Njcm9sbENvbXBsZXRlZChzdG9wcGVkKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdTY3JvbGxEaXN0YW5jZSA9IHRhcmdldE9mZnNldCAtIGNsaWNrQW5pbWF0aW9uUHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250aW51ZVdpdGhQcmVzcyA9XHJcbiAgICAgICAgICAgICAgICAgIE1hdGguc2lnbihyZW1haW5pbmdTY3JvbGxEaXN0YW5jZSAtIGhhbmRsZUxlbmd0aFdpdGhUYXJnZXRTaWduSGFsZikgPT09XHJcbiAgICAgICAgICAgICAgICAgIHRhcmdldE9mZnNldFNpZ247XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlV2l0aFByZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNldFByZXNzQW5pbWF0aW9uVGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nTGluZWFyU2Nyb2xsRGlzdGFuY2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nU2Nyb2xsRGlzdGFuY2UgLSBoYW5kbGVMZW5ndGhXaXRoVGFyZ2V0U2lnbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lYXJCcmlkZ2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaWduKHJlbWFpbmluZ0xpbmVhclNjcm9sbERpc3RhbmNlKSA9PT0gdGFyZ2V0T2Zmc2V0U2lnbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcFByZXNzQW5pbWF0aW9uID0gbGluZWFyQnJpZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IGxpbmVhclByZXNzQW5pbWF0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrQW5pbWF0aW9uUHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocmVtYWluaW5nTGluZWFyU2Nyb2xsRGlzdGFuY2UpIC8gaGFuZGxlTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogZWFzZWRFbmRQcmVzc0FuaW1hdGlvbihjbGlja0FuaW1hdGlvblByb2dyZXNzLCB0YXJnZXRPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBlYXNpbmdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gKHN0b3BDbGljaz86IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIGlmIChzdG9wQ2xpY2spIHtcclxuICAgICAgICAgICAgc3RvcENsaWNrQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY2xlYXJQcmVzc0FuaW1hdGlvblRpbWVvdXQoKTtcclxuICAgICAgICAgIHN0b3BQcmVzc0FuaW1hdGlvbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgfSxcclxufSkpKCkgc2F0aXNmaWVzIFN0YXRpY1BsdWdpbjx0eXBlb2YgY2xpY2tTY3JvbGxQbHVnaW5Nb2R1bGVOYW1lPjtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xyXG5pbXBvcnQgdHlwZSB7IERlZXBQYXJ0aWFsLCBEZWVwUmVhZG9ubHkgfSBmcm9tICcuL3R5cGluZ3MnO1xyXG5pbXBvcnQge1xyXG4gIGFzc2lnbkRlZXAsXHJcbiAgZWFjaCxcclxuICBpc09iamVjdCxcclxuICBrZXlzLFxyXG4gIGlzQXJyYXksXHJcbiAgaGFzT3duUHJvcGVydHksXHJcbiAgaXNGdW5jdGlvbixcclxuICBpc0VtcHR5T2JqZWN0LFxyXG4gIGNvbmNhdCxcclxufSBmcm9tICcuL3N1cHBvcnQnO1xyXG5cclxuZXhwb3J0IHR5cGUgT3B0aW9uc0ZpZWxkID0gc3RyaW5nO1xyXG5cclxuZXhwb3J0IHR5cGUgT3B0aW9uc1ByaW1pdGl2ZVZhbHVlID1cclxuICB8IGJvb2xlYW5cclxuICB8IG51bWJlclxyXG4gIHwgc3RyaW5nXHJcbiAgfCBBcnJheTxhbnk+XHJcbiAgfCBSZWFkb25seUFycmF5PGFueT5cclxuICB8IFthbnldXHJcbiAgfCBbYW55LCAuLi5hbnlbXV1cclxuICB8ICgodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KVxyXG4gIHwgbnVsbDtcclxuXHJcbmV4cG9ydCB0eXBlIE9wdGlvbnNPYmplY3QgPSB7XHJcbiAgW2ZpZWxkOiBPcHRpb25zRmllbGRdOiBPcHRpb25zUHJpbWl0aXZlVmFsdWUgfCBPcHRpb25zT2JqZWN0O1xyXG59O1xyXG5cclxudHlwZSBPcHRpb25zT2JqZWN0RmllbGROYW1lVHVwbGVzPFQ+ID0gVCBleHRlbmRzIE9wdGlvbnNQcmltaXRpdmVWYWx1ZVxyXG4gID8gW11cclxuICA6IHtcclxuICAgICAgW0sgaW4gRXh0cmFjdDxrZXlvZiBULCBPcHRpb25zRmllbGQ+XTogW0ssIC4uLk9wdGlvbnNPYmplY3RGaWVsZE5hbWVUdXBsZXM8VFtLXT5dO1xyXG4gICAgfVtFeHRyYWN0PGtleW9mIFQsIE9wdGlvbnNGaWVsZD5dO1xyXG5cclxudHlwZSBKb2luT3B0aW9uc09iamVjdEZpZWxkVHVwbGVzPFxyXG4gIFQgZXh0ZW5kcyBPcHRpb25zRmllbGRbXSxcclxuICBJbmNvbXBsZXRlUGF0aCBleHRlbmRzIGJvb2xlYW4gPSBmYWxzZSxcclxuPiA9IFQgZXh0ZW5kcyBbaW5mZXIgRl1cclxuICA/IEZcclxuICA6IFQgZXh0ZW5kcyBbaW5mZXIgRiwgLi4uaW5mZXIgUl1cclxuICAgID8gRiBleHRlbmRzIE9wdGlvbnNGaWVsZFxyXG4gICAgICA/XHJcbiAgICAgICAgICB8IChJbmNvbXBsZXRlUGF0aCBleHRlbmRzIHRydWUgPyBGIDogbmV2ZXIpXHJcbiAgICAgICAgICB8IGAke0Z9LiR7Sm9pbk9wdGlvbnNPYmplY3RGaWVsZFR1cGxlczxFeHRyYWN0PFIsIE9wdGlvbnNGaWVsZFtdPj59YFxyXG4gICAgICA6IG5ldmVyXHJcbiAgICA6IE9wdGlvbnNGaWVsZDtcclxuXHJcbnR5cGUgU3BsaXRKb2luZWRPcHRpb25zT2JqZWN0RmllbGRUdXBsZXM8UyBleHRlbmRzIHN0cmluZz4gPSBzdHJpbmcgZXh0ZW5kcyBTXHJcbiAgPyBPcHRpb25zRmllbGRbXVxyXG4gIDogUyBleHRlbmRzICcnXHJcbiAgICA/IFtdXHJcbiAgICA6IFMgZXh0ZW5kcyBgJHtpbmZlciBUfS4ke2luZmVyIFV9YFxyXG4gICAgICA/IFtULCAuLi5TcGxpdEpvaW5lZE9wdGlvbnNPYmplY3RGaWVsZFR1cGxlczxVPl1cclxuICAgICAgOiBbU107XHJcblxyXG50eXBlIE9wdGlvbnNPYmplY3RGaWVsZFR1cGxlc1R5cGU8TywgVCBleHRlbmRzIE9wdGlvbnNGaWVsZFtdPiA9IFQgZXh0ZW5kcyBbaW5mZXIgRl1cclxuICA/IEYgZXh0ZW5kcyBrZXlvZiBPXHJcbiAgICA/IE9bRl1cclxuICAgIDogbmV2ZXJcclxuICA6IFQgZXh0ZW5kcyBbaW5mZXIgRiwgLi4uaW5mZXIgUl1cclxuICAgID8gRiBleHRlbmRzIGtleW9mIE9cclxuICAgICAgPyBPW0ZdIGV4dGVuZHMgT3B0aW9uc1ByaW1pdGl2ZVZhbHVlXHJcbiAgICAgICAgPyBPW0ZdXHJcbiAgICAgICAgOiBPcHRpb25zT2JqZWN0RmllbGRUdXBsZXNUeXBlPE9bRl0sIEV4dHJhY3Q8UiwgT3B0aW9uc0ZpZWxkW10+PlxyXG4gICAgICA6IG5ldmVyXHJcbiAgICA6IG5ldmVyO1xyXG5cclxudHlwZSBPcHRpb25zT2JqZWN0RmllbGRQYXRoPE8gZXh0ZW5kcyBPcHRpb25zT2JqZWN0PiA9IEpvaW5PcHRpb25zT2JqZWN0RmllbGRUdXBsZXM8XHJcbiAgT3B0aW9uc09iamVjdEZpZWxkTmFtZVR1cGxlczxPPixcclxuICB0cnVlXHJcbj47XHJcblxyXG50eXBlIE9wdGlvbnNPYmplY3RGaWVsZFBhdGhUeXBlPFxyXG4gIE8gZXh0ZW5kcyBPcHRpb25zT2JqZWN0LFxyXG4gIFAgZXh0ZW5kcyBzdHJpbmcsXHJcbj4gPSBPcHRpb25zT2JqZWN0RmllbGRUdXBsZXNUeXBlPE8sIFNwbGl0Sm9pbmVkT3B0aW9uc09iamVjdEZpZWxkVHVwbGVzPFA+PjtcclxuXHJcbmNvbnN0IG9wc1N0cmluZ2lmeSA9ICh2YWx1ZTogYW55KSA9PlxyXG4gIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoXywgdmFsKSA9PiB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XHJcbiAgICAgIHRocm93IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG4gIH0pO1xyXG5cclxuY29uc3QgZ2V0UHJvcEJ5UGF0aCA9IDxUPihvYmo6IGFueSwgcGF0aDogc3RyaW5nKTogVCA9PlxyXG4gIG9ialxyXG4gICAgPyBgJHtwYXRofWBcclxuICAgICAgICAuc3BsaXQoJy4nKVxyXG4gICAgICAgIC5yZWR1Y2UoKG8sIHByb3ApID0+IChvICYmIGhhc093blByb3BlcnR5KG8sIHByb3ApID8gb1twcm9wXSA6IHVuZGVmaW5lZCksIG9iailcclxuICAgIDogKHVuZGVmaW5lZCBhcyBUKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgb3ZlcmZsb3cgYmVoYXZpb3Igb2YgYW4gYXhpcy5cclxuICovXHJcbmV4cG9ydCB0eXBlIE92ZXJmbG93QmVoYXZpb3IgPVxyXG4gIC8qKiBObyBzY3JvbGxpbmcgaXMgcG9zc2libGUgYW5kIHRoZSBjb250ZW50IGlzIGNsaXBwZWQuICovXHJcbiAgfCAnaGlkZGVuJ1xyXG4gIC8qKiBObyBzY3JvbGxpbmcgaXMgcG9zc2libGUgYW5kIHRoZSBjb250ZW50IGlzbid0IGNsaXBwZWQuICovXHJcbiAgfCAndmlzaWJsZSdcclxuICAvKiogU2Nyb2xsaW5nIGlzIHBvc3NpYmxlIGlmIHRoZXJlIGlzIGFuIG92ZXJmbG93LiAqL1xyXG4gIHwgJ3Njcm9sbCdcclxuICAvKipcclxuICAgKiBJZiB0aGUgb3RoZXIgYXhpcyBoYXMgbm8gb3ZlcmZsb3cgdGhlIGJlaGF2aW9yIGlzIHNpbWlsYXIgdG8gYHZpc2libGVgLlxyXG4gICAqIElmIHRoZSBvdGhlciBheGlzIGhhcyBvdmVyZmxvdyB0aGUgYmVoYXZpb3IgaXMgc2ltaWxhciB0byBgaGlkZGVuYC5cclxuICAgKi9cclxuICB8ICd2aXNpYmxlLWhpZGRlbidcclxuICAvKipcclxuICAgKiBJZiB0aGUgb3RoZXIgYXhpcyBoYXMgbm8gb3ZlcmZsb3cgdGhlIGJlaGF2aW9yIGlzIHNpbWlsYXIgdG8gYHZpc2libGVgLlxyXG4gICAqIElmIHRoZSBvdGhlciBheGlzIGhhcyBvdmVyZmxvdyB0aGUgYmVoYXZpb3IgaXMgc2ltaWxhciB0byBgc2Nyb2xsYC5cclxuICAgKi9cclxuICB8ICd2aXNpYmxlLXNjcm9sbCc7XHJcblxyXG4vKipcclxuICogVGhlIHNjcm9sbGJhcnMgdmlzaWJpbGl0eSBiZWhhdmlvci5cclxuICovXHJcbmV4cG9ydCB0eXBlIFNjcm9sbGJhcnNWaXNpYmlsaXR5QmVoYXZpb3IgPVxyXG4gIC8qKiBUaGUgc2Nyb2xsYmFycyBhcmUgYWx3YXlzIHZpc2libGUuICovXHJcbiAgfCAndmlzaWJsZSdcclxuICAvKiogVGhlIHNjcm9sbGJhcnMgYXJlIGFsd2F5cyBoaWRkZW4uICovXHJcbiAgfCAnaGlkZGVuJ1xyXG4gIC8qKiBUaGUgc2Nyb2xsYmFycyBhcmUgb25seSB2aXNpYmlsZSBpZiB0aGVyZSBpcyBvdmVyZmxvdy4gKi9cclxuICB8ICdhdXRvJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2Nyb2xsYmFycyBhdXRvIGhpZGUgYmVoYXZpb3JcclxuICovXHJcbmV4cG9ydCB0eXBlIFNjcm9sbGJhcnNBdXRvSGlkZUJlaGF2aW9yID1cclxuICAvKiogVGhlIHNjcm9sbGJhcnMgYXJlIG5ldmVyIGhpZGRlbiBhdXRvbWF0aWNhbGx5LiAqL1xyXG4gIHwgJ25ldmVyJ1xyXG4gIC8qKiBUaGUgc2Nyb2xsYmFycyBhcmUgaGlkZGVuIHVubGVzcyB0aGUgdXNlciBzY3JvbGxzLiAqL1xyXG4gIHwgJ3Njcm9sbCdcclxuICAvKiogVGhlIHNjcm9sbGJhcnMgYXJlIGhpZGRlbiB1bmxlc3MgdGhlIHBvaW50ZXIgbW92ZXMgaW4gdGhlIGhvc3QgZWxlbWVudCBvciB0aGUgdXNlciBzY3JvbGxzLiAqL1xyXG4gIHwgJ21vdmUnXHJcbiAgLyoqIFRoZSBzY3JvbGxiYXJzIGFyZSBoaWRkZW4gaWYgdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSBob3N0IGVsZW1lbnQgb3IgdW5sZXNzIHRoZSB1c2VyIHNjcm9sbHMuICovXHJcbiAgfCAnbGVhdmUnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzY3JvbGxiYXIgY2xpY2sgc2Nyb2xsIGJlaGF2aW9yLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU2Nyb2xsYmFyc0NsaWNrU2Nyb2xsQmVoYXZpb3IgPSBib29sZWFuIHwgJ2luc3RhbnQnO1xyXG5cclxuLyoqXHJcbiAqIElmIGEgdHVwbGUgaXMgcHJvdmlkZWQgeW91IGNhbiBjdXN0b21pemUgdGhlIGB0aW1lb3V0YCBhbmQgdGhlIGBtYXhXYWl0YCBpbiBtaWxsaXNlY29uZHMuIFRoZSB0aGlyZCB2YWx1ZSBgbGVhZGluZ2AgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlYm91bmNlIGlzIGFsc28gZXhlY3V0ZWQgb24gdGhlIGxlYWRpbmcgZWRnZS5cclxuICogQSBzaW5nbGUgbnVtYmVyIGN1c3RvbWl6ZXMgdGhlIGB0aW1lb3V0YCBpbiBtaWxsaXNlY29uZHMuXHJcbiAqIElmIHRoZSBgdGltZW91dGAgaXMgYDBgLCBhIGRlYm91bmNlIHN0aWxsIGV4aXN0cy4gKGl0cyBleGVjdXRlZCB2aWEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWApLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgT3B0aW9uc0RlYm91bmNlVmFsdWUgPVxyXG4gIHwgW1xyXG4gICAgICB0aW1lb3V0PzogbnVtYmVyIHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgICBtYXhXYWl0PzogbnVtYmVyIHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgICBsZWFkaW5nPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQsXHJcbiAgICBdXHJcbiAgfCBudW1iZXJcclxuICB8IGZhbHNlXHJcbiAgfCBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgZGVib3VuY2Ugb2JqZWN0IGluc3RlYWQuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBPcHRpb25zRGVib3VuY2VMZWdhY3kgPSBPcHRpb25zRGVib3VuY2VWYWx1ZTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgb3B0aW9ucyBvZiBhIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcclxuICAvKiogV2hldGhlciB0aGUgcGFkZGluZyBzaGFsbCBiZSBhYnNvbHV0ZS4gKi9cclxuICBwYWRkaW5nQWJzb2x1dGU6IGJvb2xlYW47XHJcbiAgLyoqIFdoZXRoZXIgdG8gc2hvdyB0aGUgbmF0aXZlIHNjcm9sbGJhcnMuIEhhcyBvbmx5IGFuIGVmZmVjdCBpdCB0aGUgbmF0aXZlIHNjcm9sbGJhcnMgYXJlIG92ZXJsYWlkLiAqL1xyXG4gIHNob3dOYXRpdmVPdmVybGFpZFNjcm9sbGJhcnM6IGJvb2xlYW47XHJcbiAgLyoqIEN1c3RvbWl6ZXMgdGhlIGF1dG9tYXRpYyB1cGRhdGUgYmVoYXZpb3IuICovXHJcbiAgdXBkYXRlOiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBnaXZlbiBFdmVudChzKSBmcm9tIHRoZSBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvcihzKSB3aWxsIHRyaWdnZXIgYW4gdXBkYXRlLlxyXG4gICAgICogVXNlZnVsIGZvciBldmVyeXRoaW5nIHRoZSBNdXRhdGlvbk9ic2VydmVyIGFuZCBSZXNpemVPYnNlcnZlciBjYW4ndCBkZXRlY3RcclxuICAgICAqIGUuZy46IGFuZCBJbWFnZXMgYGxvYWRgIGV2ZW50IG9yIHRoZSBgdHJhbnNpdGlvbmVuZGAgLyBgYW5pbWF0aW9uZW5kYCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGVsZW1lbnRFdmVudHM6IEFycmF5PFtlbGVtZW50U2VsZWN0b3I6IHN0cmluZywgZXZlbnROYW1lczogc3RyaW5nXT4gfCBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb25zIHRvIGRlYm91bmNlIHVwZGF0ZXMgdG8gZmluZS10dW5lIHBlcmZvcm1hbmNlLlxyXG4gICAgICogSXQgaXMgcG9zc2libGUgdG8gZGVib3VuY2UgdXBkYXRlcyBjYXVzZWQgYnkgbXV0YXRpb25zLCByZXNpemVzLCBldmVudHMgYW5kIGVudmlyb25tZW50YWwgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgZGVib3VuY2U6XHJcbiAgICAgIHwge1xyXG4gICAgICAgICAgLyoqIERlYm91bmNlIHVwZGF0ZXMgd2hpY2ggd2VyZSB0cmlnZ2VyZWQgYnkgYSBNdXRhdGlvbk9ic2VydmVyLiAqL1xyXG4gICAgICAgICAgbXV0YXRpb246IE9wdGlvbnNEZWJvdW5jZVZhbHVlO1xyXG4gICAgICAgICAgLyoqIERlYm91bmNlIHVwZGF0ZXMgd2hpY2ggd2VyZSB0cmlnZ2VyZWQgYnkgYSBSZXNpemVPYnNlcnZlci4gKi9cclxuICAgICAgICAgIHJlc2l6ZTogT3B0aW9uc0RlYm91bmNlVmFsdWU7XHJcbiAgICAgICAgICAvKiogRGVib3VuY2UgdXBkYXRlcyB3aGljaCB3ZXJlIHRyaWdnZXJlZCBieSBhIEV2ZW50LiAqL1xyXG4gICAgICAgICAgZXZlbnQ6IE9wdGlvbnNEZWJvdW5jZVZhbHVlO1xyXG4gICAgICAgICAgLyoqIERlYm91bmNlIHVwZGF0ZXMgd2hpY2ggd2VyZSB0cmlnZ2VyZWQgYnkgZW52aXJvbm1lbnRhbCBjaGFuZ2VzLiAoZS5nLiB6b29taW5nICYgd2luZG93IHJlc2l6ZSkgKi9cclxuICAgICAgICAgIGVudjogT3B0aW9uc0RlYm91bmNlVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB8IE9wdGlvbnNEZWJvdW5jZUxlZ2FjeTtcclxuICAgIC8qKlxyXG4gICAgICogSFRNTCBhdHRyaWJ1dGVzIHdoaWNoIHdpbGwgdHJpZ2dlciBhbiB1cGRhdGUgaWYgdGhleSdyZSBjaGFuZ2VkLlxyXG4gICAgICogQmFzaWMgYXR0cmlidXRlcyBsaWtlIGBpZGAsIGBjbGFzc2AsIGBzdHlsZWAgZXRjLiBhcmUgYWx3YXlzIG9ic2VydmVkIGFuZCBkb2Vzbid0IGhhdmUgdG8gYmUgYWRkZWQgZXhwbGljaXRseS5cclxuICAgICAqL1xyXG4gICAgYXR0cmlidXRlczogc3RyaW5nW10gfCBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGlnbm9yZSBhIGNvbnRlbnQgbXV0YXRpb24gb3IgYG51bGxgIGlmIG5vdGhpbmcgc2hhbGwgYmUgaWdub3JlZC5cclxuICAgICAqIEBwYXJhbSBtdXRhdGlvbiBUaGUgTXV0YXRpb25SZWNvcmQgZnJvbSB0aGUgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAqIEByZXR1cm5zIEEgVHJ1dGh5IHZhbHVlIGlmIHRoZSBtdXRhdGlvbiBzaGFsbCBiZSBpZ25vcmVkLCBhIGZhbHN5IHZhbHVlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaWdub3JlTXV0YXRpb246ICgobXV0YXRpb246IE11dGF0aW9uUmVjb3JkKSA9PiBib29sZWFuKSB8IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIG1hcCBvZiBzdHlsZXMgd2hpY2ggaW5mbHVlbmNlIHRoZSB2aWV3cG9ydHMgZmxvdyBkaXJlY3Rpb24gb3IgYG51bGxgIGlmIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHNoYWxsIGJlIHVzZWQuXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBiZWhhdmlvciByZWFkcyB0aGUgY29tcHV0ZWQgYGRpc3BsYXlgLCBgZmxleERpcmVjdGlvbmAsIGBkaXJlY3Rpb25gIGFuZCBgd3JpdGluZ01vZGVgIHN0eWxlcyBvZiB0aGUgdmlld3BvcnQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHNraXAgb3IgY3VzdG9taXplIHRoZSBleHBlbnNpdmUgXCJub24gZGVmYXVsdCBmbG93IGRpcmVjdGlvblwiIGNoZWNrOlxyXG4gICAgICogVXNlIGFuIGVtcHR5IHN0eWxlIG9iamVjdCB0byBza2lwIHRoZSBjaGVjay5cclxuICAgICAqIE5vbi1lbXB0eSBzdHlsZSBvYmplY3RzIHdpbGwgbGVhZCB0byBhIGNoZWNrIHdoZW4gdGhleSBjaGFuZ2UgY29tcGFyZWQgdG8gdGhlIHByZXZpb3VzbHkgcmV0dXJuZWQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZXMgb2Ygc3R5bGVzIHdoaWNoIGluZmx1ZW5jZSB0aGUgZmxvdyBkaXJlY3Rpb246XHJcbiAgICAgKiAtIGBkaXJlY3Rpb246IHJ0bGBcclxuICAgICAqIC0gYGZsZXhEaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlYFxyXG4gICAgICogLSBgd3JpdGluZ01vZGU6IHZlcnRpY2FsLXJsYFxyXG4gICAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydCBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMgQSBtYXAgb2Ygc3R5bGVzIHdoaWNoIGluZmx1ZW5jZSB0aGUgdmlld3BvcnRzIGZsb3cgZGlyZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmbG93RGlyZWN0aW9uU3R5bGVzOiAoKHZpZXdwb3J0OiBIVE1MRWxlbWVudCkgPT4gUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHwgbnVsbDtcclxuICB9O1xyXG4gIC8qKiBDdXN0b21pemVzIHRoZSBvdmVyZmxvdyBiZWhhdmlvciBwZXIgYXhpcy4gKi9cclxuICBvdmVyZmxvdzoge1xyXG4gICAgLyoqIFRoZSBvdmVyZmxvdyBiZWhhdmlvciBvZiB0aGUgaG9yaXpvbnRhbCAoeCkgYXhpcy4gKi9cclxuICAgIHg6IE92ZXJmbG93QmVoYXZpb3I7XHJcbiAgICAvKiogVGhlIG92ZXJmbG93IGJlaGF2aW9yIG9mIHRoZSB2ZXJ0aWNhbCAoeSkgYXhpcy4gKi9cclxuICAgIHk6IE92ZXJmbG93QmVoYXZpb3I7XHJcbiAgfTtcclxuICAvKiogQ3VzdG9taXplcyBhcHBlYXJhbmNlIG9mIHRoZSBzY3JvbGxiYXJzLiAqL1xyXG4gIHNjcm9sbGJhcnM6IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNjcm9sbGJhcnMgdGhlbWUuXHJcbiAgICAgKiBUaGUgdGhlbWUgdmFsdWUgd2lsbCBiZSBhZGRlZCBhcyBgY2xhc3NgIHRvIGFsbCBgc2Nyb2xsYmFyYCBlbGVtZW50cyBvZiB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHRoZW1lOiBzdHJpbmcgfCBudWxsO1xyXG4gICAgLyoqIFRoZSBzY3JvbGxiYXJzIHZpc2liaWxpdHkgYmVoYXZpb3IuICovXHJcbiAgICB2aXNpYmlsaXR5OiBTY3JvbGxiYXJzVmlzaWJpbGl0eUJlaGF2aW9yO1xyXG4gICAgLyoqIFRoZSBzY3JvbGxiYXJzIGF1dG8gaGlkZSBiZWhhdmlvci4gKi9cclxuICAgIGF1dG9IaWRlOiBTY3JvbGxiYXJzQXV0b0hpZGVCZWhhdmlvcjtcclxuICAgIC8qKiBUaGUgc2Nyb2xsYmFycyBhdXRvIGhpZGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiAqL1xyXG4gICAgYXV0b0hpZGVEZWxheTogbnVtYmVyO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHNjcm9sbGJhcnMgYXV0byBoaWRlIGJlaGF2aW9yIGlzIHN1c3BlbmRlZCB1bnRpbCBhIHNjcm9sbCBoYXBwZW5lZC4gKi9cclxuICAgIGF1dG9IaWRlU3VzcGVuZDogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIGRyYWcgdGhlIGhhbmRsZSBvZiBhIHNjcm9sbGJhciB0byBzY3JvbGwgdGhlIHZpZXdwb3J0LiAqL1xyXG4gICAgZHJhZ1Njcm9sbDogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIGl0IGlzIHBvc3NpYmxlIHRvIGNsaWNrIHRoZSB0cmFjayBvZiBhIHNjcm9sbGJhciB0byBzY3JvbGwgdGhlIHZpZXdwb3J0LiAqL1xyXG4gICAgY2xpY2tTY3JvbGw6IFNjcm9sbGJhcnNDbGlja1Njcm9sbEJlaGF2aW9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBwb2ludGVyIHR5cGVzIHdoaWNoIHNoYWxsIGJlIHN1cHBvcnRlZC5cclxuICAgICAqIENvbW1vbiBwb2ludGVyIHR5cGVzIGFyZTogYG1vdXNlYCwgYHBlbmAgYW5kIGB0b3VjaGAuXHJcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L3BvaW50ZXJUeXBlXHJcbiAgICAgKi9cclxuICAgIHBvaW50ZXJzOiBzdHJpbmdbXSB8IG51bGw7XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFJlYWRvbmx5T3B0aW9ucyA9IERlZXBSZWFkb25seTxPcHRpb25zPjtcclxuXHJcbmV4cG9ydCB0eXBlIFBhcnRpYWxPcHRpb25zID0gRGVlcFBhcnRpYWw8T3B0aW9ucz47XHJcblxyXG5leHBvcnQgdHlwZSBPcHRpb25zQ2hlY2tGbjxPIGV4dGVuZHMgT3B0aW9uc09iamVjdD4gPSA8UCBleHRlbmRzIE9wdGlvbnNPYmplY3RGaWVsZFBhdGg8Tz4+KFxyXG4gIHBhdGg6IFBcclxuKSA9PiBbdmFsdWU6IE9wdGlvbnNPYmplY3RGaWVsZFBhdGhUeXBlPE8sIFA+LCBjaGFuZ2VkOiBib29sZWFuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZWZhdWx0T3B0aW9uc1VwZGF0ZURlYm91bmNlTXV0YXRpb24gPSBbMCwgMzNdIHNhdGlzZmllcyBPcHRpb25zRGVib3VuY2VWYWx1ZTtcclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VFdmVudCA9IFszMywgOTldIHNhdGlzZmllcyBPcHRpb25zRGVib3VuY2VWYWx1ZTtcclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VFbnYgPSBbMjIyLCA2NjYsIHRydWVdIHNhdGlzZmllcyBPcHRpb25zRGVib3VuY2VWYWx1ZTtcclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zOiBSZWFkb25seU9wdGlvbnMgPSB7XHJcbiAgcGFkZGluZ0Fic29sdXRlOiBmYWxzZSxcclxuICBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzOiBmYWxzZSxcclxuICB1cGRhdGU6IHtcclxuICAgIGVsZW1lbnRFdmVudHM6IFtbJ2ltZycsICdsb2FkJ11dLFxyXG4gICAgZGVib3VuY2U6IHtcclxuICAgICAgbXV0YXRpb246IGRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VNdXRhdGlvbixcclxuICAgICAgcmVzaXplOiBudWxsLFxyXG4gICAgICBldmVudDogZGVmYXVsdE9wdGlvbnNVcGRhdGVEZWJvdW5jZUV2ZW50LFxyXG4gICAgICBlbnY6IGRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VFbnYsXHJcbiAgICB9LFxyXG4gICAgYXR0cmlidXRlczogbnVsbCxcclxuICAgIGlnbm9yZU11dGF0aW9uOiBudWxsLFxyXG4gICAgZmxvd0RpcmVjdGlvblN0eWxlczogbnVsbCxcclxuICB9LFxyXG4gIG92ZXJmbG93OiB7XHJcbiAgICB4OiAnc2Nyb2xsJyxcclxuICAgIHk6ICdzY3JvbGwnLFxyXG4gIH0sXHJcbiAgc2Nyb2xsYmFyczoge1xyXG4gICAgdGhlbWU6ICdvcy10aGVtZS1kYXJrJyxcclxuICAgIHZpc2liaWxpdHk6ICdhdXRvJyxcclxuICAgIGF1dG9IaWRlOiAnbmV2ZXInLFxyXG4gICAgYXV0b0hpZGVEZWxheTogMTMwMCxcclxuICAgIGF1dG9IaWRlU3VzcGVuZDogZmFsc2UsXHJcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxyXG4gICAgY2xpY2tTY3JvbGw6IGZhbHNlLFxyXG4gICAgcG9pbnRlcnM6IFsnbW91c2UnLCAndG91Y2gnLCAncGVuJ10sXHJcbiAgfSxcclxufSBzYXRpc2ZpZXMgT3B0aW9uc09iamVjdCAmIE9wdGlvbnM7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0T3B0aW9uc0RpZmYgPSA8VD4oY3Vyck9wdGlvbnM6IFQsIG5ld09wdGlvbnM6IERlZXBQYXJ0aWFsPFQ+KTogRGVlcFBhcnRpYWw8VD4gPT4ge1xyXG4gIGNvbnN0IGRpZmY6IERlZXBQYXJ0aWFsPFQ+ID0ge307XHJcbiAgY29uc3Qgb3B0aW9uc0tleXMgPSBjb25jYXQoa2V5cyhuZXdPcHRpb25zKSwga2V5cyhjdXJyT3B0aW9ucykpIGFzIEFycmF5PFxyXG4gICAga2V5b2YgVCAmIGtleW9mIERlZXBQYXJ0aWFsPFQ+XHJcbiAgPjtcclxuXHJcbiAgZWFjaChvcHRpb25zS2V5cywgKG9wdGlvbktleSkgPT4ge1xyXG4gICAgY29uc3QgY3Vyck9wdGlvblZhbHVlID0gY3Vyck9wdGlvbnNbb3B0aW9uS2V5XTtcclxuICAgIGNvbnN0IG5ld09wdGlvblZhbHVlID0gbmV3T3B0aW9uc1tvcHRpb25LZXldO1xyXG5cclxuICAgIGlmIChpc09iamVjdChjdXJyT3B0aW9uVmFsdWUpICYmIGlzT2JqZWN0KG5ld09wdGlvblZhbHVlKSkge1xyXG4gICAgICBhc3NpZ25EZWVwKChkaWZmW29wdGlvbktleV0gPSB7fSBhcyBhbnkpLCBnZXRPcHRpb25zRGlmZihjdXJyT3B0aW9uVmFsdWUsIG5ld09wdGlvblZhbHVlKSk7XHJcbiAgICAgIC8vIGRlbGV0ZSBlbXB0eSBuZXN0ZWQgb2JqZWN0c1xyXG4gICAgICBpZiAoaXNFbXB0eU9iamVjdChkaWZmW29wdGlvbktleV0pKSB7XHJcbiAgICAgICAgZGVsZXRlIGRpZmZbb3B0aW9uS2V5XTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShuZXdPcHRpb25zLCBvcHRpb25LZXkpICYmIG5ld09wdGlvblZhbHVlICE9PSBjdXJyT3B0aW9uVmFsdWUpIHtcclxuICAgICAgbGV0IGlzRGlmZiA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoaXNBcnJheShjdXJyT3B0aW9uVmFsdWUpIHx8IGlzQXJyYXkobmV3T3B0aW9uVmFsdWUpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmIChvcHNTdHJpbmdpZnkoY3Vyck9wdGlvblZhbHVlKSA9PT0gb3BzU3RyaW5naWZ5KG5ld09wdGlvblZhbHVlKSkge1xyXG4gICAgICAgICAgICBpc0RpZmYgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxyXG4gICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzRGlmZikge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgZGlmZltvcHRpb25LZXldID0gbmV3T3B0aW9uVmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGRpZmY7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlT3B0aW9uQ2hlY2sgPVxyXG4gIDxUIGV4dGVuZHMgT3B0aW9uc09iamVjdD4oXHJcbiAgICBvcHRpb25zOiBULFxyXG4gICAgY2hhbmdlZE9wdGlvbnM6IERlZXBQYXJ0aWFsPFQ+LFxyXG4gICAgZm9yY2U/OiBib29sZWFuXHJcbiAgKTogT3B0aW9uc0NoZWNrRm48VD4gPT5cclxuICAocGF0aCkgPT4gW1xyXG4gICAgZ2V0UHJvcEJ5UGF0aChvcHRpb25zLCBwYXRoKSxcclxuICAgIGZvcmNlIHx8IGdldFByb3BCeVBhdGgoY2hhbmdlZE9wdGlvbnMsIHBhdGgpICE9PSB1bmRlZmluZWQsXHJcbiAgXTtcclxuIiwibGV0IG5vbmNlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Tm9uY2UgPSAoKSA9PiBub25jZTtcclxuZXhwb3J0IGNvbnN0IHNldE5vbmNlID0gKG5ld05vbmNlOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcclxuICBub25jZSA9IG5ld05vbmNlO1xyXG59O1xyXG4iLCJpbXBvcnQgdHlwZSB7IFhZLCBFdmVudExpc3RlbmVyIH0gZnJvbSAnLi9zdXBwb3J0JztcclxuaW1wb3J0IHR5cGUgeyBPcHRpb25zLCBQYXJ0aWFsT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XHJcbmltcG9ydCB0eXBlIHsgSW5pdGlhbGl6YXRpb24sIFBhcnRpYWxJbml0aWFsaXphdGlvbiB9IGZyb20gJy4vaW5pdGlhbGl6YXRpb24nO1xyXG5pbXBvcnQgdHlwZSB7IFN0eWxlT2JqZWN0S2V5IH0gZnJvbSAnLi90eXBpbmdzJztcclxuaW1wb3J0IHsgZGVmYXVsdE9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xyXG5pbXBvcnQgeyBjbGFzc05hbWVFbnZpcm9ubWVudCwgY2xhc3NOYW1lRW52aXJvbm1lbnRTY3JvbGxiYXJIaWRkZW4gfSBmcm9tICcuL2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZURPTSxcclxuICBhZGRDbGFzcyxcclxuICBhcHBlbmRDaGlsZHJlbixcclxuICBnZXRGcmFjdGlvbmFsU2l6ZSxcclxuICBnZXRDbGllbnRTaXplLFxyXG4gIGdldE9mZnNldFNpemUsXHJcbiAgcmVtb3ZlQXR0cnMsXHJcbiAgcmVtb3ZlRWxlbWVudHMsXHJcbiAgYXNzaWduRGVlcCxcclxuICBjcmVhdGVDYWNoZSxcclxuICBlcXVhbFhZLFxyXG4gIGNyZWF0ZUV2ZW50TGlzdGVuZXJIdWIsXHJcbiAgc2Nyb2xsVCxcclxuICBiaW5kLFxyXG4gIHduZCxcclxuICBnZXRTdHlsZXMsXHJcbiAgaXNCb2R5RWxlbWVudCxcclxuICBpc0Z1bmN0aW9uLFxyXG4gIGFkZEV2ZW50TGlzdGVuZXIsXHJcbn0gZnJvbSAnLi9zdXBwb3J0JztcclxuaW1wb3J0IHsgZ2V0Tm9uY2UgfSBmcm9tICcuL25vbmNlJztcclxuXHJcbnR5cGUgRW52aXJvbm1lbnRFdmVudEFyZ3MgPSB7XHJcbiAgcjogW3Njcm9sbGJhclNpemVDaGFuZ2VkPzogYm9vbGVhbl07XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XHJcbiAgcmVhZG9ubHkgX25hdGl2ZVNjcm9sbGJhcnNTaXplOiBYWTtcclxuICByZWFkb25seSBfbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkOiBYWTxib29sZWFuPjtcclxuICByZWFkb25seSBfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZzogYm9vbGVhbjtcclxuICByZWFkb25seSBfc2Nyb2xsVGltZWxpbmU6IGJvb2xlYW47XHJcbiAgcmVhZG9ubHkgX3N0YXRpY0RlZmF1bHRJbml0aWFsaXphdGlvbjogSW5pdGlhbGl6YXRpb247XHJcbiAgcmVhZG9ubHkgX3N0YXRpY0RlZmF1bHRPcHRpb25zOiBPcHRpb25zO1xyXG4gIF9hZGRSZXNpemVMaXN0ZW5lcihsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxFbnZpcm9ubWVudEV2ZW50QXJncywgJ3InPik6ICgpID0+IHZvaWQ7XHJcbiAgX2dldERlZmF1bHRJbml0aWFsaXphdGlvbigpOiBJbml0aWFsaXphdGlvbjtcclxuICBfc2V0RGVmYXVsdEluaXRpYWxpemF0aW9uKG5ld0luaXRpYWxpemF0aW9uOiBQYXJ0aWFsSW5pdGlhbGl6YXRpb24pOiBJbml0aWFsaXphdGlvbjtcclxuICBfZ2V0RGVmYXVsdE9wdGlvbnMoKTogT3B0aW9ucztcclxuICBfc2V0RGVmYXVsdE9wdGlvbnMobmV3RGVmYXVsdE9wdGlvbnM6IFBhcnRpYWxPcHRpb25zKTogT3B0aW9ucztcclxufVxyXG5cclxubGV0IGVudmlyb25tZW50SW5zdGFuY2U6IEVudjtcclxuXHJcbmNvbnN0IGNyZWF0ZUVudmlyb25tZW50ID0gKCk6IEVudiA9PiB7XHJcbiAgY29uc3QgZ2V0TmF0aXZlU2Nyb2xsYmFyU2l6ZSA9IChcclxuICAgIG1lYXN1cmVFbG06IEhUTUxFbGVtZW50LFxyXG4gICAgbWVhc3VyZUVsbUNoaWxkOiBIVE1MRWxlbWVudCxcclxuICAgIGNsZWFyPzogYm9vbGVhblxyXG4gICk6IFhZID0+IHtcclxuICAgIC8vIGZpeCB3ZWlyZCBzYWZhcmkgaXNzdWUgd2hlcmUgZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIGFsbCBlbXB0eSBzdHlsZXMgYnkgYXBwZW5kaW5nIHR3aWNlXHJcbiAgICBhcHBlbmRDaGlsZHJlbihkb2N1bWVudC5ib2R5LCBtZWFzdXJlRWxtKTtcclxuICAgIGFwcGVuZENoaWxkcmVuKGRvY3VtZW50LmJvZHksIG1lYXN1cmVFbG0pO1xyXG5cclxuICAgIGNvbnN0IGNTaXplID0gZ2V0Q2xpZW50U2l6ZShtZWFzdXJlRWxtKTtcclxuICAgIGNvbnN0IG9TaXplID0gZ2V0T2Zmc2V0U2l6ZShtZWFzdXJlRWxtKTtcclxuICAgIGNvbnN0IGZTaXplID0gZ2V0RnJhY3Rpb25hbFNpemUobWVhc3VyZUVsbUNoaWxkKTtcclxuXHJcbiAgICBpZiAoY2xlYXIpIHtcclxuICAgICAgcmVtb3ZlRWxlbWVudHMobWVhc3VyZUVsbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogb1NpemUuaCAtIGNTaXplLmggKyBmU2l6ZS5oLFxyXG4gICAgICB5OiBvU2l6ZS53IC0gY1NpemUudyArIGZTaXplLncsXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldE5hdGl2ZVNjcm9sbGJhcnNIaWRpbmcgPSAodGVzdEVsbTogSFRNTEVsZW1lbnQpOiBib29sZWFuID0+IHtcclxuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcclxuICAgIGNvbnN0IHJldmVydENsYXNzID0gYWRkQ2xhc3ModGVzdEVsbSwgY2xhc3NOYW1lRW52aXJvbm1lbnRTY3JvbGxiYXJIaWRkZW4pO1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzdWx0ID1cclxuICAgICAgICBnZXRTdHlsZXModGVzdEVsbSwgJ3Njcm9sbGJhci13aWR0aCcgYXMgU3R5bGVPYmplY3RLZXkpID09PSAnbm9uZScgfHxcclxuICAgICAgICBnZXRTdHlsZXModGVzdEVsbSwgJ2Rpc3BsYXknLCAnOjotd2Via2l0LXNjcm9sbGJhcicpID09PSAnbm9uZSc7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxyXG4gICAgfSBjYXRjaCB7fVxyXG4gICAgcmV2ZXJ0Q2xhc3MoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gY2hhbmdlcyB0byB0aGlzIHN0eWxlcyBuZWVkIHRvIGJlIHJlZmxlY3RlZCBpbiB0aGUgXCJoaWRlIG5hdGl2ZSBzY3JvbGxiYXJzXCIgc2VjdGlvbiBvZiB0aGUgc3RydWN0dXJlIHN0eWxlc1xyXG4gIGNvbnN0IGVudlN0eWxlID0gYC4ke2NsYXNzTmFtZUVudmlyb25tZW50fXtzY3JvbGwtYmVoYXZpb3I6YXV0byFpbXBvcnRhbnQ7cG9zaXRpb246Zml4ZWQ7b3BhY2l0eTowO3Zpc2liaWxpdHk6aGlkZGVuO292ZXJmbG93OnNjcm9sbDtoZWlnaHQ6MjAwcHg7d2lkdGg6MjAwcHg7ei1pbmRleDotMX0uJHtjbGFzc05hbWVFbnZpcm9ubWVudH0gZGl2e3dpZHRoOjIwMCU7aGVpZ2h0OjIwMCU7bWFyZ2luOjEwcHggMH0uJHtjbGFzc05hbWVFbnZpcm9ubWVudFNjcm9sbGJhckhpZGRlbn17c2Nyb2xsYmFyLXdpZHRoOm5vbmUhaW1wb3J0YW50fS4ke2NsYXNzTmFtZUVudmlyb25tZW50U2Nyb2xsYmFySGlkZGVufTo6LXdlYmtpdC1zY3JvbGxiYXIsLiR7Y2xhc3NOYW1lRW52aXJvbm1lbnRTY3JvbGxiYXJIaWRkZW59Ojotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJ7YXBwZWFyYW5jZTpub25lIWltcG9ydGFudDtkaXNwbGF5Om5vbmUhaW1wb3J0YW50O3dpZHRoOjAhaW1wb3J0YW50O2hlaWdodDowIWltcG9ydGFudH1gO1xyXG4gIGNvbnN0IGVudkRPTSA9IGNyZWF0ZURPTShcclxuICAgIGA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWVFbnZpcm9ubWVudH1cIj48ZGl2PjwvZGl2PjxzdHlsZT4ke2VudlN0eWxlfTwvc3R5bGU+PC9kaXY+YFxyXG4gICk7XHJcbiAgY29uc3QgZW52RWxtID0gZW52RE9NWzBdIGFzIEhUTUxFbGVtZW50O1xyXG4gIGNvbnN0IGVudkNoaWxkRWxtID0gZW52RWxtLmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgY29uc3Qgc3R5bGVFbG0gPSBlbnZFbG0ubGFzdENoaWxkIGFzIEhUTUxTdHlsZUVsZW1lbnQ7XHJcbiAgY29uc3Qgbm9uY2UgPSBnZXROb25jZSgpO1xyXG5cclxuICBpZiAobm9uY2UpIHtcclxuICAgIHN0eWxlRWxtLm5vbmNlID0gbm9uY2U7XHJcbiAgfVxyXG5cclxuICBjb25zdCBbYWRkRXZlbnQsICwgdHJpZ2dlckV2ZW50XSA9IGNyZWF0ZUV2ZW50TGlzdGVuZXJIdWI8RW52aXJvbm1lbnRFdmVudEFyZ3M+KCk7XHJcbiAgY29uc3QgW3VwZGF0ZU5hdGl2ZVNjcm9sbGJhclNpemVDYWNoZSwgZ2V0TmF0aXZlU2Nyb2xsYmFyU2l6ZUNhY2hlXSA9IGNyZWF0ZUNhY2hlKFxyXG4gICAge1xyXG4gICAgICBfaW5pdGlhbFZhbHVlOiBnZXROYXRpdmVTY3JvbGxiYXJTaXplKGVudkVsbSwgZW52Q2hpbGRFbG0pLFxyXG4gICAgICBfZXF1YWw6IGVxdWFsWFksXHJcbiAgICB9LFxyXG4gICAgYmluZChnZXROYXRpdmVTY3JvbGxiYXJTaXplLCBlbnZFbG0sIGVudkNoaWxkRWxtLCB0cnVlKVxyXG4gICk7XHJcbiAgY29uc3QgW25hdGl2ZVNjcm9sbGJhcnNTaXplXSA9IGdldE5hdGl2ZVNjcm9sbGJhclNpemVDYWNoZSgpO1xyXG4gIGNvbnN0IG5hdGl2ZVNjcm9sbGJhcnNIaWRpbmcgPSBnZXROYXRpdmVTY3JvbGxiYXJzSGlkaW5nKGVudkVsbSk7XHJcbiAgY29uc3QgbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkID0ge1xyXG4gICAgeDogbmF0aXZlU2Nyb2xsYmFyc1NpemUueCA9PT0gMCxcclxuICAgIHk6IG5hdGl2ZVNjcm9sbGJhcnNTaXplLnkgPT09IDAsXHJcbiAgfTtcclxuICBjb25zdCBzdGF0aWNEZWZhdWx0SW5pdGlhbGl6YXRpb246IEluaXRpYWxpemF0aW9uID0ge1xyXG4gICAgZWxlbWVudHM6IHtcclxuICAgICAgaG9zdDogbnVsbCxcclxuICAgICAgcGFkZGluZzogIW5hdGl2ZVNjcm9sbGJhcnNIaWRpbmcsXHJcbiAgICAgIHZpZXdwb3J0OiAodGFyZ2V0KSA9PiBuYXRpdmVTY3JvbGxiYXJzSGlkaW5nICYmIGlzQm9keUVsZW1lbnQodGFyZ2V0KSAmJiB0YXJnZXQsXHJcbiAgICAgIGNvbnRlbnQ6IGZhbHNlLFxyXG4gICAgfSxcclxuICAgIHNjcm9sbGJhcnM6IHtcclxuICAgICAgc2xvdDogdHJ1ZSxcclxuICAgIH0sXHJcbiAgICBjYW5jZWw6IHtcclxuICAgICAgbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkOiBmYWxzZSxcclxuICAgICAgYm9keTogbnVsbCxcclxuICAgIH0sXHJcbiAgfTtcclxuICBjb25zdCBzdGF0aWNEZWZhdWx0T3B0aW9ucyA9IGFzc2lnbkRlZXAoe30sIGRlZmF1bHRPcHRpb25zKTtcclxuICBjb25zdCBnZXREZWZhdWx0T3B0aW9ucyA9IGJpbmQoXHJcbiAgICBhc3NpZ25EZWVwIGFzIHR5cGVvZiBhc3NpZ25EZWVwPE9wdGlvbnMsIE9wdGlvbnM+LFxyXG4gICAge30gYXMgT3B0aW9ucyxcclxuICAgIHN0YXRpY0RlZmF1bHRPcHRpb25zXHJcbiAgKTtcclxuICBjb25zdCBnZXREZWZhdWx0SW5pdGlhbGl6YXRpb24gPSBiaW5kKFxyXG4gICAgYXNzaWduRGVlcCBhcyB0eXBlb2YgYXNzaWduRGVlcDxJbml0aWFsaXphdGlvbiwgSW5pdGlhbGl6YXRpb24+LFxyXG4gICAge30gYXMgSW5pdGlhbGl6YXRpb24sXHJcbiAgICBzdGF0aWNEZWZhdWx0SW5pdGlhbGl6YXRpb25cclxuICApO1xyXG5cclxuICBjb25zdCBlbnY6IEVudiA9IHtcclxuICAgIF9uYXRpdmVTY3JvbGxiYXJzU2l6ZTogbmF0aXZlU2Nyb2xsYmFyc1NpemUsXHJcbiAgICBfbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkOiBuYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQsXHJcbiAgICBfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZzogbmF0aXZlU2Nyb2xsYmFyc0hpZGluZyxcclxuICAgIF9zY3JvbGxUaW1lbGluZTogISFzY3JvbGxULFxyXG4gICAgX2FkZFJlc2l6ZUxpc3RlbmVyOiBiaW5kKGFkZEV2ZW50LCAncicpLFxyXG4gICAgX2dldERlZmF1bHRJbml0aWFsaXphdGlvbjogZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uLFxyXG4gICAgX3NldERlZmF1bHRJbml0aWFsaXphdGlvbjogKG5ld0luaXRpYWxpemF0aW9uU3RyYXRlZ3kpID0+XHJcbiAgICAgIGFzc2lnbkRlZXAoc3RhdGljRGVmYXVsdEluaXRpYWxpemF0aW9uLCBuZXdJbml0aWFsaXphdGlvblN0cmF0ZWd5KSAmJlxyXG4gICAgICBnZXREZWZhdWx0SW5pdGlhbGl6YXRpb24oKSxcclxuICAgIF9nZXREZWZhdWx0T3B0aW9uczogZ2V0RGVmYXVsdE9wdGlvbnMsXHJcbiAgICBfc2V0RGVmYXVsdE9wdGlvbnM6IChuZXdEZWZhdWx0T3B0aW9ucykgPT5cclxuICAgICAgYXNzaWduRGVlcChzdGF0aWNEZWZhdWx0T3B0aW9ucywgbmV3RGVmYXVsdE9wdGlvbnMpICYmIGdldERlZmF1bHRPcHRpb25zKCksXHJcbiAgICBfc3RhdGljRGVmYXVsdEluaXRpYWxpemF0aW9uOiBhc3NpZ25EZWVwKHt9LCBzdGF0aWNEZWZhdWx0SW5pdGlhbGl6YXRpb24pLFxyXG4gICAgX3N0YXRpY0RlZmF1bHRPcHRpb25zOiBhc3NpZ25EZWVwKHt9LCBzdGF0aWNEZWZhdWx0T3B0aW9ucyksXHJcbiAgfTtcclxuXHJcbiAgcmVtb3ZlQXR0cnMoZW52RWxtLCAnc3R5bGUnKTtcclxuICByZW1vdmVFbGVtZW50cyhlbnZFbG0pO1xyXG5cclxuICAvLyBuZWVkZWQgaW4gY2FzZSBjb250ZW50IGhhcyBjc3Mgdmlld3BvcnQgdW5pdHNcclxuICBhZGRFdmVudExpc3RlbmVyKHduZCwgJ3Jlc2l6ZScsICgpID0+IHtcclxuICAgIHRyaWdnZXJFdmVudCgncicsIFtdKTtcclxuICB9KTtcclxuXHJcbiAgaWYgKFxyXG4gICAgaXNGdW5jdGlvbih3bmQubWF0Y2hNZWRpYSkgJiZcclxuICAgICFuYXRpdmVTY3JvbGxiYXJzSGlkaW5nICYmXHJcbiAgICAoIW5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC54IHx8ICFuYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQueSlcclxuICApIHtcclxuICAgIGNvbnN0IGFkZFpvb21MaXN0ZW5lciA9IChvblpvb206ICgpID0+IHZvaWQpID0+IHtcclxuICAgICAgY29uc3QgbWVkaWEgPSB3bmQubWF0Y2hNZWRpYShgKHJlc29sdXRpb246ICR7d25kLmRldmljZVBpeGVsUmF0aW99ZHBweClgKTtcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBtZWRpYSxcclxuICAgICAgICAnY2hhbmdlJyxcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICBvblpvb20oKTtcclxuICAgICAgICAgIGFkZFpvb21MaXN0ZW5lcihvblpvb20pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgX29uY2U6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfTtcclxuICAgIGFkZFpvb21MaXN0ZW5lcigoKSA9PiB7XHJcbiAgICAgIGNvbnN0IFt1cGRhdGVkTmF0aXZlU2Nyb2xsYmFyU2l6ZSwgbmF0aXZlU2Nyb2xsYmFyU2l6ZUNoYW5nZWRdID1cclxuICAgICAgICB1cGRhdGVOYXRpdmVTY3JvbGxiYXJTaXplQ2FjaGUoKTtcclxuXHJcbiAgICAgIGFzc2lnbkRlZXAoZW52Ll9uYXRpdmVTY3JvbGxiYXJzU2l6ZSwgdXBkYXRlZE5hdGl2ZVNjcm9sbGJhclNpemUpOyAvLyBrZWVwIHRoZSBvYmplY3QgYW5kIGp1c3QgcmUtYXNzaWduIVxyXG4gICAgICB0cmlnZ2VyRXZlbnQoJ3InLCBbbmF0aXZlU2Nyb2xsYmFyU2l6ZUNoYW5nZWRdKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVudjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRFbnZpcm9ubWVudCA9ICgpOiBFbnYgPT4ge1xyXG4gIGlmICghZW52aXJvbm1lbnRJbnN0YW5jZSkge1xyXG4gICAgZW52aXJvbm1lbnRJbnN0YW5jZSA9IGNyZWF0ZUVudmlyb25tZW50KCk7XHJcbiAgfVxyXG4gIHJldHVybiBlbnZpcm9ubWVudEluc3RhbmNlO1xyXG59O1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXHJcbmltcG9ydCB7XHJcbiAgZWFjaCxcclxuICBub29wLFxyXG4gIE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3RvcixcclxuICBhZGRFdmVudExpc3RlbmVyLFxyXG4gIGlzLFxyXG4gIGZpbmQsXHJcbiAgcHVzaCxcclxuICBydW5FYWNoQW5kQ2xlYXIsXHJcbiAgYmluZCxcclxuICBpc0VtcHR5QXJyYXksXHJcbiAgZGVkdXBsaWNhdGVBcnJheSxcclxuICBpbkFycmF5LFxyXG4gIGNvbmNhdCxcclxuICBnZXRBdHRyLFxyXG4gIGlzU3RyaW5nLFxyXG59IGZyb20gJy4uL3N1cHBvcnQnO1xyXG5cclxudHlwZSBET01Db250ZW50T2JzZXJ2ZXJDYWxsYmFjayA9IChjb250ZW50Q2hhbmdlZFRocm91Z2hFdmVudDogYm9vbGVhbikgPT4gYW55O1xyXG5cclxudHlwZSBET01UYXJnZXRPYnNlcnZlckNhbGxiYWNrID0gKHRhcmdldENoYW5nZWRBdHRyczogc3RyaW5nW10sIHRhcmdldFN0eWxlQ2hhbmdlZDogYm9vbGVhbikgPT4gYW55O1xyXG5cclxuaW50ZXJmYWNlIERPTU9ic2VydmVyT3B0aW9uc0Jhc2Uge1xyXG4gIF9hdHRyaWJ1dGVzPzogc3RyaW5nW107XHJcbiAgLyoqXHJcbiAgICogQSBmdW5jdGlvbiB3aGljaCBjYW4gaWdub3JlIGEgY2hhbmdlZCBhdHRyaWJ1dGUgaWYgaXQgcmV0dXJucyB0cnVlLlxyXG4gICAqIGZvciBET01UYXJnZXRPYnNlcnZlciB0aGlzIGFwcGxpZXMgdG8gdGhlIGNoYW5nZXMgdG8gdGhlIG9ic2VydmVkIHRhcmdldFxyXG4gICAqIGZvciBET01Db250ZW50T2JzZXJ2ZXIgdGhpcyBhcHBsaWVzIHRvIGNoYW5nZXMgdG8gbmVzdGVkIHRhcmdldHMgLT4gbmVzdGVkIHRhcmdldHMgYXJlIGVsZW1lbnRzIHdoaWNoIG1hdGNoIHRoZSBcIl9uZXN0ZWRUYXJnZXRTZWxlY3RvclwiIHNlbGVjdG9yXHJcbiAgICovXHJcbiAgX2lnbm9yZVRhcmdldENoYW5nZT86IERPTU9ic2VydmVySWdub3JlVGFyZ2V0Q2hhbmdlO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRE9NQ29udGVudE9ic2VydmVyT3B0aW9ucyBleHRlbmRzIERPTU9ic2VydmVyT3B0aW9uc0Jhc2Uge1xyXG4gIF9ldmVudENvbnRlbnRDaGFuZ2U/OiBET01PYnNlcnZlckV2ZW50Q29udGVudENoYW5nZTsgLy8gW3NlbGVjdG9yLCBldmVudG5hbWUocykgfCBmdW5jdGlvbiByZXR1cm5pbmcgZXZlbnRuYW1lKHMpXSAtPiBldmVudG5hbWVzIGRpdmlkZWQgYnkgd2hpdGVzcGFjZXNcclxuICBfbmVzdGVkVGFyZ2V0U2VsZWN0b3I/OiBzdHJpbmc7XHJcbiAgX2lnbm9yZUNvbnRlbnRDaGFuZ2U/OiBET01PYnNlcnZlcklnbm9yZUNvbnRlbnRDaGFuZ2U7IC8vIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcHJldmVudCBtYXJraW5nIGNlcnRhaW4gZG9tIGNoYW5nZXMgYXMgY29udGVudCBjaGFuZ2UgaWYgaXQgcmV0dXJucyB0cnVlXHJcbn1cclxuXHJcbmludGVyZmFjZSBET01UYXJnZXRPYnNlcnZlck9wdGlvbnMgZXh0ZW5kcyBET01PYnNlcnZlck9wdGlvbnNCYXNlIHtcclxuICAvKipcclxuICAgKiBNYXJrcyBjZXJ0YWluIGF0dHJpYnV0ZXMgYXMgc3R5bGUgY2hhbmdpbmcsIHNob3VsZCBiZSBhIHN1YnNldCBvZiB0aGUgX2F0dHJpYnV0ZXMgcHJvcC5cclxuICAgKiBVc2VkIHRvIHNldCB0aGUgXCJ0YXJnZXRTdHlsZUNoYW5nZWRcIiBwYXJhbSBpbiB0aGUgRE9NVGFyZ2V0T2JzZXJ2ZXJDYWxsYmFjay5cclxuICAgKi9cclxuICBfc3R5bGVDaGFuZ2luZ0F0dHJpYnV0ZXM/OiBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG59XHJcblxyXG50eXBlIENvbnRlbnRDaGFuZ2VBcnJheUl0ZW0gPSBbc2VsZWN0b3I/OiBzdHJpbmcsIGV2ZW50TmFtZXM/OiBzdHJpbmddIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbmV4cG9ydCB0eXBlIERPTU9ic2VydmVyRXZlbnRDb250ZW50Q2hhbmdlID1cclxuICB8IEFycmF5PENvbnRlbnRDaGFuZ2VBcnJheUl0ZW0+XHJcbiAgfCBmYWxzZVxyXG4gIHwgbnVsbFxyXG4gIHwgdW5kZWZpbmVkO1xyXG5cclxuZXhwb3J0IHR5cGUgRE9NT2JzZXJ2ZXJJZ25vcmVDb250ZW50Q2hhbmdlID0gKFxyXG4gIG11dGF0aW9uOiBNdXRhdGlvblJlY29yZCxcclxuICBpc05lc3RlZFRhcmdldDogYm9vbGVhbixcclxuICBkb21PYnNlcnZlclRhcmdldDogSFRNTEVsZW1lbnQsXHJcbiAgZG9tT2JzZXJ2ZXJPcHRpb25zPzogRE9NQ29udGVudE9ic2VydmVyT3B0aW9uc1xyXG4pID0+IGJvb2xlYW47XHJcblxyXG5leHBvcnQgdHlwZSBET01PYnNlcnZlcklnbm9yZVRhcmdldENoYW5nZSA9IChcclxuICB0YXJnZXQ6IE5vZGUsXHJcbiAgYXR0cmlidXRlTmFtZTogc3RyaW5nLFxyXG4gIG9sZEF0dHJpYnV0ZVZhbHVlOiBzdHJpbmcgfCBudWxsLFxyXG4gIG5ld0F0dHJpYnV0ZVZhbHVlOiBzdHJpbmcgfCBudWxsXHJcbikgPT4gYm9vbGVhbjtcclxuXHJcbmV4cG9ydCB0eXBlIERPTU9ic2VydmVyQ2FsbGJhY2s8Q29udGVudE9ic2VydmVyIGV4dGVuZHMgYm9vbGVhbj4gPSBDb250ZW50T2JzZXJ2ZXIgZXh0ZW5kcyB0cnVlXHJcbiAgPyBET01Db250ZW50T2JzZXJ2ZXJDYWxsYmFja1xyXG4gIDogRE9NVGFyZ2V0T2JzZXJ2ZXJDYWxsYmFjaztcclxuXHJcbmV4cG9ydCB0eXBlIERPTU9ic2VydmVyT3B0aW9uczxDb250ZW50T2JzZXJ2ZXIgZXh0ZW5kcyBib29sZWFuPiA9IENvbnRlbnRPYnNlcnZlciBleHRlbmRzIHRydWVcclxuICA/IERPTUNvbnRlbnRPYnNlcnZlck9wdGlvbnNcclxuICA6IERPTVRhcmdldE9ic2VydmVyT3B0aW9ucztcclxuXHJcbmV4cG9ydCB0eXBlIERPTU9ic2VydmVyPENvbnRlbnRPYnNlcnZlciBleHRlbmRzIGJvb2xlYW4+ID0gW1xyXG4gIGNvbnN0cnVjdDogKCkgPT4gKCkgPT4gdm9pZCxcclxuICB1cGRhdGU6ICgpID0+IHZvaWQgfCBmYWxzZSB8IFBhcmFtZXRlcnM8RE9NT2JzZXJ2ZXJDYWxsYmFjazxDb250ZW50T2JzZXJ2ZXI+PixcclxuXTtcclxuXHJcbnR5cGUgRXZlbnRDb250ZW50Q2hhbmdlVXBkYXRlRWxlbWVudCA9IChcclxuICBnZXRFbGVtZW50cz86IChzZWxlY3Rvcjogc3RyaW5nKSA9PiBOb2RlW10sXHJcbiAgcmVtb3ZlZD86IGJvb2xlYW5cclxuKSA9PiB2b2lkO1xyXG50eXBlIEV2ZW50Q29udGVudENoYW5nZSA9IFtkZXN0cm95OiAoKSA9PiB2b2lkLCB1cGRhdGVFbGVtZW50czogRXZlbnRDb250ZW50Q2hhbmdlVXBkYXRlRWxlbWVudF07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBoZWxwZXIgZnVuY3Rpb25zIHRvIG9ic2VydmUgZXZlbnRzIG9mIGVsZW1lbnRzIGluc2lkZSB0aGUgdGFyZ2V0IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IG9mIHdoaWNoIHRoZSBjaGlsZHJlbiBlbGVtZW50cyBzaGFsbCBiZSBvYnNlcnZlZC4gKG5vdCBvbmx5IGRpcmVjdCBjaGlsZHJlbiBidXQgYWxzbyBuZXN0ZWQgb25lcylcclxuICogQHBhcmFtIGV2ZW50Q29udGVudENoYW5nZSBUaGUgZXZlbnQgY29udGVudCBjaGFuZ2UgYXJyYXkuIChhcnJheSBvZiB0dXBsZXM6IHNlbGVjdG9yIGFuZCBldmVudG5hbWUocykpXHJcbiAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgaWYgb25lIG9mIHRoZSBlbGVtZW50cyBlbWl0cyB0aGUgY29ycmVzcG9uZGluZyBldmVudC5cclxuICogQHJldHVybnMgQSBvYmplY3Qgd2hpY2ggY29udGFpbnMgYSBzZXQgb2YgaGVscGVyIGZ1bmN0aW9ucyB0byBkZXN0cm95IGFuZCB1cGRhdGUgdGhlIG9ic2VydmF0aW9uIG9mIGVsZW1lbnRzLlxyXG4gKi9cclxuY29uc3QgY3JlYXRlRXZlbnRDb250ZW50Q2hhbmdlID0gKFxyXG4gIHRhcmdldDogSFRNTEVsZW1lbnQsXHJcbiAgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnkpID0+IGFueSxcclxuICBldmVudENvbnRlbnRDaGFuZ2U/OiBET01PYnNlcnZlckV2ZW50Q29udGVudENoYW5nZVxyXG4pOiBFdmVudENvbnRlbnRDaGFuZ2UgPT4ge1xyXG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcclxuICBjb25zdCBtYXAgPSBldmVudENvbnRlbnRDaGFuZ2UgPyBuZXcgV2Vha01hcDxOb2RlLCAoKCkgPT4gYW55KVtdPigpIDogZmFsc2U7IC8vIHdlYWsgbWFwIHRvIHByZXZlbnQgbWVtb3J5IGxlYWsgZm9yIGRldGFjaGVkIGVsZW1lbnRzXHJcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcclxuICAgIGRlc3Ryb3llZCA9IHRydWU7XHJcbiAgfTtcclxuICBjb25zdCB1cGRhdGVFbGVtZW50czogRXZlbnRDb250ZW50Q2hhbmdlVXBkYXRlRWxlbWVudCA9IChnZXRFbGVtZW50cykgPT4ge1xyXG4gICAgaWYgKG1hcCAmJiBldmVudENvbnRlbnRDaGFuZ2UpIHtcclxuICAgICAgY29uc3QgZXZlbnRFbG1MaXN0ID0gZXZlbnRDb250ZW50Q2hhbmdlLm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IFtzZWxlY3RvciwgZXZlbnROYW1lc10gPSBpdGVtIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZXZlbnROYW1lcyAmJiBzZWxlY3RvciA/IChnZXRFbGVtZW50cyB8fCBmaW5kKShzZWxlY3RvciwgdGFyZ2V0KSA6IFtdO1xyXG4gICAgICAgIHJldHVybiBbZWxlbWVudHMsIGV2ZW50TmFtZXNdIGFzIGNvbnN0O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGVhY2goZXZlbnRFbG1MaXN0LCAoaXRlbSkgPT5cclxuICAgICAgICBlYWNoKGl0ZW1bMF0sIChlbG0pID0+IHtcclxuICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZXMgPSBpdGVtWzFdO1xyXG4gICAgICAgICAgY29uc3QgZW50cmllcyA9IG1hcC5nZXQoZWxtKSB8fCBbXTtcclxuICAgICAgICAgIGNvbnN0IGlzVGFyZ2V0Q2hpbGQgPSB0YXJnZXQuY29udGFpbnMoZWxtKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNUYXJnZXRDaGlsZCAmJiBldmVudE5hbWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcihlbG0sIGV2ZW50TmFtZXMsIChldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShlbG0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWFwLnNldChlbG0sIHB1c2goZW50cmllcywgcmVtb3ZlTGlzdGVuZXIpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJ1bkVhY2hBbmRDbGVhcihlbnRyaWVzKTtcclxuICAgICAgICAgICAgbWFwLmRlbGV0ZShlbG0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdXBkYXRlRWxlbWVudHMoKTtcclxuXHJcbiAgcmV0dXJuIFtkZXN0cm95LCB1cGRhdGVFbGVtZW50c107XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIERPTSBvYnNlcnZlciB3aGljaCBvYnNlcnZlcyBET00gY2hhbmdlcyB0byBlaXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IG9yIGl0cyBjaGlsZHJlbi5cclxuICogQHBhcmFtIHRhcmdldCBUaGUgZWxlbWVudCB3aGljaCBzaGFsbCBiZSBvYnNlcnZlZC5cclxuICogQHBhcmFtIGlzQ29udGVudE9ic2VydmVyIFdoZXRoZXIgdGhpcyBvYnNlcnZlciBpcyBqdXN0IG9ic2VydmluZyB0aGUgdGFyZ2V0IG9yIGp1c3QgdGhlIHRhcmdldHMgY2hpbGRyZW4uIChub3Qgb25seSBkaXJlY3QgY2hpbGRyZW4gYnV0IGFsc28gbmVzdGVkIG9uZXMpXHJcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgd2hpY2ggZ2V0cyBjYWxsZWQgaWYgYSBjaGFuZ2Ugd2FzIGRldGVjdGVkLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgRE9NIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAqIEByZXR1cm5zIEEgb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgdGhlIGluc3RhbmNlIG9mIHRoZSBET00gb2JzZXJ2ZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY3JlYXRlRE9NT2JzZXJ2ZXIgPSA8Q29udGVudE9ic2VydmVyIGV4dGVuZHMgYm9vbGVhbj4oXHJcbiAgdGFyZ2V0OiBIVE1MRWxlbWVudCxcclxuICBpc0NvbnRlbnRPYnNlcnZlcjogQ29udGVudE9ic2VydmVyLFxyXG4gIGNhbGxiYWNrOiBET01PYnNlcnZlckNhbGxiYWNrPENvbnRlbnRPYnNlcnZlcj4sXHJcbiAgb3B0aW9ucz86IERPTU9ic2VydmVyT3B0aW9uczxDb250ZW50T2JzZXJ2ZXI+XHJcbik6IERPTU9ic2VydmVyPENvbnRlbnRPYnNlcnZlcj4gPT4ge1xyXG4gIGxldCBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gIGNvbnN0IHtcclxuICAgIF9hdHRyaWJ1dGVzLFxyXG4gICAgX3N0eWxlQ2hhbmdpbmdBdHRyaWJ1dGVzLFxyXG4gICAgX2V2ZW50Q29udGVudENoYW5nZSxcclxuICAgIF9uZXN0ZWRUYXJnZXRTZWxlY3RvcixcclxuICAgIF9pZ25vcmVUYXJnZXRDaGFuZ2UsXHJcbiAgICBfaWdub3JlQ29udGVudENoYW5nZSxcclxuICB9ID0gKG9wdGlvbnMgYXMgRE9NQ29udGVudE9ic2VydmVyT3B0aW9ucyAmIERPTVRhcmdldE9ic2VydmVyT3B0aW9ucykgfHwge307XHJcbiAgY29uc3QgW2Rlc3Ryb3lFdmVudENvbnRlbnRDaGFuZ2UsIHVwZGF0ZUV2ZW50Q29udGVudENoYW5nZUVsZW1lbnRzXSA9IGNyZWF0ZUV2ZW50Q29udGVudENoYW5nZShcclxuICAgIHRhcmdldCxcclxuICAgICgpID0+IGlzQ29ubmVjdGVkICYmIChjYWxsYmFjayBhcyBET01Db250ZW50T2JzZXJ2ZXJDYWxsYmFjaykodHJ1ZSksXHJcbiAgICBfZXZlbnRDb250ZW50Q2hhbmdlXHJcbiAgKTtcclxuXHJcbiAgLy8gTXV0YXRpb25PYnNlcnZlclxyXG4gIGNvbnN0IGZpbmFsQXR0cmlidXRlcyA9IF9hdHRyaWJ1dGVzIHx8IFtdO1xyXG4gIGNvbnN0IGZpbmFsU3R5bGVDaGFuZ2luZ0F0dHJpYnV0ZXMgPSBfc3R5bGVDaGFuZ2luZ0F0dHJpYnV0ZXMgfHwgW107XHJcbiAgY29uc3Qgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gY29uY2F0KGZpbmFsQXR0cmlidXRlcywgZmluYWxTdHlsZUNoYW5naW5nQXR0cmlidXRlcyk7XHJcbiAgY29uc3Qgb2JzZXJ2ZXJDYWxsYmFjayA9IChcclxuICAgIGZyb21SZWNvcmRzOiBib29sZWFuLFxyXG4gICAgbXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdXHJcbiAgKTogdm9pZCB8IFBhcmFtZXRlcnM8RE9NT2JzZXJ2ZXJDYWxsYmFjazxDb250ZW50T2JzZXJ2ZXI+PiA9PiB7XHJcbiAgICBpZiAoIWlzRW1wdHlBcnJheShtdXRhdGlvbnMpKSB7XHJcbiAgICAgIGNvbnN0IGlnbm9yZVRhcmdldENoYW5nZSA9IF9pZ25vcmVUYXJnZXRDaGFuZ2UgfHwgbm9vcDtcclxuICAgICAgY29uc3QgaWdub3JlQ29udGVudENoYW5nZSA9IF9pZ25vcmVDb250ZW50Q2hhbmdlIHx8IG5vb3A7XHJcbiAgICAgIGNvbnN0IHRvdGFsQ2hhbmdlZE5vZGVzOiBOb2RlW10gPSBbXTtcclxuICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlZEF0dHJzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICBsZXQgdGFyZ2V0U3R5bGVDaGFuZ2VkOiBib29sZWFuIHwgJycgfCBudWxsIHwgdW5kZWZpbmVkID0gZmFsc2U7XHJcbiAgICAgIGxldCBjb250ZW50Q2hhbmdlZDogYm9vbGVhbiB8ICcnIHwgbnVsbCB8IHVuZGVmaW5lZCA9IGZhbHNlO1xyXG4gICAgICBsZXQgY2hpbGRMaXN0Q2hhbmdlZDogYm9vbGVhbiB8ICcnIHwgbnVsbCB8IHVuZGVmaW5lZCA9IGZhbHNlO1xyXG5cclxuICAgICAgZWFjaChtdXRhdGlvbnMsIChtdXRhdGlvbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXHJcbiAgICAgICAgICB0YXJnZXQ6IG11dGF0aW9uVGFyZ2V0LFxyXG4gICAgICAgICAgdHlwZSxcclxuICAgICAgICAgIG9sZFZhbHVlLFxyXG4gICAgICAgICAgYWRkZWROb2RlcyxcclxuICAgICAgICAgIHJlbW92ZWROb2RlcyxcclxuICAgICAgICB9ID0gbXV0YXRpb247XHJcbiAgICAgICAgY29uc3QgaXNBdHRyaWJ1dGVzVHlwZSA9IHR5cGUgPT09ICdhdHRyaWJ1dGVzJztcclxuICAgICAgICBjb25zdCBpc0NoaWxkTGlzdFR5cGUgPSB0eXBlID09PSAnY2hpbGRMaXN0JztcclxuICAgICAgICBjb25zdCB0YXJnZXRJc011dGF0aW9uVGFyZ2V0ID0gdGFyZ2V0ID09PSBtdXRhdGlvblRhcmdldDtcclxuICAgICAgICBjb25zdCBpc0F0dHJDaGFuZ2UgPSBpc0F0dHJpYnV0ZXNUeXBlICYmIGF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPVxyXG4gICAgICAgICAgaXNBdHRyQ2hhbmdlICYmIGdldEF0dHIobXV0YXRpb25UYXJnZXQgYXMgSFRNTEVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUgfHwgJycpO1xyXG4gICAgICAgIC8vIG5hcnJvdyBkb3duIGF0dHJpYnV0ZVZhbHVlIHR5cGUgdG8gYHN0cmluZ2Agb3IgYG51bGxgIGJ1dCBkb24ndCBvdmVyd3JpdGUgYDxlbXB0eSBzdHJpbmc+YCB3aXRoIGBudWxsYFxyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gaXNTdHJpbmcobmV3VmFsdWUpID8gbmV3VmFsdWUgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZUNoYW5nZWQgPSBpc0F0dHJDaGFuZ2UgJiYgb2xkVmFsdWUgIT09IGF0dHJpYnV0ZVZhbHVlO1xyXG4gICAgICAgIGNvbnN0IHN0eWxlQ2hhbmdpbmdBdHRyQ2hhbmdlZCA9XHJcbiAgICAgICAgICBpbkFycmF5KGZpbmFsU3R5bGVDaGFuZ2luZ0F0dHJpYnV0ZXMsIGF0dHJpYnV0ZU5hbWUpICYmIGF0dHJpYnV0ZUNoYW5nZWQ7XHJcblxyXG4gICAgICAgIC8vIGlmIGlzIGNvbnRlbnQgb2JzZXJ2ZXIgYW5kIHNvbWV0aGluZyBjaGFuZ2VkIGluIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKGlzQ29udGVudE9ic2VydmVyICYmIChpc0NoaWxkTGlzdFR5cGUgfHwgIXRhcmdldElzTXV0YXRpb25UYXJnZXQpKSB7XHJcbiAgICAgICAgICBjb25zdCBjb250ZW50QXR0ckNoYW5nZWQgPSBpc0F0dHJpYnV0ZXNUeXBlICYmIGF0dHJpYnV0ZUNoYW5nZWQ7XHJcbiAgICAgICAgICBjb25zdCBpc05lc3RlZFRhcmdldCA9XHJcbiAgICAgICAgICAgIGNvbnRlbnRBdHRyQ2hhbmdlZCAmJlxyXG4gICAgICAgICAgICBfbmVzdGVkVGFyZ2V0U2VsZWN0b3IgJiZcclxuICAgICAgICAgICAgaXMobXV0YXRpb25UYXJnZXQsIF9uZXN0ZWRUYXJnZXRTZWxlY3Rvcik7XHJcbiAgICAgICAgICBjb25zdCBiYXNlQXNzZXJ0aW9uID0gaXNOZXN0ZWRUYXJnZXRcclxuICAgICAgICAgICAgPyAhaWdub3JlVGFyZ2V0Q2hhbmdlKG11dGF0aW9uVGFyZ2V0LCBhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSwgYXR0cmlidXRlVmFsdWUpXHJcbiAgICAgICAgICAgIDogIWlzQXR0cmlidXRlc1R5cGUgfHwgY29udGVudEF0dHJDaGFuZ2VkO1xyXG4gICAgICAgICAgY29uc3QgY29udGVudEZpbmFsQ2hhbmdlZCA9XHJcbiAgICAgICAgICAgIGJhc2VBc3NlcnRpb24gJiYgIWlnbm9yZUNvbnRlbnRDaGFuZ2UobXV0YXRpb24sICEhaXNOZXN0ZWRUYXJnZXQsIHRhcmdldCwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgZWFjaChhZGRlZE5vZGVzLCAobm9kZSkgPT4gcHVzaCh0b3RhbENoYW5nZWROb2Rlcywgbm9kZSkpO1xyXG4gICAgICAgICAgZWFjaChyZW1vdmVkTm9kZXMsIChub2RlKSA9PiBwdXNoKHRvdGFsQ2hhbmdlZE5vZGVzLCBub2RlKSk7XHJcblxyXG4gICAgICAgICAgY29udGVudENoYW5nZWQgPSBjb250ZW50Q2hhbmdlZCB8fCBjb250ZW50RmluYWxDaGFuZ2VkO1xyXG4gICAgICAgICAgY2hpbGRMaXN0Q2hhbmdlZCA9IGNoaWxkTGlzdENoYW5nZWQgfHwgaXNDaGlsZExpc3RUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBpcyB0YXJnZXQgb2JzZXJ2ZXIgYW5kIHRhcmdldCBhdHRyIGNoYW5nZWRcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAhaXNDb250ZW50T2JzZXJ2ZXIgJiZcclxuICAgICAgICAgIHRhcmdldElzTXV0YXRpb25UYXJnZXQgJiZcclxuICAgICAgICAgIGF0dHJpYnV0ZUNoYW5nZWQgJiZcclxuICAgICAgICAgICFpZ25vcmVUYXJnZXRDaGFuZ2UobXV0YXRpb25UYXJnZXQsIGF0dHJpYnV0ZU5hbWUhLCBvbGRWYWx1ZSwgYXR0cmlidXRlVmFsdWUpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBwdXNoKHRhcmdldENoYW5nZWRBdHRycywgYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgICAgICB0YXJnZXRTdHlsZUNoYW5nZWQgPSB0YXJnZXRTdHlsZUNoYW5nZWQgfHwgc3R5bGVDaGFuZ2luZ0F0dHJDaGFuZ2VkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBhZGRzIC8gcmVtb3ZlcyB0aGUgbmV3IGVsZW1lbnRzIGZyb20gdGhlIGV2ZW50IGNvbnRlbnQgY2hhbmdlXHJcbiAgICAgIHVwZGF0ZUV2ZW50Q29udGVudENoYW5nZUVsZW1lbnRzKChzZWxlY3Rvcjogc3RyaW5nKSA9PlxyXG4gICAgICAgIGRlZHVwbGljYXRlQXJyYXkodG90YWxDaGFuZ2VkTm9kZXMpLnJlZHVjZTxOb2RlW10+KChhcnIsIG5vZGUpID0+IHtcclxuICAgICAgICAgIHB1c2goYXJyLCBmaW5kKHNlbGVjdG9yLCBub2RlKSk7XHJcbiAgICAgICAgICByZXR1cm4gaXMobm9kZSwgc2VsZWN0b3IpID8gcHVzaChhcnIsIG5vZGUpIDogYXJyO1xyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGlzQ29udGVudE9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCFmcm9tUmVjb3JkcyAmJiBjb250ZW50Q2hhbmdlZCkge1xyXG4gICAgICAgICAgKGNhbGxiYWNrIGFzIERPTUNvbnRlbnRPYnNlcnZlckNhbGxiYWNrKShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbZmFsc2VdIHNhdGlzZmllcyBQYXJhbWV0ZXJzPERPTU9ic2VydmVyQ2FsbGJhY2s8dHJ1ZT4+IGFzIFBhcmFtZXRlcnM8XHJcbiAgICAgICAgICBET01PYnNlcnZlckNhbGxiYWNrPENvbnRlbnRPYnNlcnZlcj5cclxuICAgICAgICA+O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzRW1wdHlBcnJheSh0YXJnZXRDaGFuZ2VkQXR0cnMpIHx8IHRhcmdldFN0eWxlQ2hhbmdlZCkge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXHJcbiAgICAgICAgICBkZWR1cGxpY2F0ZUFycmF5KHRhcmdldENoYW5nZWRBdHRycyksXHJcbiAgICAgICAgICB0YXJnZXRTdHlsZUNoYW5nZWQsXHJcbiAgICAgICAgXSBzYXRpc2ZpZXMgUGFyYW1ldGVyczxET01UYXJnZXRPYnNlcnZlckNhbGxiYWNrPiAmIFBhcmFtZXRlcnM8RE9NT2JzZXJ2ZXJDYWxsYmFjazxmYWxzZT4+O1xyXG5cclxuICAgICAgICBpZiAoIWZyb21SZWNvcmRzKSB7XHJcbiAgICAgICAgICAoY2FsbGJhY2sgYXMgRE9NVGFyZ2V0T2JzZXJ2ZXJDYWxsYmFjaykuYXBwbHkoMCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJncyBhcyBQYXJhbWV0ZXJzPERPTU9ic2VydmVyQ2FsbGJhY2s8Q29udGVudE9ic2VydmVyPj47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yIShcclxuICAgIGJpbmQob2JzZXJ2ZXJDYWxsYmFjaywgZmFsc2UpXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIFtcclxuICAgICgpID0+IHtcclxuICAgICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXHJcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBvYnNlcnZlZEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgc3VidHJlZTogaXNDb250ZW50T2JzZXJ2ZXIsXHJcbiAgICAgICAgY2hpbGRMaXN0OiBpc0NvbnRlbnRPYnNlcnZlcixcclxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiBpc0NvbnRlbnRPYnNlcnZlcixcclxuICAgICAgfSk7XHJcbiAgICAgIGlzQ29ubmVjdGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICBkZXN0cm95RXZlbnRDb250ZW50Q2hhbmdlKCk7XHJcbiAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgIGlzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgICgpID0+IHtcclxuICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyQ2FsbGJhY2sodHJ1ZSwgbXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICBdO1xyXG59O1xyXG4iLCJpbXBvcnQgdHlwZSB7IFNpemVPYnNlcnZlclBsdWdpbiB9IGZyb20gJy4uL3BsdWdpbnMnO1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZUNhY2hlLFxyXG4gIGNyZWF0ZURPTSxcclxuICBydW5FYWNoQW5kQ2xlYXIsXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcixcclxuICBhZGRDbGFzcyxcclxuICBwdXNoLFxyXG4gIFJlc2l6ZU9ic2VydmVyQ29uc3RydWN0b3IsXHJcbiAgYXBwZW5kQ2hpbGRyZW4sXHJcbiAgZG9tUmVjdEhhc0RpbWVuc2lvbnMsXHJcbiAgYmluZCxcclxuICBub29wLFxyXG4gIGRvbVJlY3RBcHBlYXJlZCxcclxuICBjb25jYXQsXHJcbiAgZGVib3VuY2UsXHJcbiAgaXNCb29sZWFuLFxyXG4gIGlzQXJyYXksXHJcbiAgaXNFbXB0eUFycmF5LFxyXG59IGZyb20gJy4uL3N1cHBvcnQnO1xyXG5pbXBvcnQge1xyXG4gIGNsYXNzTmFtZVNpemVPYnNlcnZlcixcclxuICBjbGFzc05hbWVTaXplT2JzZXJ2ZXJBcHBlYXIsXHJcbiAgY2xhc3NOYW1lU2l6ZU9ic2VydmVyTGlzdGVuZXIsXHJcbn0gZnJvbSAnLi4vY2xhc3NuYW1lcyc7XHJcbmltcG9ydCB7IGdldFN0YXRpY1BsdWdpbk1vZHVsZUluc3RhbmNlLCBzaXplT2JzZXJ2ZXJQbHVnaW5OYW1lIH0gZnJvbSAnLi4vcGx1Z2lucyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNpemVPYnNlcnZlck9wdGlvbnMge1xyXG4gIC8qKiBXaGV0aGVyIGFwcGVhcmluZyBzaG91bGQgYmUgb2JzZXJ2ZWQuICovXHJcbiAgX2FwcGVhcj86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2l6ZU9ic2VydmVyQ2FsbGJhY2tQYXJhbXMge1xyXG4gIF9zaXplQ2hhbmdlZDogYm9vbGVhbjtcclxuICBfYXBwZWFyPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU2l6ZU9ic2VydmVyID0gKCkgPT4gKCkgPT4gdm9pZDtcclxuXHJcbmxldCByZXNpemVPYnNlcnZlckJveFN1cHBvcnQ6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2l6ZSBvYnNlcnZlciB3aGljaCBvYnNlcnZlcyBhbnkgc2l6ZSwgcGFkZGluZywgYm9yZGVyLCBtYXJnaW4gYW5kIGJveC1zaXppbmcgY2hhbmdlcyBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuIERlcGVuZGluZyBvbiB0aGUgb3B0aW9ucyBhbHNvIGRpcmVjdGlvbiBhbmQgYXBwZWFyIGNhbiBiZSBvYnNlcnZlZC5cclxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IGVsZW1lbnQgd2hpY2ggc2hhbGwgYmUgb2JzZXJ2ZWQuXHJcbiAqIEBwYXJhbSBvblNpemVDaGFuZ2VkQ2FsbGJhY2sgVGhlIGNhbGxiYWNrIHdoaWNoIGdldHMgY2FsbGVkIGFmdGVyIGEgc2l6ZSBjaGFuZ2Ugd2FzIGRldGVjdGVkLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3Igc2l6ZSBkZXRlY3Rpb24sIHdoZXRoZXIgdG8gb2JzZXJ2ZSBhbHNvIGRpcmVjdGlvbiBhbmQgYXBwZWFyLlxyXG4gKiBAcmV0dXJucyBBIG9iamVjdCB3aGljaCByZXByZXNlbnRzIHRoZSBpbnN0YW5jZSBvZiB0aGUgc2l6ZSBvYnNlcnZlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVTaXplT2JzZXJ2ZXIgPSAoXHJcbiAgdGFyZ2V0OiBIVE1MRWxlbWVudCxcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIG9uU2l6ZUNoYW5nZWRDYWxsYmFjazogKHBhcmFtczogU2l6ZU9ic2VydmVyQ2FsbGJhY2tQYXJhbXMpID0+IGFueSxcclxuICBvcHRpb25zPzogU2l6ZU9ic2VydmVyT3B0aW9uc1xyXG4pOiBTaXplT2JzZXJ2ZXIgPT4ge1xyXG4gIGNvbnN0IHsgX2FwcGVhcjogb2JzZXJ2ZUFwcGVhckNoYW5nZSB9ID0gb3B0aW9ucyB8fCB7fTtcclxuICBjb25zdCBzaXplT2JzZXJ2ZXJQbHVnaW4gPVxyXG4gICAgZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2U8dHlwZW9mIFNpemVPYnNlcnZlclBsdWdpbj4oc2l6ZU9ic2VydmVyUGx1Z2luTmFtZSk7XHJcbiAgY29uc3QgW3VwZGF0ZVJlc2l6ZU9ic2VydmVyQ29udGVudFJlY3RDYWNoZV0gPSBjcmVhdGVDYWNoZTxET01SZWN0UmVhZE9ubHkgfCBmYWxzZT4oe1xyXG4gICAgX2luaXRpYWxWYWx1ZTogZmFsc2UsXHJcbiAgICBfYWx3YXlzVXBkYXRlVmFsdWVzOiB0cnVlLFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgY29uc3QgZGVzdHJveUZuczogKCgpID0+IHZvaWQpW10gPSBbXTtcclxuICAgIGNvbnN0IHBvbHlmaWxsRWxlbWVudHMgPSBjcmVhdGVET00oXHJcbiAgICAgIGA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWVTaXplT2JzZXJ2ZXJ9XCI+PGRpdiBjbGFzcz1cIiR7Y2xhc3NOYW1lU2l6ZU9ic2VydmVyTGlzdGVuZXJ9XCI+PC9kaXY+PC9kaXY+YFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHBvbHlmaWxsUm9vdEVsZW1lbnQgPSBwb2x5ZmlsbEVsZW1lbnRzWzBdIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgY29uc3QgcG9seWZpbGxUYXJnZXRFbGVtZW50ID0gcG9seWZpbGxSb290RWxlbWVudC5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50O1xyXG5cclxuICAgIGNvbnN0IG9uU2l6ZUNoYW5nZWRDYWxsYmFja1Byb3h5ID0gKHNpemVDaGFuZ2VkQ29udGV4dD86IFJlc2l6ZU9ic2VydmVyRW50cnlbXSB8IGJvb2xlYW4pID0+IHtcclxuICAgICAgY29uc3QgaXNSZXNpemVPYnNlcnZlckNhbGwgPSBpc0FycmF5KHNpemVDaGFuZ2VkQ29udGV4dCkgJiYgIWlzRW1wdHlBcnJheShzaXplQ2hhbmdlZENvbnRleHQpO1xyXG5cclxuICAgICAgbGV0IHNraXAgPSBmYWxzZTtcclxuICAgICAgbGV0IGFwcGVhciA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gaWYgdHJpZ2dlcmVkIGZyb20gUk8uXHJcbiAgICAgIGlmIChpc1Jlc2l6ZU9ic2VydmVyQ2FsbCkge1xyXG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyRW50cnkgPSBzaXplQ2hhbmdlZENvbnRleHRbMF07XHJcbiAgICAgICAgY29uc3QgW2N1cnJDb250ZW50UmVjdCwgLCBwcmV2Q29udGVudFJlY3RdID0gdXBkYXRlUmVzaXplT2JzZXJ2ZXJDb250ZW50UmVjdENhY2hlKFxyXG4gICAgICAgICAgcmVzaXplT2JzZXJ2ZXJFbnRyeS5jb250ZW50UmVjdFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgaGFzRGltZW5zaW9ucyA9IGRvbVJlY3RIYXNEaW1lbnNpb25zKGN1cnJDb250ZW50UmVjdCk7XHJcbiAgICAgICAgYXBwZWFyID0gZG9tUmVjdEFwcGVhcmVkKGN1cnJDb250ZW50UmVjdCwgcHJldkNvbnRlbnRSZWN0KTtcclxuICAgICAgICBza2lwID0gIWFwcGVhciAmJiAhaGFzRGltZW5zaW9uczsgLy8gc2tpcCBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igd2hlbiB3aW5kb3cgcmVzaXplXHJcbiAgICAgIH1cclxuICAgICAgLy8gZWxzZSBpZiBpdCB0cmlnZ2VyZWQgd2l0aCBhcHBlYXIgZnJvbSBwb2x5ZmlsbFxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBhcHBlYXIgPSBzaXplQ2hhbmdlZENvbnRleHQgPT09IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghc2tpcCkge1xyXG4gICAgICAgIG9uU2l6ZUNoYW5nZWRDYWxsYmFjayh7XHJcbiAgICAgICAgICBfc2l6ZUNoYW5nZWQ6IHRydWUsXHJcbiAgICAgICAgICBfYXBwZWFyOiBhcHBlYXIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKFJlc2l6ZU9ic2VydmVyQ29uc3RydWN0b3IpIHtcclxuICAgICAgaWYgKCFpc0Jvb2xlYW4ocmVzaXplT2JzZXJ2ZXJCb3hTdXBwb3J0KSkge1xyXG4gICAgICAgIGNvbnN0IGRldGVjdFN1cHBvcnRSZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnN0cnVjdG9yKG5vb3ApO1xyXG4gICAgICAgIGRldGVjdFN1cHBvcnRSZXNpemVPYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSAtPiB2b2lkID09PSB1bmRlZmluZWRcclxuICAgICAgICAgIGdldCBib3goKSB7XHJcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyQm94U3VwcG9ydCA9IHRydWU7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyQm94U3VwcG9ydCA9IHJlc2l6ZU9ic2VydmVyQm94U3VwcG9ydCB8fCBmYWxzZTtcclxuICAgICAgICBkZXRlY3RTdXBwb3J0UmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKlxyXG4gICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XHJcbiAgICAgIGNvbnN0IHRhc2tzOiBTZXQ8KCkgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XHJcbiAgICAgIGNvbnN0IGRlYm91bmNlVGltaW5nOiBEZWJvdW5jZVRpbWluZyA9IHtcclxuICAgICAgICBfZGVib3VuY2VyOiAodGFzaykgPT4ge1xyXG4gICAgICAgICAgdGFza3MuYWRkKHRhc2spO1xyXG4gICAgICAgICAgcG9ydDIucG9zdE1lc3NhZ2UoMCk7XHJcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICAgIHBvcnQxLm9ubWVzc2FnZSA9ICgpID0+IHtcclxuICAgICAgICB0YXNrcy5mb3JFYWNoKCh0YXNrKSA9PiB0YXNrKCkpO1xyXG4gICAgICB9O1xyXG4gICAgICAqL1xyXG4gICAgICBjb25zdCBkZWJvdW5jZWRPblNpemVDaGFuZ2VkQ2FsbGJhY2tQcm94eSA9IGRlYm91bmNlKG9uU2l6ZUNoYW5nZWRDYWxsYmFja1Byb3h5LCB7XHJcbiAgICAgICAgX2RlYm91bmNlVGltaW5nOiAwLFxyXG4gICAgICAgIF9tYXhEZWJvdW5jZVRpbWluZzogMCxcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSA9PlxyXG4gICAgICAgIGRlYm91bmNlZE9uU2l6ZUNoYW5nZWRDYWxsYmFja1Byb3h5KGVudHJpZXMpO1xyXG4gICAgICBjb25zdCBjb250ZW50Qm94UmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb25zdHJ1Y3RvcihyZXNpemVPYnNlcnZlckNhbGxiYWNrKTtcclxuICAgICAgY29udGVudEJveFJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVzaXplT2JzZXJ2ZXJCb3hTdXBwb3J0ID8gdGFyZ2V0IDogcG9seWZpbGxUYXJnZXRFbGVtZW50KTtcclxuXHJcbiAgICAgIHB1c2goZGVzdHJveUZucywgW1xyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGNvbnRlbnRCb3hSZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAvKlxyXG4gICAgICAgICAgcG9ydDEuY2xvc2UoKTtcclxuICAgICAgICAgIHBvcnQyLmNsb3NlKCk7XHJcbiAgICAgICAgICB0YXNrcy5jbGVhcigpO1xyXG4gICAgICAgICAgKi9cclxuICAgICAgICB9LFxyXG4gICAgICAgICFyZXNpemVPYnNlcnZlckJveFN1cHBvcnQgJiYgYXBwZW5kQ2hpbGRyZW4odGFyZ2V0LCBwb2x5ZmlsbFJvb3RFbGVtZW50KSxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBpZiAocmVzaXplT2JzZXJ2ZXJCb3hTdXBwb3J0KSB7XHJcbiAgICAgICAgY29uc3QgYm9yZGVyQm94UmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb25zdHJ1Y3RvcihyZXNpemVPYnNlcnZlckNhbGxiYWNrKTtcclxuICAgICAgICBib3JkZXJCb3hSZXNpemVPYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xyXG4gICAgICAgICAgYm94OiAnYm9yZGVyLWJveCcsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHVzaChkZXN0cm95Rm5zLCAoKSA9PiBib3JkZXJCb3hSZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHNpemVPYnNlcnZlclBsdWdpbikge1xyXG4gICAgICBjb25zdCBbcGx1Z2luQXBwZWFyQ2FsbGJhY2ssIHBsdWdpbkRlc3Ryb3lGbnNdID0gc2l6ZU9ic2VydmVyUGx1Z2luKFxyXG4gICAgICAgIHBvbHlmaWxsVGFyZ2V0RWxlbWVudCxcclxuICAgICAgICBvblNpemVDaGFuZ2VkQ2FsbGJhY2tQcm94eSxcclxuICAgICAgICBvYnNlcnZlQXBwZWFyQ2hhbmdlXHJcbiAgICAgICk7XHJcbiAgICAgIHB1c2goXHJcbiAgICAgICAgZGVzdHJveUZucyxcclxuICAgICAgICBjb25jYXQoXHJcbiAgICAgICAgICBbXHJcbiAgICAgICAgICAgIGFkZENsYXNzKHBvbHlmaWxsUm9vdEVsZW1lbnQsIGNsYXNzTmFtZVNpemVPYnNlcnZlckFwcGVhciksXHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIocG9seWZpbGxSb290RWxlbWVudCwgJ2FuaW1hdGlvbnN0YXJ0JywgcGx1Z2luQXBwZWFyQ2FsbGJhY2spLFxyXG4gICAgICAgICAgICBhcHBlbmRDaGlsZHJlbih0YXJnZXQsIHBvbHlmaWxsUm9vdEVsZW1lbnQpLFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICAgIHBsdWdpbkRlc3Ryb3lGbnNcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbm9vcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmluZChydW5FYWNoQW5kQ2xlYXIsIGRlc3Ryb3lGbnMpO1xyXG4gIH07XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgV0gsIENhY2hlVmFsdWVzIH0gZnJvbSAnLi4vc3VwcG9ydCc7XHJcbmltcG9ydCB7IGNyZWF0ZVNpemVPYnNlcnZlciB9IGZyb20gJy4vc2l6ZU9ic2VydmVyJztcclxuaW1wb3J0IHsgY2xhc3NOYW1lVHJpbnNpY09ic2VydmVyIH0gZnJvbSAnLi4vY2xhc3NuYW1lcyc7XHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlRGl2LFxyXG4gIGdldE9mZnNldFNpemUsXHJcbiAgcnVuRWFjaEFuZENsZWFyLFxyXG4gIGNyZWF0ZUNhY2hlLFxyXG4gIHB1c2gsXHJcbiAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3RvcixcclxuICBhcHBlbmRDaGlsZHJlbixcclxuICBiaW5kLFxyXG59IGZyb20gJy4uL3N1cHBvcnQnO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuZXhwb3J0IHR5cGUgVHJpbnNpY09ic2VydmVyQ2FsbGJhY2sgPSAoaGVpZ2h0SW50cmluc2ljOiBDYWNoZVZhbHVlczxib29sZWFuPikgPT4gYW55O1xyXG5leHBvcnQgdHlwZSBUcmluc2ljT2JzZXJ2ZXIgPSBbXHJcbiAgY29uc3RydWN0OiAoKSA9PiAoKSA9PiB2b2lkLFxyXG4gIHVwZGF0ZTogKCkgPT4gdm9pZCB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZCB8IFBhcmFtZXRlcnM8VHJpbnNpY09ic2VydmVyQ2FsbGJhY2s+LFxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB0cmluc2ljIG9ic2VydmVyIHdoaWNoIG9ic2VydmVzIGNoYW5nZXMgdG8gaW50cmluc2ljIG9yIGV4dHJpbnNpYyBzaXppbmcgZm9yIHRoZSBoZWlnaHQgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBlbGVtZW50IHdoaWNoIHNoYWxsIGJlIG9ic2VydmVkLlxyXG4gKiBAcGFyYW0gb25Ucmluc2ljQ2hhbmdlZENhbGxiYWNrIFRoZSBjYWxsYmFjayB3aGljaCBnZXRzIGNhbGxlZCBhZnRlciBhIGNoYW5nZSB3YXMgZGV0ZWN0ZWQuXHJcbiAqIEByZXR1cm5zIEEgb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgdGhlIGluc3RhbmNlIG9mIHRoZSB0cmluc2ljIG9ic2VydmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRyaW5zaWNPYnNlcnZlciA9IChcclxuICB0YXJnZXQ6IEhUTUxFbGVtZW50LFxyXG4gIG9uVHJpbnNpY0NoYW5nZWRDYWxsYmFjazogVHJpbnNpY09ic2VydmVyQ2FsbGJhY2tcclxuKTogVHJpbnNpY09ic2VydmVyID0+IHtcclxuICBsZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbnN0YW5jZTogdW5kZWZpbmVkIHwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XHJcbiAgY29uc3QgaXNIZWlnaHRJbnRyaW5zaWMgPSAoaW9FbnRyeU9yU2l6ZTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSB8IFdIPG51bWJlcj4pOiBib29sZWFuID0+XHJcbiAgICAoaW9FbnRyeU9yU2l6ZSBhcyBXSDxudW1iZXI+KS5oID09PSAwIHx8XHJcbiAgICAoaW9FbnRyeU9yU2l6ZSBhcyBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KS5pc0ludGVyc2VjdGluZyB8fFxyXG4gICAgKGlvRW50cnlPclNpemUgYXMgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xyXG4gIGNvbnN0IHRyaW5zaWNPYnNlcnZlciA9IGNyZWF0ZURpdihjbGFzc05hbWVUcmluc2ljT2JzZXJ2ZXIpO1xyXG4gIGNvbnN0IFt1cGRhdGVIZWlnaHRJbnRyaW5zaWNDYWNoZV0gPSBjcmVhdGVDYWNoZSh7XHJcbiAgICBfaW5pdGlhbFZhbHVlOiBmYWxzZSxcclxuICB9KTtcclxuICBjb25zdCB0cmlnZ2VyT25Ucmluc2ljQ2hhbmdlZENhbGxiYWNrID0gKFxyXG4gICAgdXBkYXRlVmFsdWU6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgfCBXSDxudW1iZXI+IHwgdW5kZWZpbmVkLFxyXG4gICAgZnJvbVJlY29yZHM/OiBib29sZWFuXHJcbiAgKTogdm9pZCB8IFBhcmFtZXRlcnM8VHJpbnNpY09ic2VydmVyQ2FsbGJhY2s+ID0+IHtcclxuICAgIGlmICh1cGRhdGVWYWx1ZSkge1xyXG4gICAgICBjb25zdCBoZWlnaHRJbnRyaW5zaWMgPSB1cGRhdGVIZWlnaHRJbnRyaW5zaWNDYWNoZShpc0hlaWdodEludHJpbnNpYyh1cGRhdGVWYWx1ZSkpO1xyXG4gICAgICBjb25zdCBbLCBoZWlnaHRJbnRyaW5zaWNDaGFuZ2VkXSA9IGhlaWdodEludHJpbnNpYztcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICBoZWlnaHRJbnRyaW5zaWNDaGFuZ2VkICYmXHJcbiAgICAgICAgIWZyb21SZWNvcmRzICYmXHJcbiAgICAgICAgb25Ucmluc2ljQ2hhbmdlZENhbGxiYWNrKGhlaWdodEludHJpbnNpYykgJiYgW2hlaWdodEludHJpbnNpY11cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sgPSAoXHJcbiAgICBmcm9tUmVjb3JkczogYm9vbGVhbixcclxuICAgIGVudHJpZXM6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlbXVxyXG4gICkgPT4gdHJpZ2dlck9uVHJpbnNpY0NoYW5nZWRDYWxsYmFjayhlbnRyaWVzLnBvcCgpLCBmcm9tUmVjb3Jkcyk7XHJcblxyXG4gIHJldHVybiBbXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRlc3Ryb3lGbnM6ICgoKSA9PiB2b2lkKVtdID0gW107XHJcblxyXG4gICAgICBpZiAoSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGludGVyc2VjdGlvbk9ic2VydmVySW5zdGFuY2UgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3RvcihcclxuICAgICAgICAgIGJpbmQoaW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjaywgZmFsc2UpLFxyXG4gICAgICAgICAgeyByb290OiB0YXJnZXQgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbnN0YW5jZS5vYnNlcnZlKHRyaW5zaWNPYnNlcnZlcik7XHJcbiAgICAgICAgcHVzaChkZXN0cm95Rm5zLCAoKSA9PiB7XHJcbiAgICAgICAgICBpbnRlcnNlY3Rpb25PYnNlcnZlckluc3RhbmNlIS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgb25TaXplQ2hhbmdlZCA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBnZXRPZmZzZXRTaXplKHRyaW5zaWNPYnNlcnZlcik7XHJcbiAgICAgICAgICB0cmlnZ2VyT25Ucmluc2ljQ2hhbmdlZENhbGxiYWNrKG5ld1NpemUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcHVzaChkZXN0cm95Rm5zLCBjcmVhdGVTaXplT2JzZXJ2ZXIodHJpbnNpY09ic2VydmVyLCBvblNpemVDaGFuZ2VkKSgpKTtcclxuICAgICAgICBvblNpemVDaGFuZ2VkKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBiaW5kKHJ1bkVhY2hBbmRDbGVhciwgcHVzaChkZXN0cm95Rm5zLCBhcHBlbmRDaGlsZHJlbih0YXJnZXQsIHRyaW5zaWNPYnNlcnZlcikpKTtcclxuICAgIH0sXHJcbiAgICAoKSA9PlxyXG4gICAgICBpbnRlcnNlY3Rpb25PYnNlcnZlckluc3RhbmNlICYmXHJcbiAgICAgIGludGVyc2VjdGlvbk9ic2VydmVyQ2FsbGJhY2sodHJ1ZSwgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbnN0YW5jZS50YWtlUmVjb3JkcygpKSxcclxuICBdO1xyXG59O1xyXG4iLCJpbXBvcnQgdHlwZSB7IE9wdGlvbnMsIE9wdGlvbnNDaGVja0ZuLCBPcHRpb25zRGVib3VuY2VWYWx1ZSB9IGZyb20gJy4uLy4uL29wdGlvbnMnO1xyXG5pbXBvcnQgdHlwZSB7IFNjcm9sbGJhcnNIaWRpbmdQbHVnaW4gfSBmcm9tICcuLi8uLi9wbHVnaW5zJztcclxuaW1wb3J0IHR5cGUgeyBTaXplT2JzZXJ2ZXJDYWxsYmFja1BhcmFtcyB9IGZyb20gJy4uLy4uL29ic2VydmVycyc7XHJcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlU2V0dXBFbGVtZW50c09iaiB9IGZyb20gJy4uL3N0cnVjdHVyZVNldHVwL3N0cnVjdHVyZVNldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHR5cGUgeyBTZXR1cCwgU2V0dXBVcGRhdGVJbmZvLCBTdHJ1Y3R1cmVTZXR1cFN0YXRlIH0gZnJvbSAnLi4vLi4vc2V0dXBzJztcclxuaW1wb3J0IHR5cGUgeyBDYWNoZVZhbHVlcywgRGVib3VuY2VMZWFkaW5nLCBEZWJvdW5jZVRpbWluZywgV0ggfSBmcm9tICcuLi8uLi9zdXBwb3J0JztcclxuaW1wb3J0IHR5cGUgeyBQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xyXG5pbXBvcnQgeyBkZWZhdWx0T3B0aW9uc1VwZGF0ZURlYm91bmNlRW52LCBkZWZhdWx0T3B0aW9uc1VwZGF0ZURlYm91bmNlRXZlbnQgfSBmcm9tICcuLi8uLi9vcHRpb25zJztcclxuaW1wb3J0IHsgZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2UsIHNjcm9sbGJhcnNIaWRpbmdQbHVnaW5OYW1lIH0gZnJvbSAnLi4vLi4vcGx1Z2lucyc7XHJcbmltcG9ydCB7XHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFyLFxyXG4gIGRhdGFBdHRyaWJ1dGVIb3N0LFxyXG4gIGRhdGFBdHRyaWJ1dGVWaWV3cG9ydCxcclxuICBkYXRhVmFsdWVWaWV3cG9ydE1lYXN1cmluZyxcclxuICBkYXRhVmFsdWVWaWV3cG9ydEFycmFuZ2UsXHJcbiAgZGF0YVZhbHVlTm9DbGlwcGluZyxcclxufSBmcm9tICcuLi8uLi9jbGFzc25hbWVzJztcclxuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnQgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XHJcbmltcG9ydCB7IGNyZWF0ZURPTU9ic2VydmVyLCBjcmVhdGVTaXplT2JzZXJ2ZXIsIGNyZWF0ZVRyaW5zaWNPYnNlcnZlciB9IGZyb20gJy4uLy4uL29ic2VydmVycyc7XHJcbmltcG9ydCB7XHJcbiAgUmVzaXplT2JzZXJ2ZXJDb25zdHJ1Y3RvcixcclxuICBhc3NpZ25EZWVwLFxyXG4gIGNsb3Nlc3QsXHJcbiAgY3JlYXRlQ2FjaGUsXHJcbiAgZGVib3VuY2UsXHJcbiAgZXF1YWxXSCxcclxuICBnZXRGcmFjdGlvbmFsU2l6ZSxcclxuICBpc0FycmF5LFxyXG4gIGlzRnVuY3Rpb24sXHJcbiAgaXNOdW1iZXIsXHJcbiAgaXNQbGFpbk9iamVjdCxcclxuICBrZXlzLFxyXG4gIGxpZXNCZXR3ZWVuLFxyXG4gIGdldFNjcm9sbFNpemUsXHJcbiAgZ2V0RWxlbWVudFNjcm9sbCxcclxuICBzY3JvbGxFbGVtZW50VG8sXHJcbiAgZG9tUmVjdEFwcGVhcmVkLFxyXG4gIGNvbmNhdCxcclxuICBnZXRTdHlsZXMsXHJcbiAgaGFzQXR0ckNsYXNzLFxyXG59IGZyb20gJy4uLy4uL3N1cHBvcnQnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZlcnNTZXR1cFN0YXRlIHtcclxuICBfaGVpZ2h0SW50cmluc2ljOiBib29sZWFuO1xyXG4gIF9kaXJlY3Rpb25Jc1JUTDogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZlcnNTZXR1cFVwZGF0ZUluZm8gZXh0ZW5kcyBTZXR1cFVwZGF0ZUluZm8ge1xyXG4gIF90YWtlUmVjb3Jkcz86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE9ic2VydmVyc1NldHVwVXBkYXRlSGludHMgPSB7XHJcbiAgX3NpemVDaGFuZ2VkPzogYm9vbGVhbjtcclxuICBfZGlyZWN0aW9uQ2hhbmdlZD86IGJvb2xlYW47XHJcbiAgX2hlaWdodEludHJpbnNpY0NoYW5nZWQ/OiBib29sZWFuO1xyXG4gIF9ob3N0TXV0YXRpb24/OiBib29sZWFuO1xyXG4gIF9jb250ZW50TXV0YXRpb24/OiBib29sZWFuO1xyXG4gIF9hcHBlYXI/OiBib29sZWFuO1xyXG4gIF9zY3JvbGxiYXJTaXplQ2hhbmdlZD86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBPYnNlcnZlcnNTZXR1cCA9IFNldHVwPFxyXG4gIE9ic2VydmVyc1NldHVwVXBkYXRlSW5mbyxcclxuICBPYnNlcnZlcnNTZXR1cFN0YXRlLFxyXG4gIE9ic2VydmVyc1NldHVwVXBkYXRlSGludHNcclxuPjtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVPYnNlcnZlcnNTZXR1cCA9IChcclxuICBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzOiBTdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzT2JqLFxyXG4gIHN0cnVjdHVyZVNldHVwU3RhdGU6IFN0cnVjdHVyZVNldHVwU3RhdGUsXHJcbiAgZ2V0Q3VycmVudE9wdGlvbjogT3B0aW9uc0NoZWNrRm48T3B0aW9ucz4sXHJcbiAgb25PYnNlcnZlcnNVcGRhdGVkOiAodXBkYXRlSGludHM6IE9ic2VydmVyc1NldHVwVXBkYXRlSGludHMpID0+IHZvaWRcclxuKTogT2JzZXJ2ZXJzU2V0dXAgPT4ge1xyXG4gIC8vIGxhdGVzdCBkZWJvdW5jZSBvcHRpb25zXHJcbiAgbGV0IGRlYm91bmNlTXV0YXRpb246IE9wdGlvbnNEZWJvdW5jZVZhbHVlIHwgdW5kZWZpbmVkO1xyXG4gIGxldCBkZWJvdW5jZVJlc2l6ZTogT3B0aW9uc0RlYm91bmNlVmFsdWUgfCB1bmRlZmluZWQ7XHJcbiAgbGV0IGRlYm91bmNlRXZlbnQ6IE9wdGlvbnNEZWJvdW5jZVZhbHVlIHwgdW5kZWZpbmVkO1xyXG4gIGxldCBkZWJvdW5jZUVudjogT3B0aW9uc0RlYm91bmNlVmFsdWUgfCB1bmRlZmluZWQ7XHJcblxyXG4gIGxldCB1cGRhdGVDb250ZW50TXV0YXRpb25PYnNlcnZlcjogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xyXG4gIGxldCBkZXN0cm95Q29udGVudE11dGF0aW9uT2JzZXJ2ZXI6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcclxuICBsZXQgcHJldkNvbnRlbnRSZWN0OiBET01SZWN0UmVhZE9ubHkgfCB1bmRlZmluZWQ7XHJcbiAgbGV0IHByZXZEaXJlY3Rpb25Jc1JUTDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICBjb25zdCBob3N0U2VsZWN0b3IgPSBgWyR7ZGF0YUF0dHJpYnV0ZUhvc3R9XWA7XHJcblxyXG4gIC8vIFRPRE86IG9ic2VydmVyIHRleHRhcmVhIGF0dHJzIGlmIHRleHRhcmVhXHJcblxyXG4gIGNvbnN0IHZpZXdwb3J0U2VsZWN0b3IgPSBgWyR7ZGF0YUF0dHJpYnV0ZVZpZXdwb3J0fV1gO1xyXG4gIGNvbnN0IGJhc2VTdHlsZUNoYW5naW5nQXR0cnMgPSBbJ2lkJywgJ2NsYXNzJywgJ3N0eWxlJywgJ29wZW4nLCAnd3JhcCcsICdjb2xzJywgJ3Jvd3MnXTtcclxuICBjb25zdCB7XHJcbiAgICBfdGFyZ2V0LFxyXG4gICAgX2hvc3QsXHJcbiAgICBfdmlld3BvcnQsXHJcbiAgICBfc2Nyb2xsT2Zmc2V0RWxlbWVudCxcclxuICAgIF9jb250ZW50LFxyXG4gICAgX3ZpZXdwb3J0SXNUYXJnZXQsXHJcbiAgICBfaXNCb2R5LFxyXG4gICAgX3ZpZXdwb3J0SGFzQ2xhc3MsXHJcbiAgICBfdmlld3BvcnRBZGRSZW1vdmVDbGFzcyxcclxuICAgIF9yZW1vdmVTY3JvbGxPYnNjdXJpbmdTdHlsZXMsXHJcbiAgfSA9IHN0cnVjdHVyZVNldHVwRWxlbWVudHM7XHJcbiAgY29uc3QgZ2V0RGlyZWN0aW9uSXNSVEwgPSAoZWxtOiBIVE1MRWxlbWVudCk6IGJvb2xlYW4gPT4gZ2V0U3R5bGVzKGVsbSwgJ2RpcmVjdGlvbicpID09PSAncnRsJztcclxuICBjb25zdCBjcmVhdGVEZWJvdW5jZWRPYnNlcnZlc1VwZGF0ZSA9ICgpID0+IHtcclxuICAgIGxldCBjdXJyRGVib3VuY2VUaW1pbmc6IERlYm91bmNlVGltaW5nO1xyXG4gICAgbGV0IGN1cnJNYXhEZWJvdW5jZVRpbWluZzogRGVib3VuY2VUaW1pbmc7XHJcbiAgICBsZXQgY3VyckRlYm91bmNlTGVhZGluZzogRGVib3VuY2VMZWFkaW5nO1xyXG4gICAgY29uc3QgZGVib3VuY2VkRm4gPSBkZWJvdW5jZShvbk9ic2VydmVyc1VwZGF0ZWQsIHtcclxuICAgICAgX2RlYm91bmNlVGltaW5nOiAoKSA9PiBjdXJyRGVib3VuY2VUaW1pbmcsXHJcbiAgICAgIF9tYXhEZWJvdW5jZVRpbWluZzogKCkgPT4gY3Vyck1heERlYm91bmNlVGltaW5nLFxyXG4gICAgICBfbGVhZGluZzogKCkgPT4gY3VyckRlYm91bmNlTGVhZGluZyxcclxuICAgICAgX21lcmdlUGFyYW1zKHByZXYsIGN1cnIpIHtcclxuICAgICAgICBjb25zdCBbcHJldk9ial0gPSBwcmV2O1xyXG4gICAgICAgIGNvbnN0IFtjdXJyT2JqXSA9IGN1cnI7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIGNvbmNhdChrZXlzKHByZXZPYmopLCBrZXlzKGN1cnJPYmopKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIG9ialtrZXldID0gcHJldk9ialtrZXkgYXMga2V5b2YgdHlwZW9mIHByZXZPYmpdIHx8IGN1cnJPYmpba2V5IGFzIGtleW9mIHR5cGVvZiBjdXJyT2JqXTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgIH0sIHt9IGFzIFBsYWluT2JqZWN0KSxcclxuICAgICAgICBdIGFzIFtQYXJ0aWFsPE9ic2VydmVyc1NldHVwVXBkYXRlSGludHM+XTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZm4gPSAoXHJcbiAgICAgIHVwZGF0ZUhpbnRzOiBPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzLFxyXG4gICAgICBkZWJvdW5jZU9wdGlvbjogT3B0aW9uc0RlYm91bmNlVmFsdWUgfCBmYWxzZSB8IHVuZGVmaW5lZFxyXG4gICAgKSA9PiB7XHJcbiAgICAgIGlmIChpc0FycmF5KGRlYm91bmNlT3B0aW9uKSkge1xyXG4gICAgICAgIGNvbnN0IFt0aW1pbmcsIG1heFRpbWluZywgbGVhZGluZ10gPSBkZWJvdW5jZU9wdGlvbjtcclxuICAgICAgICBjdXJyRGVib3VuY2VUaW1pbmcgPSB0aW1pbmc7XHJcbiAgICAgICAgY3Vyck1heERlYm91bmNlVGltaW5nID0gbWF4VGltaW5nO1xyXG4gICAgICAgIGN1cnJEZWJvdW5jZUxlYWRpbmcgPSBsZWFkaW5nO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGRlYm91bmNlT3B0aW9uKSkge1xyXG4gICAgICAgIGN1cnJEZWJvdW5jZVRpbWluZyA9IGRlYm91bmNlT3B0aW9uO1xyXG4gICAgICAgIGN1cnJNYXhEZWJvdW5jZVRpbWluZyA9IGZhbHNlO1xyXG4gICAgICAgIGN1cnJEZWJvdW5jZUxlYWRpbmcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyRGVib3VuY2VUaW1pbmcgPSBmYWxzZTtcclxuICAgICAgICBjdXJyTWF4RGVib3VuY2VUaW1pbmcgPSBmYWxzZTtcclxuICAgICAgICBjdXJyRGVib3VuY2VMZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRlYm91bmNlZEZuKHVwZGF0ZUhpbnRzKTtcclxuICAgIH07XHJcbiAgICBmbi5fZmx1c2ggPSBkZWJvdW5jZWRGbi5fZmx1c2g7XHJcblxyXG4gICAgcmV0dXJuIGZuO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHN0YXRlOiBPYnNlcnZlcnNTZXR1cFN0YXRlID0ge1xyXG4gICAgX2hlaWdodEludHJpbnNpYzogZmFsc2UsXHJcbiAgICBfZGlyZWN0aW9uSXNSVEw6IGdldERpcmVjdGlvbklzUlRMKF90YXJnZXQpLFxyXG4gIH07XHJcbiAgY29uc3QgZW52ID0gZ2V0RW52aXJvbm1lbnQoKTtcclxuICBjb25zdCBzY3JvbGxiYXJzSGlkaW5nUGx1Z2luID0gZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2U8dHlwZW9mIFNjcm9sbGJhcnNIaWRpbmdQbHVnaW4+KFxyXG4gICAgc2Nyb2xsYmFyc0hpZGluZ1BsdWdpbk5hbWVcclxuICApO1xyXG4gIGNvbnN0IFt1cGRhdGVDb250ZW50U2l6ZUNhY2hlXSA9IGNyZWF0ZUNhY2hlPFdIPG51bWJlcj4+KFxyXG4gICAge1xyXG4gICAgICBfZXF1YWw6IGVxdWFsV0gsXHJcbiAgICAgIF9pbml0aWFsVmFsdWU6IHsgdzogMCwgaDogMCB9LFxyXG4gICAgfSxcclxuICAgICgpID0+IHtcclxuICAgICAgY29uc3QgdW5kb1ZpZXdwb3J0QXJyYW5nZSA9XHJcbiAgICAgICAgc2Nyb2xsYmFyc0hpZGluZ1BsdWdpbiAmJlxyXG4gICAgICAgIHNjcm9sbGJhcnNIaWRpbmdQbHVnaW4uX3ZpZXdwb3J0QXJyYW5nZW1lbnQoXHJcbiAgICAgICAgICBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzLFxyXG4gICAgICAgICAgc3RydWN0dXJlU2V0dXBTdGF0ZSxcclxuICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgZW52LFxyXG4gICAgICAgICAgZ2V0Q3VycmVudE9wdGlvblxyXG4gICAgICAgICkuX3VuZG9WaWV3cG9ydEFycmFuZ2U7XHJcblxyXG4gICAgICBjb25zdCB2aWV3cG9ydElzVGFyZ2V0Qm9keSA9IF9pc0JvZHkgJiYgX3ZpZXdwb3J0SXNUYXJnZXQ7XHJcbiAgICAgIGNvbnN0IG5vQ2xpcHBpbmcgPVxyXG4gICAgICAgICF2aWV3cG9ydElzVGFyZ2V0Qm9keSAmJiBoYXNBdHRyQ2xhc3MoX2hvc3QsIGRhdGFBdHRyaWJ1dGVIb3N0LCBkYXRhVmFsdWVOb0NsaXBwaW5nKTtcclxuICAgICAgY29uc3QgaXNBcnJhbmdlZCA9ICFfdmlld3BvcnRJc1RhcmdldCAmJiBfdmlld3BvcnRIYXNDbGFzcyhkYXRhVmFsdWVWaWV3cG9ydEFycmFuZ2UpO1xyXG4gICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSBpc0FycmFuZ2VkICYmIGdldEVsZW1lbnRTY3JvbGwoX3Njcm9sbE9mZnNldEVsZW1lbnQpO1xyXG4gICAgICBjb25zdCByZXZlcnRTY3JvbGxPYnNjdXJpbmdTdHlsZXMgPSBzY3JvbGxPZmZzZXQgJiYgX3JlbW92ZVNjcm9sbE9ic2N1cmluZ1N0eWxlcygpO1xyXG5cclxuICAgICAgY29uc3QgcmV2ZXJ0TWVhc3VyaW5nID0gX3ZpZXdwb3J0QWRkUmVtb3ZlQ2xhc3MoZGF0YVZhbHVlVmlld3BvcnRNZWFzdXJpbmcsIG5vQ2xpcHBpbmcpO1xyXG4gICAgICBjb25zdCByZWRvVmlld3BvcnRBcnJhbmdlID0gaXNBcnJhbmdlZCAmJiB1bmRvVmlld3BvcnRBcnJhbmdlICYmIHVuZG9WaWV3cG9ydEFycmFuZ2UoKTtcclxuICAgICAgY29uc3Qgdmlld3BvcnRTY3JvbGwgPSBnZXRTY3JvbGxTaXplKF92aWV3cG9ydCk7XHJcbiAgICAgIGNvbnN0IGZyYWN0aW9uYWwgPSBnZXRGcmFjdGlvbmFsU2l6ZShfdmlld3BvcnQpO1xyXG5cclxuICAgICAgaWYgKHJlZG9WaWV3cG9ydEFycmFuZ2UpIHtcclxuICAgICAgICByZWRvVmlld3BvcnRBcnJhbmdlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjcm9sbEVsZW1lbnRUbyhfc2Nyb2xsT2Zmc2V0RWxlbWVudCwgc2Nyb2xsT2Zmc2V0KTtcclxuICAgICAgaWYgKHJldmVydFNjcm9sbE9ic2N1cmluZ1N0eWxlcykge1xyXG4gICAgICAgIHJldmVydFNjcm9sbE9ic2N1cmluZ1N0eWxlcygpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChub0NsaXBwaW5nKSB7XHJcbiAgICAgICAgcmV2ZXJ0TWVhc3VyaW5nKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdzogdmlld3BvcnRTY3JvbGwudyArIGZyYWN0aW9uYWwudyxcclxuICAgICAgICBoOiB2aWV3cG9ydFNjcm9sbC5oICsgZnJhY3Rpb25hbC5oLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICk7XHJcbiAgY29uc3Qgb25PYnNlcnZlcnNVcGRhdGVkRGVib3VuY2VkID0gY3JlYXRlRGVib3VuY2VkT2JzZXJ2ZXNVcGRhdGUoKTtcclxuICBjb25zdCBzZXREaXJlY3Rpb24gPSAodXBkYXRlSGludHM6IE9ic2VydmVyc1NldHVwVXBkYXRlSGludHMpID0+IHtcclxuICAgIGNvbnN0IG5ld0RpcmVjdGlvbklzUlRMID0gZ2V0RGlyZWN0aW9uSXNSVEwoX3RhcmdldCk7XHJcbiAgICBhc3NpZ25EZWVwKHVwZGF0ZUhpbnRzLCB7IF9kaXJlY3Rpb25DaGFuZ2VkOiBwcmV2RGlyZWN0aW9uSXNSVEwgIT09IG5ld0RpcmVjdGlvbklzUlRMIH0pO1xyXG4gICAgYXNzaWduRGVlcChzdGF0ZSwgeyBfZGlyZWN0aW9uSXNSVEw6IG5ld0RpcmVjdGlvbklzUlRMIH0pO1xyXG4gICAgcHJldkRpcmVjdGlvbklzUlRMID0gbmV3RGlyZWN0aW9uSXNSVEw7XHJcbiAgfTtcclxuICBjb25zdCBvblRyaW5zaWNDaGFuZ2VkID0gKFxyXG4gICAgaGVpZ2h0SW50cmluc2ljQ2FjaGU6IENhY2hlVmFsdWVzPGJvb2xlYW4+LFxyXG4gICAgZnJvbVJlY29yZHM/OiB0cnVlXHJcbiAgKTogT2JzZXJ2ZXJzU2V0dXBVcGRhdGVIaW50cyA9PiB7XHJcbiAgICBjb25zdCBbaGVpZ2h0SW50cmluc2ljLCBoZWlnaHRJbnRyaW5zaWNDaGFuZ2VkXSA9IGhlaWdodEludHJpbnNpY0NhY2hlO1xyXG4gICAgY29uc3QgdXBkYXRlSGludHM6IE9ic2VydmVyc1NldHVwVXBkYXRlSGludHMgPSB7XHJcbiAgICAgIF9oZWlnaHRJbnRyaW5zaWNDaGFuZ2VkOiBoZWlnaHRJbnRyaW5zaWNDaGFuZ2VkLFxyXG4gICAgfTtcclxuXHJcbiAgICBhc3NpZ25EZWVwKHN0YXRlLCB7IF9oZWlnaHRJbnRyaW5zaWM6IGhlaWdodEludHJpbnNpYyB9KTtcclxuXHJcbiAgICBpZiAoIWZyb21SZWNvcmRzKSB7XHJcbiAgICAgIG9uT2JzZXJ2ZXJzVXBkYXRlZCh1cGRhdGVIaW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVwZGF0ZUhpbnRzO1xyXG4gIH07XHJcbiAgY29uc3Qgb25TaXplQ2hhbmdlZCA9ICh7IF9zaXplQ2hhbmdlZCwgX2FwcGVhciB9OiBTaXplT2JzZXJ2ZXJDYWxsYmFja1BhcmFtcykgPT4ge1xyXG4gICAgLy8gb25seSBkb24ndCBkZWJvdW5jZSBhcHBlYXIgc2luY2UgaXQgc2hvdWxkbid0IGhhcHBlbiB0aGF0IGZyZXF1ZW50bHlcclxuICAgIGNvbnN0IHVwZGF0ZUZuID0gX2FwcGVhciA/IG9uT2JzZXJ2ZXJzVXBkYXRlZCA6IG9uT2JzZXJ2ZXJzVXBkYXRlZERlYm91bmNlZDtcclxuICAgIGNvbnN0IHVwZGF0ZUhpbnRzOiBPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzID0ge1xyXG4gICAgICBfc2l6ZUNoYW5nZWQ6IF9zaXplQ2hhbmdlZCB8fCBfYXBwZWFyLFxyXG4gICAgICBfYXBwZWFyLFxyXG4gICAgfTtcclxuXHJcbiAgICBzZXREaXJlY3Rpb24odXBkYXRlSGludHMpO1xyXG4gICAgdXBkYXRlRm4odXBkYXRlSGludHMsIGRlYm91bmNlUmVzaXplKTtcclxuICB9O1xyXG4gIGNvbnN0IG9uQ29udGVudE11dGF0aW9uID0gKFxyXG4gICAgY29udGVudENoYW5nZWRUaHJvdWdoRXZlbnQ6IGJvb2xlYW4sXHJcbiAgICBmcm9tUmVjb3Jkcz86IHRydWVcclxuICApOiBPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzID0+IHtcclxuICAgIGNvbnN0IFssIF9jb250ZW50TXV0YXRpb25dID0gdXBkYXRlQ29udGVudFNpemVDYWNoZSgpO1xyXG4gICAgY29uc3QgdXBkYXRlSGludHM6IE9ic2VydmVyc1NldHVwVXBkYXRlSGludHMgPSB7XHJcbiAgICAgIF9jb250ZW50TXV0YXRpb24sXHJcbiAgICB9O1xyXG5cclxuICAgIHNldERpcmVjdGlvbih1cGRhdGVIaW50cyk7XHJcblxyXG4gICAgaWYgKF9jb250ZW50TXV0YXRpb24gJiYgIWZyb21SZWNvcmRzKSB7XHJcbiAgICAgIG9uT2JzZXJ2ZXJzVXBkYXRlZERlYm91bmNlZChcclxuICAgICAgICB1cGRhdGVIaW50cyxcclxuICAgICAgICBjb250ZW50Q2hhbmdlZFRocm91Z2hFdmVudCA/IGRlYm91bmNlRXZlbnQgOiBkZWJvdW5jZU11dGF0aW9uXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVwZGF0ZUhpbnRzO1xyXG4gIH07XHJcbiAgY29uc3Qgb25Ib3N0TXV0YXRpb24gPSAoXHJcbiAgICB0YXJnZXRDaGFuZ2VkQXR0cnM6IHN0cmluZ1tdLFxyXG4gICAgdGFyZ2V0U3R5bGVDaGFuZ2VkOiBib29sZWFuLFxyXG4gICAgZnJvbVJlY29yZHM/OiB0cnVlXHJcbiAgKTogT2JzZXJ2ZXJzU2V0dXBVcGRhdGVIaW50cyA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVIaW50czogT2JzZXJ2ZXJzU2V0dXBVcGRhdGVIaW50cyA9IHtcclxuICAgICAgX2hvc3RNdXRhdGlvbjogdGFyZ2V0U3R5bGVDaGFuZ2VkLFxyXG4gICAgfTtcclxuXHJcbiAgICBzZXREaXJlY3Rpb24odXBkYXRlSGludHMpO1xyXG5cclxuICAgIGlmICh0YXJnZXRTdHlsZUNoYW5nZWQgJiYgIWZyb21SZWNvcmRzKSB7XHJcbiAgICAgIG9uT2JzZXJ2ZXJzVXBkYXRlZERlYm91bmNlZCh1cGRhdGVIaW50cywgZGVib3VuY2VNdXRhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgZWxzZSBpZiAoIV92aWV3cG9ydElzVGFyZ2V0KSB7XHJcbiAgICAgIHVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tSG9zdCh0YXJnZXRDaGFuZ2VkQXR0cnMpO1xyXG4gICAgfVxyXG4gICAgKi9cclxuXHJcbiAgICByZXR1cm4gdXBkYXRlSGludHM7XHJcbiAgfTtcclxuICBjb25zdCBbY29uc3RydWN0VHJpbnNpY09ic2VydmVyLCB1cGRhdGVUcmluc2ljT2JzZXJ2ZXJdID0gX2NvbnRlbnRcclxuICAgID8gY3JlYXRlVHJpbnNpY09ic2VydmVyKF9ob3N0LCBvblRyaW5zaWNDaGFuZ2VkKVxyXG4gICAgOiBbXTtcclxuICBjb25zdCBjb25zdHJ1Y3RTaXplT2JzZXJ2ZXIgPVxyXG4gICAgIV92aWV3cG9ydElzVGFyZ2V0ICYmXHJcbiAgICBjcmVhdGVTaXplT2JzZXJ2ZXIoX2hvc3QsIG9uU2l6ZUNoYW5nZWQsIHtcclxuICAgICAgX2FwcGVhcjogdHJ1ZSxcclxuICAgIH0pO1xyXG4gIGNvbnN0IFtjb25zdHJ1Y3RIb3N0TXV0YXRpb25PYnNlcnZlciwgdXBkYXRlSG9zdE11dGF0aW9uT2JzZXJ2ZXJdID0gY3JlYXRlRE9NT2JzZXJ2ZXIoXHJcbiAgICBfaG9zdCxcclxuICAgIGZhbHNlLFxyXG4gICAgb25Ib3N0TXV0YXRpb24sXHJcbiAgICB7XHJcbiAgICAgIF9zdHlsZUNoYW5naW5nQXR0cmlidXRlczogYmFzZVN0eWxlQ2hhbmdpbmdBdHRycyxcclxuICAgICAgX2F0dHJpYnV0ZXM6IGJhc2VTdHlsZUNoYW5naW5nQXR0cnMsXHJcbiAgICB9XHJcbiAgKTtcclxuICBjb25zdCB2aWV3cG9ydElzVGFyZ2V0UmVzaXplT2JzZXJ2ZXIgPVxyXG4gICAgX3ZpZXdwb3J0SXNUYXJnZXQgJiZcclxuICAgIFJlc2l6ZU9ic2VydmVyQ29uc3RydWN0b3IgJiZcclxuICAgIG5ldyBSZXNpemVPYnNlcnZlckNvbnN0cnVjdG9yKChlbnRyaWVzKSA9PiB7XHJcbiAgICAgIGNvbnN0IGN1cnJDb250ZW50UmVjdCA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5jb250ZW50UmVjdDtcclxuICAgICAgb25TaXplQ2hhbmdlZCh7XHJcbiAgICAgICAgX3NpemVDaGFuZ2VkOiB0cnVlLFxyXG4gICAgICAgIF9hcHBlYXI6IGRvbVJlY3RBcHBlYXJlZChjdXJyQ29udGVudFJlY3QsIHByZXZDb250ZW50UmVjdCksXHJcbiAgICAgIH0pO1xyXG4gICAgICBwcmV2Q29udGVudFJlY3QgPSBjdXJyQ29udGVudFJlY3Q7XHJcbiAgICB9KTtcclxuXHJcbiAgcmV0dXJuIFtcclxuICAgICgpID0+IHtcclxuICAgICAgLy8gb3JkZXIgaXMgbWF0dGVyIVxyXG4gICAgICAvLyB1cGRhdGVWaWV3cG9ydEF0dHJzRnJvbUhvc3QoKTtcclxuICAgICAgaWYgKHZpZXdwb3J0SXNUYXJnZXRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgIHZpZXdwb3J0SXNUYXJnZXRSZXNpemVPYnNlcnZlci5vYnNlcnZlKF9ob3N0KTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkZXN0cm95U2l6ZU9ic2VydmVyID0gY29uc3RydWN0U2l6ZU9ic2VydmVyICYmIGNvbnN0cnVjdFNpemVPYnNlcnZlcigpO1xyXG4gICAgICBjb25zdCBkZXN0cm95VHJpbnNpY09ic2VydmVyID0gY29uc3RydWN0VHJpbnNpY09ic2VydmVyICYmIGNvbnN0cnVjdFRyaW5zaWNPYnNlcnZlcigpO1xyXG4gICAgICBjb25zdCBkZXN0cm95SG9zdE11dGF0aW9uT2JzZXJ2ZXIgPSBjb25zdHJ1Y3RIb3N0TXV0YXRpb25PYnNlcnZlcigpO1xyXG4gICAgICBjb25zdCByZW1vdmVSZXNpemVMaXN0ZW5lciA9IGVudi5fYWRkUmVzaXplTGlzdGVuZXIoKF9zY3JvbGxiYXJTaXplQ2hhbmdlZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IFssIF9jb250ZW50TXV0YXRpb25dID0gdXBkYXRlQ29udGVudFNpemVDYWNoZSgpO1xyXG4gICAgICAgIG9uT2JzZXJ2ZXJzVXBkYXRlZERlYm91bmNlZChcclxuICAgICAgICAgIHsgX3Njcm9sbGJhclNpemVDaGFuZ2VkLCBfY29udGVudE11dGF0aW9uLCBfc2l6ZUNoYW5nZWQ6IF9pc0JvZHkgfSxcclxuICAgICAgICAgIGRlYm91bmNlRW52XHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGlmICh2aWV3cG9ydElzVGFyZ2V0UmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgIHZpZXdwb3J0SXNUYXJnZXRSZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXN0cm95U2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICBkZXN0cm95U2l6ZU9ic2VydmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXN0cm95VHJpbnNpY09ic2VydmVyKSB7XHJcbiAgICAgICAgICBkZXN0cm95VHJpbnNpY09ic2VydmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXN0cm95Q29udGVudE11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgIGRlc3Ryb3lDb250ZW50TXV0YXRpb25PYnNlcnZlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95SG9zdE11dGF0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICByZW1vdmVSZXNpemVMaXN0ZW5lcigpO1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgICh7IF9jaGVja09wdGlvbiwgX3Rha2VSZWNvcmRzLCBfZm9yY2UgfSkgPT4ge1xyXG4gICAgICBjb25zdCB1cGRhdGVIaW50czogT2JzZXJ2ZXJzU2V0dXBVcGRhdGVIaW50cyA9IHt9O1xyXG5cclxuICAgICAgY29uc3QgW2lnbm9yZU11dGF0aW9uXSA9IF9jaGVja09wdGlvbigndXBkYXRlLmlnbm9yZU11dGF0aW9uJyk7XHJcbiAgICAgIGNvbnN0IFthdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzQ2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ3VwZGF0ZS5hdHRyaWJ1dGVzJyk7XHJcbiAgICAgIGNvbnN0IFtlbGVtZW50RXZlbnRzLCBlbGVtZW50RXZlbnRzQ2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ3VwZGF0ZS5lbGVtZW50RXZlbnRzJyk7XHJcbiAgICAgIGNvbnN0IFtkZWJvdW5jZVZhbHVlLCBkZWJvdW5jZUNoYW5nZWRdID0gX2NoZWNrT3B0aW9uKCd1cGRhdGUuZGVib3VuY2UnKTtcclxuICAgICAgY29uc3QgY29udGVudE11dGF0aW9uT2JzZXJ2ZXJDaGFuZ2VkID0gZWxlbWVudEV2ZW50c0NoYW5nZWQgfHwgYXR0cmlidXRlc0NoYW5nZWQ7XHJcbiAgICAgIGNvbnN0IHRha2VSZWNvcmRzID0gX3Rha2VSZWNvcmRzIHx8IF9mb3JjZTtcclxuICAgICAgY29uc3QgaWdub3JlTXV0YXRpb25Gcm9tT3B0aW9ucyA9IChtdXRhdGlvbjogTXV0YXRpb25SZWNvcmQpID0+XHJcbiAgICAgICAgaXNGdW5jdGlvbihpZ25vcmVNdXRhdGlvbikgJiYgaWdub3JlTXV0YXRpb24obXV0YXRpb24pO1xyXG5cclxuICAgICAgaWYgKGNvbnRlbnRNdXRhdGlvbk9ic2VydmVyQ2hhbmdlZCkge1xyXG4gICAgICAgIGlmICh1cGRhdGVDb250ZW50TXV0YXRpb25PYnNlcnZlcikge1xyXG4gICAgICAgICAgdXBkYXRlQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc3Ryb3lDb250ZW50TXV0YXRpb25PYnNlcnZlcikge1xyXG4gICAgICAgICAgZGVzdHJveUNvbnRlbnRNdXRhdGlvbk9ic2VydmVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBbY29uc3RydWN0LCB1cGRhdGVdID0gY3JlYXRlRE9NT2JzZXJ2ZXIoXHJcbiAgICAgICAgICBfY29udGVudCB8fCBfdmlld3BvcnQsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgb25Db250ZW50TXV0YXRpb24sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiBjb25jYXQoYmFzZVN0eWxlQ2hhbmdpbmdBdHRycywgYXR0cmlidXRlcyB8fCBbXSksXHJcbiAgICAgICAgICAgIF9ldmVudENvbnRlbnRDaGFuZ2U6IGVsZW1lbnRFdmVudHMsXHJcbiAgICAgICAgICAgIF9uZXN0ZWRUYXJnZXRTZWxlY3RvcjogaG9zdFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBfaWdub3JlQ29udGVudENoYW5nZTogKG11dGF0aW9uLCBpc05lc3RlZFRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0OiBtdXRhdGlvblRhcmdldCwgYXR0cmlidXRlTmFtZSB9ID0gbXV0YXRpb247XHJcbiAgICAgICAgICAgICAgY29uc3QgaWdub3JlID1cclxuICAgICAgICAgICAgICAgICFpc05lc3RlZFRhcmdldCAmJiBhdHRyaWJ1dGVOYW1lICYmICFfdmlld3BvcnRJc1RhcmdldFxyXG4gICAgICAgICAgICAgICAgICA/IGxpZXNCZXR3ZWVuKG11dGF0aW9uVGFyZ2V0LCBob3N0U2VsZWN0b3IsIHZpZXdwb3J0U2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIGlnbm9yZSB8fFxyXG4gICAgICAgICAgICAgICAgISFjbG9zZXN0KG11dGF0aW9uVGFyZ2V0LCBgLiR7Y2xhc3NOYW1lU2Nyb2xsYmFyfWApIHx8IC8vIGlnbm9yZSBleHBsaWNpdGVseSBhbGwgc2Nyb2xsYmFyIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAhIWlnbm9yZU11dGF0aW9uRnJvbU9wdGlvbnMobXV0YXRpb24pXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBkZXN0cm95Q29udGVudE11dGF0aW9uT2JzZXJ2ZXIgPSBjb25zdHJ1Y3QoKTtcclxuICAgICAgICB1cGRhdGVDb250ZW50TXV0YXRpb25PYnNlcnZlciA9IHVwZGF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRlYm91bmNlQ2hhbmdlZCkge1xyXG4gICAgICAgIG9uT2JzZXJ2ZXJzVXBkYXRlZERlYm91bmNlZC5fZmx1c2goKTtcclxuICAgICAgICAvLyBwYXJzZSBhbmQgZGlzdHJpYnV0ZSB0aGUgZGVib3VuY2Ugb3B0aW9uXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZGVib3VuY2VWYWx1ZSkgfHwgaXNOdW1iZXIoZGVib3VuY2VWYWx1ZSkpIHtcclxuICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgYmVoYXZpb3I6IFZhbHVlIGFwcGxpZXMgdG8gbXV0YXRpb24uIHJlc2l6ZSBhbmQgZXZlbnQgYXJlIHVuZGVmaW5lZFxyXG4gICAgICAgICAgZGVib3VuY2VNdXRhdGlvbiA9IGRlYm91bmNlVmFsdWU7XHJcbiAgICAgICAgICBkZWJvdW5jZVJlc2l6ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgZGVib3VuY2VFdmVudCA9IGRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VFdmVudDtcclxuICAgICAgICAgIGRlYm91bmNlRW52ID0gZGVmYXVsdE9wdGlvbnNVcGRhdGVEZWJvdW5jZUVudjtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoZGVib3VuY2VWYWx1ZSkpIHtcclxuICAgICAgICAgIGRlYm91bmNlTXV0YXRpb24gPSBkZWJvdW5jZVZhbHVlLm11dGF0aW9uO1xyXG4gICAgICAgICAgZGVib3VuY2VSZXNpemUgPSBkZWJvdW5jZVZhbHVlLnJlc2l6ZTtcclxuICAgICAgICAgIGRlYm91bmNlRXZlbnQgPSBkZWJvdW5jZVZhbHVlLmV2ZW50O1xyXG4gICAgICAgICAgZGVib3VuY2VFbnYgPSBkZWJvdW5jZVZhbHVlLmVudjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGVib3VuY2VNdXRhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgZGVib3VuY2VSZXNpemUgPSBmYWxzZTtcclxuICAgICAgICAgIGRlYm91bmNlRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICAgIGRlYm91bmNlRW52ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGFrZVJlY29yZHMpIHtcclxuICAgICAgICBjb25zdCBob3N0VXBkYXRlUmVzdWx0ID0gdXBkYXRlSG9zdE11dGF0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICBjb25zdCB0cmluc2ljVXBkYXRlUmVzdWx0ID0gdXBkYXRlVHJpbnNpY09ic2VydmVyICYmIHVwZGF0ZVRyaW5zaWNPYnNlcnZlcigpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRVcGRhdGVSZXN1bHQgPVxyXG4gICAgICAgICAgdXBkYXRlQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIgJiYgdXBkYXRlQ29udGVudE11dGF0aW9uT2JzZXJ2ZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGhvc3RVcGRhdGVSZXN1bHQpIHtcclxuICAgICAgICAgIGFzc2lnbkRlZXAoXHJcbiAgICAgICAgICAgIHVwZGF0ZUhpbnRzLFxyXG4gICAgICAgICAgICBvbkhvc3RNdXRhdGlvbihob3N0VXBkYXRlUmVzdWx0WzBdLCBob3N0VXBkYXRlUmVzdWx0WzFdLCB0YWtlUmVjb3JkcylcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJpbnNpY1VwZGF0ZVJlc3VsdCkge1xyXG4gICAgICAgICAgYXNzaWduRGVlcCh1cGRhdGVIaW50cywgb25Ucmluc2ljQ2hhbmdlZCh0cmluc2ljVXBkYXRlUmVzdWx0WzBdLCB0YWtlUmVjb3JkcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbnRlbnRVcGRhdGVSZXN1bHQpIHtcclxuICAgICAgICAgIGFzc2lnbkRlZXAodXBkYXRlSGludHMsIG9uQ29udGVudE11dGF0aW9uKGNvbnRlbnRVcGRhdGVSZXN1bHRbMF0sIHRha2VSZWNvcmRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXREaXJlY3Rpb24odXBkYXRlSGludHMpO1xyXG5cclxuICAgICAgcmV0dXJuIHVwZGF0ZUhpbnRzO1xyXG4gICAgfSxcclxuICAgIHN0YXRlLFxyXG4gIF07XHJcbn07XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuaW1wb3J0IHR5cGUgeyBEZWVwUGFydGlhbCB9IGZyb20gJy4vdHlwaW5ncyc7XHJcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzSFRNTEVsZW1lbnQsIGlzTnVsbCwgaXNVbmRlZmluZWQgfSBmcm9tICcuL3N1cHBvcnQnO1xyXG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudCB9IGZyb20gJy4vZW52aXJvbm1lbnQnO1xyXG5cclxudHlwZSBGYWxsYmFja1N0YXRpY0luaXRpYWxpenRhdGlvbkVsZW1lbnQ8QXJncyBleHRlbmRzIGFueVtdPiA9XHJcbiAgRXh0cmFjdDxTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnQ8QXJncz4sICguLi5hcmdzOiBBcmdzKSA9PiBhbnk+IGV4dGVuZHMgKFxyXG4gICAgLi4uYXJnczogaW5mZXIgUFxyXG4gICkgPT4gYW55XHJcbiAgICA/ICguLi5hcmdzOiBQKSA9PiBIVE1MRWxlbWVudFxyXG4gICAgOiBuZXZlcjtcclxudHlwZSBGYWxsYmFja0R5bmFtaWNJbml0aWFsaXp0YXRpb25FbGVtZW50PEFyZ3MgZXh0ZW5kcyBhbnlbXT4gPVxyXG4gIEV4dHJhY3Q8RHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudDxBcmdzPiwgKC4uLmFyZ3M6IEFyZ3MpID0+IGFueT4gZXh0ZW5kcyAoXHJcbiAgICAuLi5hcmdzOiBpbmZlciBQXHJcbiAgKSA9PiBhbnlcclxuICAgID8gKC4uLmFyZ3M6IFApID0+IEhUTUxFbGVtZW50XHJcbiAgICA6IG5ldmVyO1xyXG5cclxuZXhwb3J0IHR5cGUgU3RhdGljSW5pdGlhbGl6YXRpb24gPSBIVE1MRWxlbWVudCB8IGZhbHNlIHwgbnVsbDtcclxuZXhwb3J0IHR5cGUgRHluYW1pY0luaXRpYWxpemF0aW9uID0gSFRNTEVsZW1lbnQgfCBib29sZWFuIHwgbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBTdGF0aWMgZWxlbWVudHMgYXJlIGVsZW1lbnRzIHdoaWNoIE1VU1QgYmUgcHJlc2VudCBpbiB0aGUgZmluYWwgRE9NLlxyXG4gKiBJZiBhbiBgSFRNTEVsZW1lbnRgIGlzIHBhc3NlZCB0aGUgcGFzc2VkIGVsZW1lbnQgd2lsbCBiZSB0YWtlbiBhcyB0aGUgcmVwc2VjdGl2ZSBlbGVtZW50LlxyXG4gKiBXaXRoIGBmYWxzZWAsIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhbiBhcHByb3ByaWF0ZSBlbGVtZW50IGlzIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5LlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50PEFyZ3MgZXh0ZW5kcyBhbnlbXT4gPVxyXG4gIC8qKiBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHRoZSBTdGF0aWNJbml0aWFsaXphdGlvbiB2YWx1ZS4gKi9cclxuICB8ICgoLi4uYXJnczogQXJncykgPT4gU3RhdGljSW5pdGlhbGl6YXRpb24pXHJcbiAgLyoqIFRoZSBTdGF0aWNJbml0aWFsaXphdGlvbiB2YWx1ZS4gKi9cclxuICB8IFN0YXRpY0luaXRpYWxpemF0aW9uO1xyXG5cclxuLyoqXHJcbiAqIER5bmFtaWMgZWxlbWVudHMgYXJlIGVsZW1lbnRzIHdoaWNoIENBTiBiZSBwcmVzZW50IGluIHRoZSBmaW5hbCBET00uXHJcbiAqIElmIGFuIGBIVE1MRWxlbWVudGBpcyBwYXNzZWQgdGhlIHBhc3NlZCBlbGVtZW50IHdpbGwgYmUgdGFrZW4gYXMgdGhlIHJlcHNlY3RpdmUgZWxlbWVudC5cclxuICogV2l0aCBgdHJ1ZWAgYW4gYXBwcm9wcmlhdGUgZWxlbWVudCBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cclxuICogV2l0aCBgZmFsc2VgLCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdGhlIGVsZW1lbnQgd29uJ3QgYmUgaW4gdGhlIERPTS5cclxuICovXHJcbmV4cG9ydCB0eXBlIER5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnQ8QXJncyBleHRlbmRzIGFueVtdPiA9XHJcbiAgLyoqIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgdGhlIER5bmFtaWNJbml0aWFsaXphdGlvbiB2YWx1ZS4gKi9cclxuICB8ICgoLi4uYXJnczogQXJncykgPT4gRHluYW1pY0luaXRpYWxpemF0aW9uKVxyXG4gIC8qKiBUaGUgRHluYW1pY0luaXRpYWxpemF0aW9uIHZhbHVlLiAqL1xyXG4gIHwgRHluYW1pY0luaXRpYWxpemF0aW9uO1xyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyBob3cgYSBPdmVybGF5U2Nyb2xsYmFyIGluc3RhbmNlIHNob3VsZCBpbml0aWFsaXplLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgSW5pdGlhbGl6YXRpb24gPSB7XHJcbiAgLyoqXHJcbiAgICogQ3VzdG9taXplcyB3aGljaCBlbGVtZW50cyBhcmUgZ2VuZXJhdGVkIGFuZCB1c2VkLlxyXG4gICAqIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIGFueSBvZiB0aGUgZmllbGRzLCBpdCByZWNlaXZlcyB0aGUgYHRhcmdldGAgZWxlbWVudCBhcyBpdHMgYXJndW1lbnQuXHJcbiAgICogQW55IHBhc3NlZCBmdW5jdGlvbiBzaG91bGQgYmUgYSBcInB1cmVcIiBmdW5jdGlvbi4gKHNhbWUgaW5wdXQgcHJvZHVjZXMgc2FtZSBvdXRwdXQpXHJcbiAgICovXHJcbiAgZWxlbWVudHM6IHtcclxuICAgIC8qKlxyXG4gICAgICogQXNzaWduIGEgY3VzdG9tIGVsZW1lbnQgYXMgdGhlIGhvc3QgZWxlbWVudC5cclxuICAgICAqIE9ubHkgcmVsZXZhbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgVGV4dGFyZWEuXHJcbiAgICAgKi9cclxuICAgIGhvc3Q6IFN0YXRpY0luaXRpYWxpemF0aW9uRWxlbWVudDxbdGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldEVsZW1lbnRdPjtcclxuICAgIC8qKiBBc3NpZ24gYSBjdXN0b20gZWxlbWVudCBhcyB0aGUgdmlld3BvcnQgZWxlbWVudC4gKi9cclxuICAgIHZpZXdwb3J0OiBTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnQ8W3RhcmdldDogSW5pdGlhbGl6YXRpb25UYXJnZXRFbGVtZW50XT47XHJcbiAgICAvKiogQXNzaWduIGEgY3VzdG9tIGVsZW1lbnQgYXMgdGhlIHBhZGRpbmcgZWxlbWVudCBvciBmb3JjZSB0aGUgZWxlbWVudCBub3QgdG8gYmUgZ2VuZXJhdGVkLiAqL1xyXG4gICAgcGFkZGluZzogRHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudDxbdGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldEVsZW1lbnRdPjtcclxuICAgIC8qKiBBc3NpZ24gYSBjdXN0b20gZWxlbWVudCBhcyB0aGUgY29udGVudCBlbGVtZW50IG9yIGZvcmNlIHRoZSBlbGVtZW50IG5vdCB0byBiZSBnZW5lcmF0ZWQuICovXHJcbiAgICBjb250ZW50OiBEeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50PFt0YXJnZXQ6IEluaXRpYWxpemF0aW9uVGFyZ2V0RWxlbWVudF0+O1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ3VzdG9taXplcyBlbGVtZW50cyByZWxhdGVkIHRvIHRoZSBzY3JvbGxiYXJzLlxyXG4gICAqIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCByZWNlaXZlcyB0aGUgYHRhcmdldGAsIGBob3N0YCBhbmQgYHZpZXdwb3J0YCBlbGVtZW50IGFzIGFyZ3VtZW50cy5cclxuICAgKi9cclxuICBzY3JvbGxiYXJzOiB7XHJcbiAgICBzbG90OiBEeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50PFxyXG4gICAgICBbdGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldEVsZW1lbnQsIGhvc3Q6IEhUTUxFbGVtZW50LCB2aWV3cG9ydDogSFRNTEVsZW1lbnRdXHJcbiAgICA+O1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ3VzdG9taXplcyB0aGUgY2FuY2VsYXRpb24gYmVoYXZpb3IuXHJcbiAgICovXHJcbiAgY2FuY2VsOiB7XHJcbiAgICAvKiogV2hldGhlciB0aGUgaW5pdGlhbGl6YXRpb24gc2hhbGwgYmUgY2FuY2VsZWQgaWYgdGhlIG5hdGl2ZSBzY3JvbGxiYXJzIGFyZSBvdmVybGFpZC4gKi9cclxuICAgIG5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZDogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgaW5pdGlhbGl6YXRpb24gc2hhbGwgYmUgY2FuY2VsZWQgaWYgaXRzIGFwcGxpZWQgdG8gYSBib2R5IGVsZW1lbnQuXHJcbiAgICAgKiBXaXRoIGB0cnVlYCBhbiBpbml0aWFsaXphdGlvbiBpcyBhbHdheXMgY2FuY2VsZWQsIHdpdGggYGZhbHNlYCBpdHMgbmV2ZXIgY2FuY2VsZWQuXHJcbiAgICAgKiBXaXRoIGBudWxsYCB0aGUgaW5pdGlhbGl6YXRpb24gd2lsbCBvbmx5IGJlIGNhbmNlbGVkIHdoZW4gdGhlIGluaXRpYWxpemF0aW9uIHdvdWxkIGFmZmVjdCB0aGUgYnJvd3NlcnMgZnVuY3Rpb25hbGl0eS4gKHdpbmRvdy5zY3JvbGxUbywgbW9iaWxlIGJyb3dzZXIgYmVoYXZpb3IgZXRjLilcclxuICAgICAqL1xyXG4gICAgYm9keTogYm9vbGVhbiB8IG51bGw7XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFBhcnRpYWxJbml0aWFsaXphdGlvbiA9IERlZXBQYXJ0aWFsPEluaXRpYWxpemF0aW9uPjtcclxuXHJcbi8qKiBUaGUgaW5pdGlhbGl6YXRpb24gdGFyZ2V0IGVsZW1lbnQuICovXHJcbmV4cG9ydCB0eXBlIEluaXRpYWxpemF0aW9uVGFyZ2V0RWxlbWVudCA9IEhUTUxFbGVtZW50OyAvLyB8IEhUTUxUZXh0QXJlYUVsZW1lbnQ7XHJcblxyXG4vKipcclxuICogVGhlIGluaXRpYWxpemF0aW9uIHRhcmdldCBvYmplY3QuXHJcbiAqIE92ZXJsYXlTY3JvbGxiYXJzKHsgdGFyZ2V0OiBteUVsZW1lbnQgfSkgaXMgZXF1aXZhbGVudCB0byBPdmVybGF5U2Nyb2xsYmFycyhteUVsZW1lbnQpLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgSW5pdGlhbGl6YXRpb25UYXJnZXRPYmplY3QgPSBQYXJ0aWFsSW5pdGlhbGl6YXRpb24gJiB7XHJcbiAgdGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldEVsZW1lbnQ7XHJcbn07XHJcblxyXG4vKiogVGhlIGluaXRpYWxpemF0aW9uIHRhcmdldC4gKi9cclxuZXhwb3J0IHR5cGUgSW5pdGlhbGl6YXRpb25UYXJnZXQgPSBJbml0aWFsaXphdGlvblRhcmdldEVsZW1lbnQgfCBJbml0aWFsaXphdGlvblRhcmdldE9iamVjdDtcclxuXHJcbmV4cG9ydCBjb25zdCByZXNvbHZlSW5pdGlhbGl6YXRpb24gPSA8VCBleHRlbmRzIFN0YXRpY0luaXRpYWxpemF0aW9uIHwgRHluYW1pY0luaXRpYWxpemF0aW9uPihcclxuICBhcmdzOiBhbnksXHJcbiAgdmFsdWU6IGFueVxyXG4pOiBUID0+IChpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmFwcGx5KDAsIGFyZ3MpIDogdmFsdWUpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0YXRpY0luaXRpYWxpemF0aW9uRWxlbWVudCA9IDxBcmdzIGV4dGVuZHMgYW55W10+KFxyXG4gIGFyZ3M6IEFyZ3MsXHJcbiAgZmFsbGJhY2tTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnQ6IEZhbGxiYWNrU3RhdGljSW5pdGlhbGl6dGF0aW9uRWxlbWVudDxBcmdzPixcclxuICBkZWZhdWx0U3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50OiBTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnQ8QXJncz4sXHJcbiAgc3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50VmFsdWU/OiBTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnQ8QXJncz5cclxuKTogSFRNTEVsZW1lbnQgPT4ge1xyXG4gIGNvbnN0IHN0YXRpY0luaXRpYWxpemF0aW9uID0gaXNVbmRlZmluZWQoc3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50VmFsdWUpXHJcbiAgICA/IGRlZmF1bHRTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnRcclxuICAgIDogc3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50VmFsdWU7XHJcbiAgY29uc3QgcmVzb2x2ZWRJbml0aWFsaXphdGlvbiA9IHJlc29sdmVJbml0aWFsaXphdGlvbjxTdGF0aWNJbml0aWFsaXphdGlvbj4oXHJcbiAgICBhcmdzLFxyXG4gICAgc3RhdGljSW5pdGlhbGl6YXRpb25cclxuICApO1xyXG4gIHJldHVybiByZXNvbHZlZEluaXRpYWxpemF0aW9uIHx8IGZhbGxiYWNrU3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50LmFwcGx5KDAsIGFyZ3MpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGR5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnQgPSA8QXJncyBleHRlbmRzIGFueVtdPihcclxuICBhcmdzOiBBcmdzLFxyXG4gIGZhbGxiYWNrRHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudDogRmFsbGJhY2tEeW5hbWljSW5pdGlhbGl6dGF0aW9uRWxlbWVudDxBcmdzPixcclxuICBkZWZhdWx0RHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudDogRHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudDxBcmdzPixcclxuICBkeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50VmFsdWU/OiBEeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50PEFyZ3M+XHJcbik6IEhUTUxFbGVtZW50IHwgZmFsc2UgPT4ge1xyXG4gIGNvbnN0IGR5bmFtaWNJbml0aWFsaXphdGlvbiA9IGlzVW5kZWZpbmVkKGR5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnRWYWx1ZSlcclxuICAgID8gZGVmYXVsdER5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnRcclxuICAgIDogZHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudFZhbHVlO1xyXG4gIGNvbnN0IHJlc29sdmVkSW5pdGlhbGl6YXRpb24gPSByZXNvbHZlSW5pdGlhbGl6YXRpb248RHluYW1pY0luaXRpYWxpemF0aW9uPihcclxuICAgIGFyZ3MsXHJcbiAgICBkeW5hbWljSW5pdGlhbGl6YXRpb25cclxuICApO1xyXG4gIHJldHVybiAoXHJcbiAgICAhIXJlc29sdmVkSW5pdGlhbGl6YXRpb24gJiZcclxuICAgIChpc0hUTUxFbGVtZW50KHJlc29sdmVkSW5pdGlhbGl6YXRpb24pXHJcbiAgICAgID8gcmVzb2x2ZWRJbml0aWFsaXphdGlvblxyXG4gICAgICA6IGZhbGxiYWNrRHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudC5hcHBseSgwLCBhcmdzKSlcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNhbmNlbEluaXRpYWxpemF0aW9uID0gKFxyXG4gIGlzQm9keTogYm9vbGVhbixcclxuICBjYW5jZWxJbml0aWFsaXphdGlvblZhbHVlPzogRGVlcFBhcnRpYWw8SW5pdGlhbGl6YXRpb25bJ2NhbmNlbCddPiB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4pOiBib29sZWFuID0+IHtcclxuICBjb25zdCB7IG5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCwgYm9keSB9ID0gY2FuY2VsSW5pdGlhbGl6YXRpb25WYWx1ZSB8fCB7fTtcclxuICBjb25zdCB7IF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQsIF9uYXRpdmVTY3JvbGxiYXJzSGlkaW5nLCBfZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uIH0gPVxyXG4gICAgZ2V0RW52aXJvbm1lbnQoKTtcclxuICBjb25zdCB7IG5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZDogZGVmYXVsdE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCwgYm9keTogZGVmYXVsdGJvZHkgfSA9XHJcbiAgICBfZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uKCkuY2FuY2VsO1xyXG5cclxuICBjb25zdCByZXNvbHZlZE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCA9XHJcbiAgICBuYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQgPz8gZGVmYXVsdE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZDtcclxuICBjb25zdCByZXNvbHZlZERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCA9IGlzVW5kZWZpbmVkKGJvZHkpID8gZGVmYXVsdGJvZHkgOiBib2R5O1xyXG5cclxuICBjb25zdCBmaW5hbE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCA9XHJcbiAgICAoX25hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC54IHx8IF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQueSkgJiZcclxuICAgIHJlc29sdmVkTmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkO1xyXG4gIGNvbnN0IGZpbmFsRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50ID1cclxuICAgIGlzQm9keSAmJlxyXG4gICAgKGlzTnVsbChyZXNvbHZlZERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudClcclxuICAgICAgPyAhX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmdcclxuICAgICAgOiByZXNvbHZlZERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCk7XHJcblxyXG4gIHJldHVybiAhIWZpbmFsTmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkIHx8ICEhZmluYWxEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQ7XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgWFkgfSBmcm9tICcuLi8uLi9zdXBwb3J0JztcclxuaW1wb3J0IHR5cGUge1xyXG4gIEluaXRpYWxpemF0aW9uVGFyZ2V0LFxyXG4gIEluaXRpYWxpemF0aW9uVGFyZ2V0RWxlbWVudCxcclxuICBJbml0aWFsaXphdGlvblRhcmdldE9iamVjdCxcclxufSBmcm9tICcuLi8uLi9pbml0aWFsaXphdGlvbic7XHJcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlU2V0dXBFbGVtZW50c09iaiB9IGZyb20gJy4uL3N0cnVjdHVyZVNldHVwL3N0cnVjdHVyZVNldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHR5cGUgeyBTY3JvbGxiYXJzU2V0dXBFdmVudHMgfSBmcm9tICcuL3Njcm9sbGJhcnNTZXR1cC5ldmVudHMnO1xyXG5pbXBvcnQgdHlwZSB7IFN0eWxlT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XHJcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlU2V0dXBTdGF0ZSB9IGZyb20gJy4uL3N0cnVjdHVyZVNldHVwJztcclxuaW1wb3J0IHsgZHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudCBhcyBnZW5lcmFsRHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudCB9IGZyb20gJy4uLy4uL2luaXRpYWxpemF0aW9uJztcclxuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnQgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XHJcbmltcG9ydCB7XHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFyLFxyXG4gIGNsYXNzTmFtZVNjcm9sbGJhckhvcml6b250YWwsXHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFyVmVydGljYWwsXHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2ssXHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlLFxyXG59IGZyb20gJy4uLy4uL2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQge1xyXG4gIGFkZENsYXNzLFxyXG4gIGFwcGVuZENoaWxkcmVuLFxyXG4gIGNyZWF0ZURpdixcclxuICBlYWNoLFxyXG4gIGdldFRyYXNmb3JtVHJhbnNsYXRlVmFsdWUsXHJcbiAgaXNCb29sZWFuLFxyXG4gIHBhcmVudCxcclxuICBwdXNoLFxyXG4gIHJlbW92ZUNsYXNzLFxyXG4gIHJlbW92ZUVsZW1lbnRzLFxyXG4gIHJ1bkVhY2hBbmRDbGVhcixcclxuICBzY3JvbGxULFxyXG4gIGJpbmQsXHJcbiAgZ2V0RWxlbWVudFNjcm9sbCxcclxuICBudW1iZXJUb0Nzc1B4LFxyXG4gIHNldFN0eWxlcyxcclxuICBjYXBOdW1iZXIsXHJcbiAgZ2V0U2Nyb2xsQ29vcmRpbmF0ZXNQZXJjZW50LFxyXG4gIGlzRGVmYXVsdERpcmVjdGlvblNjcm9sbENvb3JkaW5hdGVzLFxyXG4gIHJvdW5kQ3NzTnVtYmVyLFxyXG59IGZyb20gJy4uLy4uL3N1cHBvcnQnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxiYXJTdHJ1Y3R1cmUge1xyXG4gIF9zY3JvbGxiYXI6IEhUTUxFbGVtZW50O1xyXG4gIF90cmFjazogSFRNTEVsZW1lbnQ7XHJcbiAgX2hhbmRsZTogSFRNTEVsZW1lbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsYmFyc1NldHVwRWxlbWVudCB7XHJcbiAgX3Njcm9sbGJhclN0cnVjdHVyZXM6IFNjcm9sbGJhclN0cnVjdHVyZVtdO1xyXG4gIF9jbG9uZTogKCkgPT4gU2Nyb2xsYmFyU3RydWN0dXJlO1xyXG4gIF9zdHlsZTogKFxyXG4gICAgZWxtU3R5bGU6IChcclxuICAgICAgc2Nyb2xsYmFyU3RydWN0dXJlOiBTY3JvbGxiYXJTdHJ1Y3R1cmVcclxuICAgICkgPT4gW0hUTUxFbGVtZW50IHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkLCBTdHlsZU9iamVjdF1cclxuICApID0+IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsYmFyc1NldHVwRWxlbWVudHNPYmoge1xyXG4gIF9zY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3M6IChcclxuICAgIGNsYXNzTmFtZXM6IHN0cmluZyB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgIGFkZD86IGJvb2xlYW4sXHJcbiAgICBpc0hvcml6b250YWw/OiBib29sZWFuXHJcbiAgKSA9PiB2b2lkO1xyXG4gIF9yZWZyZXNoU2Nyb2xsYmFyc0hhbmRsZUxlbmd0aDogKCkgPT4gdm9pZDtcclxuICBfcmVmcmVzaFNjcm9sbGJhcnNIYW5kbGVPZmZzZXQ6ICgpID0+IHZvaWQ7XHJcbiAgX3JlZnJlc2hTY3JvbGxiYXJzU2Nyb2xsYmFyT2Zmc2V0OiAoKSA9PiB2b2lkO1xyXG4gIF9yZWZyZXNoU2Nyb2xsYmFyc1Njcm9sbENvb3JkaW5hdGVzOiAoKSA9PiB2b2lkO1xyXG4gIF9ob3Jpem9udGFsOiBTY3JvbGxiYXJzU2V0dXBFbGVtZW50O1xyXG4gIF92ZXJ0aWNhbDogU2Nyb2xsYmFyc1NldHVwRWxlbWVudDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU2Nyb2xsYmFyc1NldHVwRWxlbWVudHMgPSBbXHJcbiAgZWxlbWVudHM6IFNjcm9sbGJhcnNTZXR1cEVsZW1lbnRzT2JqLFxyXG4gIGFwcGVuZEVsZW1lbnRzOiAoKSA9PiAoKSA9PiB2b2lkLFxyXG5dO1xyXG5cclxudHlwZSBTY3JvbGxiYXJTdHlsZUZuID0gKFxyXG4gIHNjcm9sbGJhclN0cnVjdHVyZTogU2Nyb2xsYmFyU3RydWN0dXJlXHJcbikgPT4gW0hUTUxFbGVtZW50IHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkLCBTdHlsZU9iamVjdCB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZF07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlU2Nyb2xsYmFyc1NldHVwRWxlbWVudHMgPSAoXHJcbiAgdGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldCxcclxuICBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzOiBTdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzT2JqLFxyXG4gIHN0cnVjdHVyZVNldHVwU3RhdGU6IFN0cnVjdHVyZVNldHVwU3RhdGUsXHJcbiAgc2Nyb2xsYmFyc1NldHVwRXZlbnRzOiBTY3JvbGxiYXJzU2V0dXBFdmVudHNcclxuKTogU2Nyb2xsYmFyc1NldHVwRWxlbWVudHMgPT4ge1xyXG4gIGNvbnN0IGNzc0N1c3RvbVByb3BWaWV3cG9ydFBlcmNlbnQgPSAnLS1vcy12aWV3cG9ydC1wZXJjZW50JztcclxuICBjb25zdCBjc3NDdXN0b21Qcm9wU2Nyb2xsUGVyY2VudCA9ICctLW9zLXNjcm9sbC1wZXJjZW50JztcclxuICBjb25zdCBjc3NDdXN0b21Qcm9wU2Nyb2xsRGlyZWN0aW9uID0gJy0tb3Mtc2Nyb2xsLWRpcmVjdGlvbic7XHJcbiAgY29uc3QgeyBfZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uIH0gPSBnZXRFbnZpcm9ubWVudCgpO1xyXG4gIGNvbnN0IHsgc2Nyb2xsYmFyczogZGVmYXVsdEluaXRTY3JvbGxiYXJzIH0gPSBfZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uKCk7XHJcbiAgY29uc3QgeyBzbG90OiBkZWZhdWx0SW5pdFNjcm9sbGJhcnNTbG90IH0gPSBkZWZhdWx0SW5pdFNjcm9sbGJhcnM7XHJcbiAgY29uc3Qge1xyXG4gICAgX3RhcmdldCxcclxuICAgIF9ob3N0LFxyXG4gICAgX3ZpZXdwb3J0LFxyXG4gICAgX3RhcmdldElzRWxtLFxyXG4gICAgX3Njcm9sbE9mZnNldEVsZW1lbnQsXHJcbiAgICBfaXNCb2R5LFxyXG4gICAgX3ZpZXdwb3J0SXNUYXJnZXQsXHJcbiAgfSA9IHN0cnVjdHVyZVNldHVwRWxlbWVudHM7XHJcbiAgY29uc3QgeyBzY3JvbGxiYXJzOiBzY3JvbGxiYXJzSW5pdCB9ID0gKF90YXJnZXRJc0VsbSA/IHt9IDogdGFyZ2V0KSBhcyBJbml0aWFsaXphdGlvblRhcmdldE9iamVjdDtcclxuICBjb25zdCB7IHNsb3Q6IGluaXRTY3JvbGxiYXJzU2xvdCB9ID0gc2Nyb2xsYmFyc0luaXQgfHwge307XHJcbiAgY29uc3QgZGVzdHJveUZuczogKCgpID0+IHZvaWQpW10gPSBbXTtcclxuICBjb25zdCBob3Jpem9udGFsU2Nyb2xsYmFyczogU2Nyb2xsYmFyU3RydWN0dXJlW10gPSBbXTtcclxuICBjb25zdCB2ZXJ0aWNhbFNjcm9sbGJhcnM6IFNjcm9sbGJhclN0cnVjdHVyZVtdID0gW107XHJcbiAgY29uc3QgZXZhbHVhdGVkU2Nyb2xsYmFyU2xvdCA9IGdlbmVyYWxEeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50PFxyXG4gICAgW0luaXRpYWxpemF0aW9uVGFyZ2V0RWxlbWVudCwgSFRNTEVsZW1lbnQsIEhUTUxFbGVtZW50XVxyXG4gID4oXHJcbiAgICBbX3RhcmdldCwgX2hvc3QsIF92aWV3cG9ydF0sXHJcbiAgICAoKSA9PiAoX3ZpZXdwb3J0SXNUYXJnZXQgJiYgX2lzQm9keSA/IF90YXJnZXQgOiBfaG9zdCksXHJcbiAgICBkZWZhdWx0SW5pdFNjcm9sbGJhcnNTbG90LFxyXG4gICAgaW5pdFNjcm9sbGJhcnNTbG90XHJcbiAgKTtcclxuXHJcbiAgY29uc3QgaW5pdFNjcm9sbFRpbWVsaW5lID0gKGF4aXM6IGtleW9mIFhZPHVua25vd24+KSA9PiB7XHJcbiAgICBpZiAoc2Nyb2xsVCkge1xyXG4gICAgICBsZXQgY3VyckFuaW1hdGlvbjogQW5pbWF0aW9uIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgIGxldCBjdXJyQW5pbWF0aW9uVHJhbnNmb3JtOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICBjb25zdCB0aW1lbGluZSA9IG5ldyBzY3JvbGxUKHtcclxuICAgICAgICBzb3VyY2U6IF9zY3JvbGxPZmZzZXRFbGVtZW50LFxyXG4gICAgICAgIGF4aXMsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBjYW5jZWxBbmltYXRpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGN1cnJBbmltYXRpb24pIHtcclxuICAgICAgICAgIGN1cnJBbmltYXRpb24uY2FuY2VsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJBbmltYXRpb24gPSBudWxsO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBfc2V0U2Nyb2xsUGVyY2VudEFuaW1hdGlvbiA9IChzdHJ1Y3R1cmU6IFNjcm9sbGJhclN0cnVjdHVyZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgX3Njcm9sbENvb3JkaW5hdGVzIH0gPSBzdHJ1Y3R1cmVTZXR1cFN0YXRlO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHREaXJlY3Rpb25TY3JvbGwgPVxyXG4gICAgICAgICAgaXNEZWZhdWx0RGlyZWN0aW9uU2Nyb2xsQ29vcmRpbmF0ZXMoX3Njcm9sbENvb3JkaW5hdGVzKVtheGlzXTtcclxuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtQXJyYXkgPSBbXHJcbiAgICAgICAgICBnZXRUcmFzZm9ybVRyYW5zbGF0ZVZhbHVlKDAsIGlzSG9yaXpvbnRhbCksXHJcbiAgICAgICAgICBnZXRUcmFzZm9ybVRyYW5zbGF0ZVZhbHVlKGBjYWxjKC0xMDAlICsgMTAwY3Eke2lzSG9yaXpvbnRhbCA/ICd3JyA6ICdoJ30pYCwgaXNIb3Jpem9udGFsKSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGRlZmF1bHREaXJlY3Rpb25TY3JvbGwgPyB0cmFuc2Zvcm1BcnJheSA6IHRyYW5zZm9ybUFycmF5LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBrZXlmcmFtZXMgYXJlIGlkZW50aWNhbCwgZG8gbm90aGluZyBhbmQga2VlcCBjdXJyZW50IGFuaW1hdGlvblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGN1cnJBbmltYXRpb25UcmFuc2Zvcm1bMF0gPT09IHRyYW5zZm9ybVswXSAmJlxyXG4gICAgICAgICAgY3VyckFuaW1hdGlvblRyYW5zZm9ybVsxXSA9PT0gdHJhbnNmb3JtWzFdXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FuY2VsQW5pbWF0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VyckFuaW1hdGlvblRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuXHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgY3VyckFuaW1hdGlvbiA9IHN0cnVjdHVyZS5faGFuZGxlLmFuaW1hdGUoXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGR1bW15IGtleWZyYW1lIHdoaWNoIGZpeGVzIGJ1ZyB3aGVyZSB0aGUgc2Nyb2xsYmFyIGhhbmRsZSBpcyByZXZlcnRlZCB0byBvcmlnaW4gcG9zaXRpb24gd2hlbiBpdCBzaG91bGQgYmUgYXQgaXRzIG1heCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjbGVhcjogWydsZWZ0J10sXHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBpcyBhIHRlbXBvcmFyeSBmaXggZm9yOiBodHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmEvT3ZlcmxheVNjcm9sbGJhcnMvaXNzdWVzLzcwNVxyXG4gICAgICAgICAgICAvLyBjYW4gYmUgcmV2ZXJ0ZWQgdG8ganVzdCBhbmltYXRlIFwiY3NzQ3VzdG9tUHJvcFNjcm9sbFBlcmNlbnRcIiB3aGVuIGJyb3dzZXJzIGltcGxlbWVudCBhbiBvcHRpbWl6YXRpb24gcG9zc2liaWxpdHlcclxuICAgICAgICAgICAgdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAvLyBbY3NzQ3VzdG9tUHJvcFNjcm9sbFBlcmNlbnRdOiBbMCwgMV0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0aW1lbGluZSxcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FuY2VsQW5pbWF0aW9uO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBfc2V0U2Nyb2xsUGVyY2VudEFuaW1hdGlvbixcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHNjcm9sbFRpbWVsaW5lID0ge1xyXG4gICAgeDogaW5pdFNjcm9sbFRpbWVsaW5lKCd4JyksXHJcbiAgICB5OiBpbml0U2Nyb2xsVGltZWxpbmUoJ3knKSxcclxuICB9O1xyXG4gIGNvbnN0IGdldFZpZXdwb3J0UGVyY2VudCA9ICgpID0+IHtcclxuICAgIGNvbnN0IHsgX292ZXJmbG93QW1vdW50LCBfb3ZlcmZsb3dFZGdlIH0gPSBzdHJ1Y3R1cmVTZXR1cFN0YXRlO1xyXG4gICAgY29uc3QgZ2V0QXhpc1ZhbHVlID0gKGF4aXNWaWV3cG9ydFNpemU6IG51bWJlciwgYXhpc092ZXJmbG93QW1vdW50OiBudW1iZXIpID0+XHJcbiAgICAgIGNhcE51bWJlcigwLCAxLCBheGlzVmlld3BvcnRTaXplIC8gKGF4aXNWaWV3cG9ydFNpemUgKyBheGlzT3ZlcmZsb3dBbW91bnQpIHx8IDApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGdldEF4aXNWYWx1ZShfb3ZlcmZsb3dFZGdlLngsIF9vdmVyZmxvd0Ftb3VudC54KSxcclxuICAgICAgeTogZ2V0QXhpc1ZhbHVlKF9vdmVyZmxvd0VkZ2UueSwgX292ZXJmbG93QW1vdW50LnkpLFxyXG4gICAgfTtcclxuICB9O1xyXG4gIGNvbnN0IHNjcm9sbGJhclN0cnVjdHVyZUFkZFJlbW92ZUNsYXNzID0gKFxyXG4gICAgc2Nyb2xsYmFyU3RydWN0dXJlczogU2Nyb2xsYmFyU3RydWN0dXJlW10sXHJcbiAgICBjbGFzc05hbWVzOiBzdHJpbmcgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWQsXHJcbiAgICBhZGQ/OiBib29sZWFuXHJcbiAgKSA9PiB7XHJcbiAgICBjb25zdCBhY3Rpb24gPSBhZGQgPyBhZGRDbGFzcyA6IHJlbW92ZUNsYXNzO1xyXG4gICAgZWFjaChzY3JvbGxiYXJTdHJ1Y3R1cmVzLCAoc2Nyb2xsYmFyU3RydWN0dXJlKSA9PiB7XHJcbiAgICAgIGFjdGlvbihzY3JvbGxiYXJTdHJ1Y3R1cmUuX3Njcm9sbGJhciwgY2xhc3NOYW1lcyk7XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIGNvbnN0IHNjcm9sbGJhclN0eWxlID0gKFxyXG4gICAgc2Nyb2xsYmFyU3RydWN0dXJlczogU2Nyb2xsYmFyU3RydWN0dXJlW10sXHJcbiAgICBlbG1TdHlsZTogU2Nyb2xsYmFyU3R5bGVGblxyXG4gICkgPT4ge1xyXG4gICAgZWFjaChzY3JvbGxiYXJTdHJ1Y3R1cmVzLCAoc2Nyb2xsYmFyU3RydWN0dXJlKSA9PiB7XHJcbiAgICAgIGNvbnN0IFtlbG0sIHN0eWxlc10gPSBlbG1TdHlsZShzY3JvbGxiYXJTdHJ1Y3R1cmUpO1xyXG4gICAgICBzZXRTdHlsZXMoZWxtLCBzdHlsZXMpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICBjb25zdCBzY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MgPSAoXHJcbiAgICBjbGFzc05hbWU6IHN0cmluZyB8IGZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgIGFkZD86IGJvb2xlYW4sXHJcbiAgICBvbmx5SG9yaXpvbnRhbD86IGJvb2xlYW5cclxuICApID0+IHtcclxuICAgIGNvbnN0IHNpbmdsZUF4aXMgPSBpc0Jvb2xlYW4ob25seUhvcml6b250YWwpO1xyXG4gICAgY29uc3QgcnVuSG9yaXpvbnRhbCA9IHNpbmdsZUF4aXMgPyBvbmx5SG9yaXpvbnRhbCA6IHRydWU7XHJcbiAgICBjb25zdCBydW5WZXJ0aWNhbCA9IHNpbmdsZUF4aXMgPyAhb25seUhvcml6b250YWwgOiB0cnVlO1xyXG4gICAgaWYgKHJ1bkhvcml6b250YWwpIHtcclxuICAgICAgc2Nyb2xsYmFyU3RydWN0dXJlQWRkUmVtb3ZlQ2xhc3MoaG9yaXpvbnRhbFNjcm9sbGJhcnMsIGNsYXNzTmFtZSwgYWRkKTtcclxuICAgIH1cclxuICAgIGlmIChydW5WZXJ0aWNhbCkge1xyXG4gICAgICBzY3JvbGxiYXJTdHJ1Y3R1cmVBZGRSZW1vdmVDbGFzcyh2ZXJ0aWNhbFNjcm9sbGJhcnMsIGNsYXNzTmFtZSwgYWRkKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHJlZnJlc2hTY3JvbGxiYXJzSGFuZGxlTGVuZ3RoID0gKCkgPT4ge1xyXG4gICAgY29uc3Qgdmlld3BvcnRQZXJjZW50ID0gZ2V0Vmlld3BvcnRQZXJjZW50KCk7XHJcbiAgICBjb25zdCBjcmVhdGVTY3JvbGxiYXJTdHlsZUZuID1cclxuICAgICAgKGF4aXNWaWV3cG9ydFBlcmNlbnQ6IG51bWJlcik6IFNjcm9sbGJhclN0eWxlRm4gPT5cclxuICAgICAgKHN0cnVjdHVyZTogU2Nyb2xsYmFyU3RydWN0dXJlKSA9PiBbXHJcbiAgICAgICAgc3RydWN0dXJlLl9zY3JvbGxiYXIsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgW2Nzc0N1c3RvbVByb3BWaWV3cG9ydFBlcmNlbnRdOiByb3VuZENzc051bWJlcihheGlzVmlld3BvcnRQZXJjZW50KSArICcnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF07XHJcblxyXG4gICAgc2Nyb2xsYmFyU3R5bGUoaG9yaXpvbnRhbFNjcm9sbGJhcnMsIGNyZWF0ZVNjcm9sbGJhclN0eWxlRm4odmlld3BvcnRQZXJjZW50LngpKTtcclxuICAgIHNjcm9sbGJhclN0eWxlKHZlcnRpY2FsU2Nyb2xsYmFycywgY3JlYXRlU2Nyb2xsYmFyU3R5bGVGbih2aWV3cG9ydFBlcmNlbnQueSkpO1xyXG4gIH07XHJcbiAgY29uc3QgcmVmcmVzaFNjcm9sbGJhcnNIYW5kbGVPZmZzZXQgPSAoKSA9PiB7XHJcbiAgICBpZiAoIXNjcm9sbFQpIHtcclxuICAgICAgY29uc3QgeyBfc2Nyb2xsQ29vcmRpbmF0ZXMgfSA9IHN0cnVjdHVyZVNldHVwU3RhdGU7XHJcbiAgICAgIGNvbnN0IHNjcm9sbFBlcmNlbnQgPSBnZXRTY3JvbGxDb29yZGluYXRlc1BlcmNlbnQoXHJcbiAgICAgICAgX3Njcm9sbENvb3JkaW5hdGVzLFxyXG4gICAgICAgIGdldEVsZW1lbnRTY3JvbGwoX3Njcm9sbE9mZnNldEVsZW1lbnQpXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IGNyZWF0ZVNjcm9sbGJhclN0eWxlRm4gPVxyXG4gICAgICAgIChheGlzU2Nyb2xsUGVyY2VudDogbnVtYmVyKTogU2Nyb2xsYmFyU3R5bGVGbiA9PlxyXG4gICAgICAgIChzdHJ1Y3R1cmU6IFNjcm9sbGJhclN0cnVjdHVyZSkgPT4gW1xyXG4gICAgICAgICAgc3RydWN0dXJlLl9zY3JvbGxiYXIsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFtjc3NDdXN0b21Qcm9wU2Nyb2xsUGVyY2VudF06IHJvdW5kQ3NzTnVtYmVyKGF4aXNTY3JvbGxQZXJjZW50KSArICcnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgc2Nyb2xsYmFyU3R5bGUoaG9yaXpvbnRhbFNjcm9sbGJhcnMsIGNyZWF0ZVNjcm9sbGJhclN0eWxlRm4oc2Nyb2xsUGVyY2VudC54KSk7XHJcbiAgICAgIHNjcm9sbGJhclN0eWxlKHZlcnRpY2FsU2Nyb2xsYmFycywgY3JlYXRlU2Nyb2xsYmFyU3R5bGVGbihzY3JvbGxQZXJjZW50LnkpKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHJlZnJlc2hTY3JvbGxiYXJzU2Nyb2xsQ29vcmRpbmF0ZXMgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IF9zY3JvbGxDb29yZGluYXRlcyB9ID0gc3RydWN0dXJlU2V0dXBTdGF0ZTtcclxuICAgIGNvbnN0IGRlZmF1bHREaXJlY3Rpb25TY3JvbGwgPSBpc0RlZmF1bHREaXJlY3Rpb25TY3JvbGxDb29yZGluYXRlcyhfc2Nyb2xsQ29vcmRpbmF0ZXMpO1xyXG4gICAgY29uc3QgY3JlYXRlU2Nyb2xsYmFyU3R5bGVGbiA9XHJcbiAgICAgIChheGlzSXNEZWZhdWx0RGlyZWN0aW9uU2Nyb2xsQ29vcmRpbmF0ZXM6IGJvb2xlYW4pOiBTY3JvbGxiYXJTdHlsZUZuID0+XHJcbiAgICAgIChzdHJ1Y3R1cmU6IFNjcm9sbGJhclN0cnVjdHVyZSkgPT4gW1xyXG4gICAgICAgIHN0cnVjdHVyZS5fc2Nyb2xsYmFyLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFtjc3NDdXN0b21Qcm9wU2Nyb2xsRGlyZWN0aW9uXTogYXhpc0lzRGVmYXVsdERpcmVjdGlvblNjcm9sbENvb3JkaW5hdGVzID8gJzAnIDogJzEnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF07XHJcblxyXG4gICAgc2Nyb2xsYmFyU3R5bGUoaG9yaXpvbnRhbFNjcm9sbGJhcnMsIGNyZWF0ZVNjcm9sbGJhclN0eWxlRm4oZGVmYXVsdERpcmVjdGlvblNjcm9sbC54KSk7XHJcbiAgICBzY3JvbGxiYXJTdHlsZSh2ZXJ0aWNhbFNjcm9sbGJhcnMsIGNyZWF0ZVNjcm9sbGJhclN0eWxlRm4oZGVmYXVsdERpcmVjdGlvblNjcm9sbC55KSk7XHJcblxyXG4gICAgLy8gdGVtcG9yYXJ5IGZpeCBmb3I6IGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYS9PdmVybGF5U2Nyb2xsYmFycy9pc3N1ZXMvNzA1XHJcbiAgICBpZiAoc2Nyb2xsVCkge1xyXG4gICAgICBob3Jpem9udGFsU2Nyb2xsYmFycy5mb3JFYWNoKHNjcm9sbFRpbWVsaW5lLnghLl9zZXRTY3JvbGxQZXJjZW50QW5pbWF0aW9uKTtcclxuICAgICAgdmVydGljYWxTY3JvbGxiYXJzLmZvckVhY2goc2Nyb2xsVGltZWxpbmUueSEuX3NldFNjcm9sbFBlcmNlbnRBbmltYXRpb24pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgcmVmcmVzaFNjcm9sbGJhcnNTY3JvbGxiYXJPZmZzZXQgPSAoKSA9PiB7XHJcbiAgICBpZiAoX3ZpZXdwb3J0SXNUYXJnZXQgJiYgIV9pc0JvZHkpIHtcclxuICAgICAgY29uc3QgeyBfb3ZlcmZsb3dBbW91bnQsIF9zY3JvbGxDb29yZGluYXRlcyB9ID0gc3RydWN0dXJlU2V0dXBTdGF0ZTtcclxuICAgICAgY29uc3QgaXNEZWZhdWx0RGlyZWN0aW9uU2Nyb2xsID0gaXNEZWZhdWx0RGlyZWN0aW9uU2Nyb2xsQ29vcmRpbmF0ZXMoX3Njcm9sbENvb3JkaW5hdGVzKTtcclxuICAgICAgY29uc3Qgc2Nyb2xsUGVyY2VudCA9IGdldFNjcm9sbENvb3JkaW5hdGVzUGVyY2VudChcclxuICAgICAgICBfc2Nyb2xsQ29vcmRpbmF0ZXMsXHJcbiAgICAgICAgZ2V0RWxlbWVudFNjcm9sbChfc2Nyb2xsT2Zmc2V0RWxlbWVudClcclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgc3R5bGVTY3JvbGxiYXJQb3NpdGlvbjogU2Nyb2xsYmFyU3R5bGVGbiA9IChzdHJ1Y3R1cmU6IFNjcm9sbGJhclN0cnVjdHVyZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgX3Njcm9sbGJhciB9ID0gc3RydWN0dXJlO1xyXG4gICAgICAgIGNvbnN0IGVsbSA9IHBhcmVudChfc2Nyb2xsYmFyKSA9PT0gX3ZpZXdwb3J0ICYmIF9zY3JvbGxiYXI7XHJcbiAgICAgICAgY29uc3QgZ2V0VHJhbnNsYXRlVmFsdWUgPSAoXHJcbiAgICAgICAgICBheGlzU2Nyb2xsUGVyY2VudDogbnVtYmVyLFxyXG4gICAgICAgICAgYXhpc092ZXJmbG93QW1vdW50OiBudW1iZXIsXHJcbiAgICAgICAgICBheGlzSXNEZWZhdWx0Q29vcmRpbmF0ZXM6IGJvb2xlYW5cclxuICAgICAgICApID0+IHtcclxuICAgICAgICAgIGNvbnN0IHB4ID0gYXhpc092ZXJmbG93QW1vdW50ICogYXhpc1Njcm9sbFBlcmNlbnQ7XHJcbiAgICAgICAgICByZXR1cm4gbnVtYmVyVG9Dc3NQeChheGlzSXNEZWZhdWx0Q29vcmRpbmF0ZXMgPyBweCA6IC1weCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIGVsbSxcclxuICAgICAgICAgIGVsbSAmJiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogZ2V0VHJhc2Zvcm1UcmFuc2xhdGVWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgeDogZ2V0VHJhbnNsYXRlVmFsdWUoc2Nyb2xsUGVyY2VudC54LCBfb3ZlcmZsb3dBbW91bnQueCwgaXNEZWZhdWx0RGlyZWN0aW9uU2Nyb2xsLngpLFxyXG4gICAgICAgICAgICAgIHk6IGdldFRyYW5zbGF0ZVZhbHVlKHNjcm9sbFBlcmNlbnQueSwgX292ZXJmbG93QW1vdW50LnksIGlzRGVmYXVsdERpcmVjdGlvblNjcm9sbC55KSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzY3JvbGxiYXJTdHlsZShob3Jpem9udGFsU2Nyb2xsYmFycywgc3R5bGVTY3JvbGxiYXJQb3NpdGlvbik7XHJcbiAgICAgIHNjcm9sbGJhclN0eWxlKHZlcnRpY2FsU2Nyb2xsYmFycywgc3R5bGVTY3JvbGxiYXJQb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBnZW5lcmF0ZVNjcm9sbGJhckRPTSA9IChpc0hvcml6b250YWw/OiBib29sZWFuKTogU2Nyb2xsYmFyU3RydWN0dXJlID0+IHtcclxuICAgIGNvbnN0IHh5S2V5ID0gaXNIb3Jpem9udGFsID8gJ3gnIDogJ3knO1xyXG4gICAgY29uc3Qgc2Nyb2xsYmFyQ2xhc3NOYW1lID0gaXNIb3Jpem9udGFsXHJcbiAgICAgID8gY2xhc3NOYW1lU2Nyb2xsYmFySG9yaXpvbnRhbFxyXG4gICAgICA6IGNsYXNzTmFtZVNjcm9sbGJhclZlcnRpY2FsO1xyXG4gICAgY29uc3Qgc2Nyb2xsYmFyID0gY3JlYXRlRGl2KGAke2NsYXNzTmFtZVNjcm9sbGJhcn0gJHtzY3JvbGxiYXJDbGFzc05hbWV9YCk7XHJcbiAgICBjb25zdCB0cmFjayA9IGNyZWF0ZURpdihjbGFzc05hbWVTY3JvbGxiYXJUcmFjayk7XHJcbiAgICBjb25zdCBoYW5kbGUgPSBjcmVhdGVEaXYoY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgX3Njcm9sbGJhcjogc2Nyb2xsYmFyLFxyXG4gICAgICBfdHJhY2s6IHRyYWNrLFxyXG4gICAgICBfaGFuZGxlOiBoYW5kbGUsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgdGltZWxpbmUgPSBzY3JvbGxUaW1lbGluZVt4eUtleV07XHJcblxyXG4gICAgcHVzaChpc0hvcml6b250YWwgPyBob3Jpem9udGFsU2Nyb2xsYmFycyA6IHZlcnRpY2FsU2Nyb2xsYmFycywgcmVzdWx0KTtcclxuICAgIHB1c2goZGVzdHJveUZucywgW1xyXG4gICAgICBhcHBlbmRDaGlsZHJlbihzY3JvbGxiYXIsIHRyYWNrKSxcclxuICAgICAgYXBwZW5kQ2hpbGRyZW4odHJhY2ssIGhhbmRsZSksXHJcbiAgICAgIGJpbmQocmVtb3ZlRWxlbWVudHMsIHNjcm9sbGJhciksXHJcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLl9zZXRTY3JvbGxQZXJjZW50QW5pbWF0aW9uKHJlc3VsdCksXHJcbiAgICAgIHNjcm9sbGJhcnNTZXR1cEV2ZW50cyhyZXN1bHQsIHNjcm9sbGJhcnNBZGRSZW1vdmVDbGFzcywgaXNIb3Jpem9udGFsKSxcclxuICAgIF0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuICBjb25zdCBnZW5lcmF0ZUhvcml6b250YWxTY3JvbGxiYXJTdHJ1Y3R1cmUgPSBiaW5kKGdlbmVyYXRlU2Nyb2xsYmFyRE9NLCB0cnVlKTtcclxuICBjb25zdCBnZW5lcmF0ZVZlcnRpY2FsU2Nyb2xsYmFyU3RydWN0dXJlID0gYmluZChnZW5lcmF0ZVNjcm9sbGJhckRPTSwgZmFsc2UpO1xyXG4gIGNvbnN0IGFwcGVuZEVsZW1lbnRzID0gKCkgPT4ge1xyXG4gICAgYXBwZW5kQ2hpbGRyZW4oZXZhbHVhdGVkU2Nyb2xsYmFyU2xvdCwgaG9yaXpvbnRhbFNjcm9sbGJhcnNbMF0uX3Njcm9sbGJhcik7XHJcbiAgICBhcHBlbmRDaGlsZHJlbihldmFsdWF0ZWRTY3JvbGxiYXJTbG90LCB2ZXJ0aWNhbFNjcm9sbGJhcnNbMF0uX3Njcm9sbGJhcik7XHJcblxyXG4gICAgcmV0dXJuIGJpbmQocnVuRWFjaEFuZENsZWFyLCBkZXN0cm95Rm5zKTtcclxuICB9O1xyXG5cclxuICBnZW5lcmF0ZUhvcml6b250YWxTY3JvbGxiYXJTdHJ1Y3R1cmUoKTtcclxuICBnZW5lcmF0ZVZlcnRpY2FsU2Nyb2xsYmFyU3RydWN0dXJlKCk7XHJcblxyXG4gIHJldHVybiBbXHJcbiAgICB7XHJcbiAgICAgIF9yZWZyZXNoU2Nyb2xsYmFyc0hhbmRsZUxlbmd0aDogcmVmcmVzaFNjcm9sbGJhcnNIYW5kbGVMZW5ndGgsXHJcbiAgICAgIF9yZWZyZXNoU2Nyb2xsYmFyc0hhbmRsZU9mZnNldDogcmVmcmVzaFNjcm9sbGJhcnNIYW5kbGVPZmZzZXQsXHJcbiAgICAgIF9yZWZyZXNoU2Nyb2xsYmFyc1Njcm9sbENvb3JkaW5hdGVzOiByZWZyZXNoU2Nyb2xsYmFyc1Njcm9sbENvb3JkaW5hdGVzLFxyXG4gICAgICBfcmVmcmVzaFNjcm9sbGJhcnNTY3JvbGxiYXJPZmZzZXQ6IHJlZnJlc2hTY3JvbGxiYXJzU2Nyb2xsYmFyT2Zmc2V0LFxyXG4gICAgICBfc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzOiBzY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MsXHJcbiAgICAgIF9ob3Jpem9udGFsOiB7XHJcbiAgICAgICAgX3Njcm9sbGJhclN0cnVjdHVyZXM6IGhvcml6b250YWxTY3JvbGxiYXJzLFxyXG4gICAgICAgIF9jbG9uZTogZ2VuZXJhdGVIb3Jpem9udGFsU2Nyb2xsYmFyU3RydWN0dXJlLFxyXG4gICAgICAgIF9zdHlsZTogYmluZChzY3JvbGxiYXJTdHlsZSwgaG9yaXpvbnRhbFNjcm9sbGJhcnMpLFxyXG4gICAgICB9LFxyXG4gICAgICBfdmVydGljYWw6IHtcclxuICAgICAgICBfc2Nyb2xsYmFyU3RydWN0dXJlczogdmVydGljYWxTY3JvbGxiYXJzLFxyXG4gICAgICAgIF9jbG9uZTogZ2VuZXJhdGVWZXJ0aWNhbFNjcm9sbGJhclN0cnVjdHVyZSxcclxuICAgICAgICBfc3R5bGU6IGJpbmQoc2Nyb2xsYmFyU3R5bGUsIHZlcnRpY2FsU2Nyb2xsYmFycyksXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgYXBwZW5kRWxlbWVudHMsXHJcbiAgXTtcclxufTtcclxuIiwiaW1wb3J0IHR5cGUgeyBYWSB9IGZyb20gJy4uLy4uL3N1cHBvcnQnO1xyXG5pbXBvcnQgdHlwZSB7IENsaWNrU2Nyb2xsUGx1Z2luIH0gZnJvbSAnLi4vLi4vcGx1Z2lucyc7XHJcbmltcG9ydCB0eXBlIHsgUmVhZG9ubHlPcHRpb25zIH0gZnJvbSAnLi4vLi4vb3B0aW9ucyc7XHJcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlU2V0dXBTdGF0ZSB9IGZyb20gJy4uLy4uL3NldHVwcyc7XHJcbmltcG9ydCB0eXBlIHsgU2Nyb2xsYmFyc1NldHVwRWxlbWVudHNPYmosIFNjcm9sbGJhclN0cnVjdHVyZSB9IGZyb20gJy4vc2Nyb2xsYmFyc1NldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHR5cGUgeyBTdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzT2JqIH0gZnJvbSAnLi4vc3RydWN0dXJlU2V0dXAvc3RydWN0dXJlU2V0dXAuZWxlbWVudHMnO1xyXG5pbXBvcnQge1xyXG4gIGNsYXNzTmFtZVNjcm9sbGJhckhhbmRsZSxcclxuICBjbGFzc05hbWVTY3JvbGxiYXJJbnRlcmFjdGlvbixcclxuICBjbGFzc05hbWVTY3JvbGxiYXJXaGVlbCxcclxuICBkYXRhQXR0cmlidXRlSG9zdCxcclxuICBkYXRhQXR0cmlidXRlVmlld3BvcnQsXHJcbn0gZnJvbSAnLi4vLi4vY2xhc3NuYW1lcyc7XHJcbmltcG9ydCB7IGNsaWNrU2Nyb2xsUGx1Z2luTW9kdWxlTmFtZSwgZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2UgfSBmcm9tICcuLi8uLi9wbHVnaW5zJztcclxuaW1wb3J0IHtcclxuICBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXHJcbiAgZ2V0T2Zmc2V0U2l6ZSxcclxuICBhZGRFdmVudExpc3RlbmVyLFxyXG4gIHByZXZlbnREZWZhdWx0LFxyXG4gIHJ1bkVhY2hBbmRDbGVhcixcclxuICBzZWxmQ2xlYXJUaW1lb3V0LFxyXG4gIHBhcmVudCxcclxuICBjbG9zZXN0LFxyXG4gIHB1c2gsXHJcbiAgYmluZCxcclxuICBtYXRoUm91bmQsXHJcbiAgc3RyV2lkdGgsXHJcbiAgc3RySGVpZ2h0LFxyXG4gIGdldEVsZW1lbnRTY3JvbGwsXHJcbiAgc2Nyb2xsRWxlbWVudFRvLFxyXG4gIGdldEZvY3VzZWRFbGVtZW50LFxyXG4gIHNldFQsXHJcbiAgaGFzQXR0cixcclxuICBzdG9wQW5kUHJldmVudCxcclxuICBpc0Z1bmN0aW9uLFxyXG4gIG1hdGhBYnMsXHJcbiAgZm9jdXNFbGVtZW50LFxyXG59IGZyb20gJy4uLy4uL3N1cHBvcnQnO1xyXG5cclxuZXhwb3J0IHR5cGUgU2Nyb2xsYmFyc1NldHVwRXZlbnRzID0gKFxyXG4gIHNjcm9sbGJhclN0cnVjdHVyZTogU2Nyb2xsYmFyU3RydWN0dXJlLFxyXG4gIHNjcm9sbGJhcnNBZGRSZW1vdmVDbGFzczogU2Nyb2xsYmFyc1NldHVwRWxlbWVudHNPYmpbJ19zY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MnXSxcclxuICBpc0hvcml6b250YWw/OiBib29sZWFuXHJcbikgPT4gKCkgPT4gdm9pZDtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVTY3JvbGxiYXJzU2V0dXBFdmVudHMgPSAoXHJcbiAgb3B0aW9uczogUmVhZG9ubHlPcHRpb25zLFxyXG4gIHN0cnVjdHVyZVNldHVwRWxlbWVudHM6IFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmosXHJcbiAgc3RydWN0dXJlU2V0dXBTdGF0ZTogU3RydWN0dXJlU2V0dXBTdGF0ZSxcclxuICBzY3JvbGxiYXJIYW5kbGVQb2ludGVySW50ZXJhY3Rpb246IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB2b2lkXHJcbik6IFNjcm9sbGJhcnNTZXR1cEV2ZW50cyA9PiB7XHJcbiAgcmV0dXJuIChzY3JvbGxiYXJTdHJ1Y3R1cmUsIHNjcm9sbGJhcnNBZGRSZW1vdmVDbGFzcywgaXNIb3Jpem9udGFsKSA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIF9ob3N0LFxyXG4gICAgICBfdmlld3BvcnQsXHJcbiAgICAgIF92aWV3cG9ydElzVGFyZ2V0LFxyXG4gICAgICBfc2Nyb2xsT2Zmc2V0RWxlbWVudCxcclxuICAgICAgX2RvY3VtZW50RWxtLFxyXG4gICAgICBfcmVtb3ZlU2Nyb2xsT2JzY3VyaW5nU3R5bGVzLFxyXG4gICAgfSA9IHN0cnVjdHVyZVNldHVwRWxlbWVudHM7XHJcbiAgICBjb25zdCB7IF9zY3JvbGxiYXIsIF90cmFjaywgX2hhbmRsZSB9ID0gc2Nyb2xsYmFyU3RydWN0dXJlO1xyXG4gICAgY29uc3QgW3doZWVsVGltZW91dCwgY2xlYXJXaGVlbFRpbWVvdXRdID0gc2VsZkNsZWFyVGltZW91dCgzMzMpO1xyXG4gICAgY29uc3QgW3Njcm9sbFNuYXBTY3JvbGxUcmFuc2l0aW9uVGltZW91dCwgY2xlYXJTY3JvbGxTbmFwU2Nyb2xsVHJhbnNpdGlvblRpbWVvdXRdID1cclxuICAgICAgc2VsZkNsZWFyVGltZW91dCg0NDQpO1xyXG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0RWxlbWVudFNjcm9sbEJ5ID0gKGNvb3JkaW5hdGVzOiBYWTxudW1iZXI+KSA9PiB7XHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKF9zY3JvbGxPZmZzZXRFbGVtZW50LnNjcm9sbEJ5KSkge1xyXG4gICAgICAgIF9zY3JvbGxPZmZzZXRFbGVtZW50LnNjcm9sbEJ5KHtcclxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcclxuICAgICAgICAgIGxlZnQ6IGNvb3JkaW5hdGVzLngsXHJcbiAgICAgICAgICB0b3A6IGNvb3JkaW5hdGVzLnksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY3JlYXRlSW50ZXJhY3RpdmVTY3JvbGxFdmVudHMgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlbGVhc2VQb2ludGVyQ2FwdHVyZUV2ZW50cyA9ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBsb3N0cG9pbnRlcmNhcHR1cmUnO1xyXG4gICAgICBjb25zdCBjbGllbnRYWUtleSA9IGBjbGllbnQke2lzSG9yaXpvbnRhbCA/ICdYJyA6ICdZJ31gIGFzICdjbGllbnRYJyB8ICdjbGllbnRZJztcclxuICAgICAgY29uc3Qgd2lkdGhIZWlnaHRLZXkgPSBpc0hvcml6b250YWwgPyBzdHJXaWR0aCA6IHN0ckhlaWdodDtcclxuICAgICAgY29uc3QgbGVmdFRvcEtleSA9IGlzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnO1xyXG4gICAgICBjb25zdCB3aEtleSA9IGlzSG9yaXpvbnRhbCA/ICd3JyA6ICdoJztcclxuICAgICAgY29uc3QgeHlLZXkgPSBpc0hvcml6b250YWwgPyAneCcgOiAneSc7XHJcblxyXG4gICAgICBjb25zdCBjcmVhdGVSZWxhdGl2ZUhhbmRsZU1vdmUgPVxyXG4gICAgICAgIChtb3VzZURvd25TY3JvbGw6IG51bWJlciwgaW52ZXJ0ZWRTY2FsZTogbnVtYmVyKSA9PiAoZGVsdGFNb3ZlbWVudDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB7IF9vdmVyZmxvd0Ftb3VudCB9ID0gc3RydWN0dXJlU2V0dXBTdGF0ZTtcclxuICAgICAgICAgIGNvbnN0IGhhbmRsZVRyYWNrRGlmZiA9IGdldE9mZnNldFNpemUoX3RyYWNrKVt3aEtleV0gLSBnZXRPZmZzZXRTaXplKF9oYW5kbGUpW3doS2V5XTtcclxuICAgICAgICAgIGNvbnN0IHNjcm9sbERlbHRhUGVyY2VudCA9IChpbnZlcnRlZFNjYWxlICogZGVsdGFNb3ZlbWVudCkgLyBoYW5kbGVUcmFja0RpZmY7XHJcbiAgICAgICAgICBjb25zdCBzY3JvbGxEZWx0YSA9IHNjcm9sbERlbHRhUGVyY2VudCAqIF9vdmVyZmxvd0Ftb3VudFt4eUtleV07XHJcblxyXG4gICAgICAgICAgc2Nyb2xsRWxlbWVudFRvKF9zY3JvbGxPZmZzZXRFbGVtZW50LCB7XHJcbiAgICAgICAgICAgIFt4eUtleV06IG1vdXNlRG93blNjcm9sbCArIHNjcm9sbERlbHRhLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgY29uc3QgcG9pbnRlcmRvd25DbGVhbnVwRm5zOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xyXG5cclxuICAgICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIoX3RyYWNrLCAncG9pbnRlcmRvd24nLCAocG9pbnRlckRvd25FdmVudDogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNEcmFnU2Nyb2xsID1cclxuICAgICAgICAgIGNsb3Nlc3QocG9pbnRlckRvd25FdmVudC50YXJnZXQgYXMgTm9kZSwgYC4ke2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZX1gKSA9PT0gX2hhbmRsZTtcclxuICAgICAgICBjb25zdCBwb2ludGVyQ2FwdHVyZUVsZW1lbnQgPSBpc0RyYWdTY3JvbGwgPyBfaGFuZGxlIDogX3RyYWNrO1xyXG5cclxuICAgICAgICBjb25zdCBzY3JvbGxiYXJPcHRpb25zID0gb3B0aW9ucy5zY3JvbGxiYXJzO1xyXG4gICAgICAgIGNvbnN0IGRyYWdDbGlja1Njcm9sbE9wdGlvbiA9IHNjcm9sbGJhck9wdGlvbnNbaXNEcmFnU2Nyb2xsID8gJ2RyYWdTY3JvbGwnIDogJ2NsaWNrU2Nyb2xsJ107XHJcbiAgICAgICAgY29uc3QgeyBidXR0b24sIGlzUHJpbWFyeSwgcG9pbnRlclR5cGUgfSA9IHBvaW50ZXJEb3duRXZlbnQ7XHJcbiAgICAgICAgY29uc3QgeyBwb2ludGVycyB9ID0gc2Nyb2xsYmFyT3B0aW9ucztcclxuXHJcbiAgICAgICAgY29uc3QgY29udGludWVQb2ludGVyRG93biA9XHJcbiAgICAgICAgICBidXR0b24gPT09IDAgJiZcclxuICAgICAgICAgIGlzUHJpbWFyeSAmJlxyXG4gICAgICAgICAgZHJhZ0NsaWNrU2Nyb2xsT3B0aW9uICYmXHJcbiAgICAgICAgICAocG9pbnRlcnMgfHwgW10pLmluY2x1ZGVzKHBvaW50ZXJUeXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRpbnVlUG9pbnRlckRvd24pIHtcclxuICAgICAgICAgIHJ1bkVhY2hBbmRDbGVhcihwb2ludGVyZG93bkNsZWFudXBGbnMpO1xyXG4gICAgICAgICAgY2xlYXJTY3JvbGxTbmFwU2Nyb2xsVHJhbnNpdGlvblRpbWVvdXQoKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBpbnN0YW50Q2xpY2tTY3JvbGwgPVxyXG4gICAgICAgICAgICAhaXNEcmFnU2Nyb2xsICYmIChwb2ludGVyRG93bkV2ZW50LnNoaWZ0S2V5IHx8IGRyYWdDbGlja1Njcm9sbE9wdGlvbiA9PT0gJ2luc3RhbnQnKTtcclxuICAgICAgICAgIGNvbnN0IGdldEhhbmRsZVJlY3QgPSBiaW5kKGdldEJvdW5kaW5nQ2xpZW50UmVjdCwgX2hhbmRsZSk7XHJcbiAgICAgICAgICBjb25zdCBnZXRUcmFja1JlY3QgPSBiaW5kKGdldEJvdW5kaW5nQ2xpZW50UmVjdCwgX3RyYWNrKTtcclxuICAgICAgICAgIGNvbnN0IGdldEhhbmRsZU9mZnNldCA9IChoYW5kbGVSZWN0PzogRE9NUmVjdCwgdHJhY2tSZWN0PzogRE9NUmVjdCkgPT5cclxuICAgICAgICAgICAgKGhhbmRsZVJlY3QgfHwgZ2V0SGFuZGxlUmVjdCgpKVtsZWZ0VG9wS2V5XSAtICh0cmFja1JlY3QgfHwgZ2V0VHJhY2tSZWN0KCkpW2xlZnRUb3BLZXldO1xyXG4gICAgICAgICAgY29uc3QgYXhpc1NjYWxlID1cclxuICAgICAgICAgICAgbWF0aFJvdW5kKGdldEJvdW5kaW5nQ2xpZW50UmVjdChfc2Nyb2xsT2Zmc2V0RWxlbWVudClbd2lkdGhIZWlnaHRLZXldKSAvXHJcbiAgICAgICAgICAgICAgZ2V0T2Zmc2V0U2l6ZShfc2Nyb2xsT2Zmc2V0RWxlbWVudClbd2hLZXldIHx8IDE7XHJcbiAgICAgICAgICBjb25zdCBtb3ZlSGFuZGxlUmVsYXRpdmUgPSBjcmVhdGVSZWxhdGl2ZUhhbmRsZU1vdmUoXHJcbiAgICAgICAgICAgIGdldEVsZW1lbnRTY3JvbGwoX3Njcm9sbE9mZnNldEVsZW1lbnQpW3h5S2V5XSxcclxuICAgICAgICAgICAgMSAvIGF4aXNTY2FsZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGNvbnN0IHBvaW50ZXJEb3duT2Zmc2V0ID0gcG9pbnRlckRvd25FdmVudFtjbGllbnRYWUtleV07XHJcbiAgICAgICAgICBjb25zdCBoYW5kbGVSZWN0ID0gZ2V0SGFuZGxlUmVjdCgpO1xyXG4gICAgICAgICAgY29uc3QgdHJhY2tSZWN0ID0gZ2V0VHJhY2tSZWN0KCk7XHJcbiAgICAgICAgICBjb25zdCBoYW5kbGVMZW5ndGggPSBoYW5kbGVSZWN0W3dpZHRoSGVpZ2h0S2V5XTtcclxuICAgICAgICAgIGNvbnN0IGhhbmRsZUNlbnRlciA9IGdldEhhbmRsZU9mZnNldChoYW5kbGVSZWN0LCB0cmFja1JlY3QpICsgaGFuZGxlTGVuZ3RoIC8gMjtcclxuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlVHJhY2tQb2ludGVyT2Zmc2V0ID0gcG9pbnRlckRvd25PZmZzZXQgLSB0cmFja1JlY3RbbGVmdFRvcEtleV07XHJcbiAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IGlzRHJhZ1Njcm9sbCA/IDAgOiByZWxhdGl2ZVRyYWNrUG9pbnRlck9mZnNldCAtIGhhbmRsZUNlbnRlcjtcclxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSA9IChwb2ludGVyVXBFdmVudDogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHJ1bkVhY2hBbmRDbGVhcihwb2ludGVydXBDbGVhbnVwRm5zKTtcclxuICAgICAgICAgICAgcG9pbnRlckNhcHR1cmVFbGVtZW50LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVyVXBFdmVudC5wb2ludGVySWQpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGNvbnN0IG5vbkFuaW1hdGVkU2Nyb2xsID0gaXNEcmFnU2Nyb2xsIHx8IGluc3RhbnRDbGlja1Njcm9sbDtcclxuICAgICAgICAgIGNvbnN0IHJldmVydFNjcm9sbE9ic2N1cmluZ1N0eWxlcyA9IF9yZW1vdmVTY3JvbGxPYnNjdXJpbmdTdHlsZXMoKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBwb2ludGVydXBDbGVhbnVwRm5zID0gW1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsbSwgcmVsZWFzZVBvaW50ZXJDYXB0dXJlRXZlbnRzLCByZWxlYXNlUG9pbnRlckNhcHR1cmUpLFxyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsbSwgJ3NlbGVjdHN0YXJ0JywgKGV2ZW50OiBFdmVudCkgPT4gcHJldmVudERlZmF1bHQoZXZlbnQpLCB7XHJcbiAgICAgICAgICAgICAgX3Bhc3NpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfdHJhY2ssIHJlbGVhc2VQb2ludGVyQ2FwdHVyZUV2ZW50cywgcmVsZWFzZVBvaW50ZXJDYXB0dXJlKSxcclxuICAgICAgICAgICAgbm9uQW5pbWF0ZWRTY3JvbGwgJiZcclxuICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKF90cmFjaywgJ3BvaW50ZXJtb3ZlJywgKHBvaW50ZXJNb3ZlRXZlbnQ6IFBvaW50ZXJFdmVudCkgPT5cclxuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVSZWxhdGl2ZShcclxuICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgKyAocG9pbnRlck1vdmVFdmVudFtjbGllbnRYWUtleV0gLSBwb2ludGVyRG93bk9mZnNldClcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBub25BbmltYXRlZFNjcm9sbCAmJlxyXG4gICAgICAgICAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRob3V0U25hcFNjcm9sbE9mZnNldCA9IGdldEVsZW1lbnRTY3JvbGwoX3Njcm9sbE9mZnNldEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJ0U2Nyb2xsT2JzY3VyaW5nU3R5bGVzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoU25hcFNjcm9sbE9mZnNldCA9IGdldEVsZW1lbnRTY3JvbGwoX3Njcm9sbE9mZnNldEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcFNjcm9sbERpZmYgPSB7XHJcbiAgICAgICAgICAgICAgICAgIHg6IHdpdGhTbmFwU2Nyb2xsT2Zmc2V0LnggLSB3aXRob3V0U25hcFNjcm9sbE9mZnNldC54LFxyXG4gICAgICAgICAgICAgICAgICB5OiB3aXRoU25hcFNjcm9sbE9mZnNldC55IC0gd2l0aG91dFNuYXBTY3JvbGxPZmZzZXQueSxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGhBYnMoc25hcFNjcm9sbERpZmYueCkgPiAzIHx8IG1hdGhBYnMoc25hcFNjcm9sbERpZmYueSkgPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgIF9yZW1vdmVTY3JvbGxPYnNjdXJpbmdTdHlsZXMoKTtcclxuICAgICAgICAgICAgICAgICAgc2Nyb2xsRWxlbWVudFRvKF9zY3JvbGxPZmZzZXRFbGVtZW50LCB3aXRob3V0U25hcFNjcm9sbE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgIHNjcm9sbE9mZnNldEVsZW1lbnRTY3JvbGxCeShzbmFwU2Nyb2xsRGlmZik7XHJcbiAgICAgICAgICAgICAgICAgIHNjcm9sbFNuYXBTY3JvbGxUcmFuc2l0aW9uVGltZW91dChyZXZlcnRTY3JvbGxPYnNjdXJpbmdTdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICBwb2ludGVyQ2FwdHVyZUVsZW1lbnQuc2V0UG9pbnRlckNhcHR1cmUocG9pbnRlckRvd25FdmVudC5wb2ludGVySWQpO1xyXG5cclxuICAgICAgICAgIGlmIChpbnN0YW50Q2xpY2tTY3JvbGwpIHtcclxuICAgICAgICAgICAgbW92ZUhhbmRsZVJlbGF0aXZlKHN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZ1Njcm9sbCkge1xyXG4gICAgICAgICAgICBjb25zdCBhbmltYXRlQ2xpY2tTY3JvbGwgPSBnZXRTdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZTx0eXBlb2YgQ2xpY2tTY3JvbGxQbHVnaW4+KFxyXG4gICAgICAgICAgICAgIGNsaWNrU2Nyb2xsUGx1Z2luTW9kdWxlTmFtZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZUNsaWNrU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc3RvcENsaWNrU2Nyb2xsQW5pbWF0aW9uID0gYW5pbWF0ZUNsaWNrU2Nyb2xsKFxyXG4gICAgICAgICAgICAgICAgbW92ZUhhbmRsZVJlbGF0aXZlLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAoc3RvcHBlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBkb2Vzbid0IGNvbnRpbnVlIHdpdGggYSBwcmVzc1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldmVydFNjcm9sbE9ic2N1cmluZ1N0eWxlcygpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2gocG9pbnRlcnVwQ2xlYW51cEZucywgcmV2ZXJ0U2Nyb2xsT2JzY3VyaW5nU3R5bGVzKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgIHB1c2gocG9pbnRlcnVwQ2xlYW51cEZucywgc3RvcENsaWNrU2Nyb2xsQW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICBwdXNoKHBvaW50ZXJkb3duQ2xlYW51cEZucywgYmluZChzdG9wQ2xpY2tTY3JvbGxBbmltYXRpb24sIHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCB3aGVlbFNjcm9sbEJ5ID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gYmluZChydW5FYWNoQW5kQ2xlYXIsIFtcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfaGFuZGxlLCAncG9pbnRlcm1vdmUgcG9pbnRlcmxlYXZlJywgc2Nyb2xsYmFySGFuZGxlUG9pbnRlckludGVyYWN0aW9uKSxcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfc2Nyb2xsYmFyLCAncG9pbnRlcmVudGVyJywgKCkgPT4ge1xyXG4gICAgICAgIHNjcm9sbGJhcnNBZGRSZW1vdmVDbGFzcyhjbGFzc05hbWVTY3JvbGxiYXJJbnRlcmFjdGlvbiwgdHJ1ZSk7XHJcbiAgICAgIH0pLFxyXG4gICAgICBhZGRFdmVudExpc3RlbmVyKF9zY3JvbGxiYXIsICdwb2ludGVybGVhdmUgcG9pbnRlcmNhbmNlbCcsICgpID0+IHtcclxuICAgICAgICBzY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MoY2xhc3NOYW1lU2Nyb2xsYmFySW50ZXJhY3Rpb24sIGZhbHNlKTtcclxuICAgICAgfSksXHJcbiAgICAgIC8vIGZvY3VzIHZpZXdwb3J0IHdoZW4gY2xpY2tpbmcgb24gYSBzY3JvbGxiYXIgKG1vdXNlIG9ubHkpXHJcbiAgICAgICFfdmlld3BvcnRJc1RhcmdldCAmJlxyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoX3Njcm9sbGJhciwgJ21vdXNlZG93bicsICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcclxuICAgICAgICAgIC8vIGRvbnQgc3RlYWwgZm9jdXMgZnJvbSBidXR0b25zIG9yIG90aGVyIGludGVyYWN0aXZlIGVsZW1lbnRzXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGhhc0F0dHIoZm9jdXNlZEVsZW1lbnQsIGRhdGFBdHRyaWJ1dGVWaWV3cG9ydCkgfHxcclxuICAgICAgICAgICAgaGFzQXR0cihmb2N1c2VkRWxlbWVudCwgZGF0YUF0dHJpYnV0ZUhvc3QpIHx8XHJcbiAgICAgICAgICAgIGZvY3VzZWRFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5XHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgc2V0VChiaW5kKGZvY3VzRWxlbWVudCwgX3ZpZXdwb3J0KSwgMjUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAvLyBwcm9wYWdhdGUgd2hlZWwgZXZlbnRzIHRvIHZpZXdwb3J0IHdoZW4gbW91c2UgaXMgb3ZlciBzY3JvbGxiYXJcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBfc2Nyb2xsYmFyLFxyXG4gICAgICAgICd3aGVlbCcsXHJcbiAgICAgICAgKHdoZWVsRXZlbnQ6IFdoZWVsRXZlbnQpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHsgZGVsdGFYLCBkZWx0YVksIGRlbHRhTW9kZSB9ID0gd2hlZWxFdmVudDtcclxuXHJcbiAgICAgICAgICAvLyB0aGUgZmlyc3Qgd2hlZWwgZXZlbnQgaXMgc3dhbGxvd2VkLCBzaW11bGF0ZSBzY3JvbGwgdG8gY29tcGVuc2F0ZSBmb3IgaXRcclxuICAgICAgICAgIGlmICh3aGVlbFNjcm9sbEJ5ICYmIGRlbHRhTW9kZSA9PT0gMCAmJiBwYXJlbnQoX3Njcm9sbGJhcikgPT09IF9ob3N0KSB7XHJcbiAgICAgICAgICAgIHNjcm9sbE9mZnNldEVsZW1lbnRTY3JvbGxCeSh7XHJcbiAgICAgICAgICAgICAgeDogZGVsdGFYLFxyXG4gICAgICAgICAgICAgIHk6IGRlbHRhWSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgd2hlZWxTY3JvbGxCeSA9IGZhbHNlO1xyXG4gICAgICAgICAgc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzKGNsYXNzTmFtZVNjcm9sbGJhcldoZWVsLCB0cnVlKTtcclxuICAgICAgICAgIHdoZWVsVGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHdoZWVsU2Nyb2xsQnkgPSB0cnVlO1xyXG4gICAgICAgICAgICBzY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MoY2xhc3NOYW1lU2Nyb2xsYmFyV2hlZWwpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcHJldmVudERlZmF1bHQod2hlZWxFdmVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IF9wYXNzaXZlOiBmYWxzZSwgX2NhcHR1cmU6IHRydWUgfVxyXG4gICAgICApLFxyXG4gICAgICAvLyBzb2x2ZSBwcm9ibGVtIG9mIGludGVyYWN0aW9uIGNhdXNpbmcgYGNsaWNrYCBldmVudHMgKGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYS9PdmVybGF5U2Nyb2xsYmFycy9pc3N1ZXMvMjUxKVxyXG4gICAgICAvLyAxLiBvbiBgc2Nyb2xsYmFyYCBwb2ludGVyIGRvd24gcmVnaXN0ZXIgYSBgZG9jdW1lbnRgIGNsaWNrIGV2ZW50IHdoaWNoIGdldHMgcHJldmVudGVkIGFuZCBwcm9wYWdhdGlvbiBpcyBzdG9wcGVkXHJcbiAgICAgIC8vIDIuIG9uIGBkb2N1bWVudGAgcG9pbnRlcnVwIC8gcG9pbnRlcmNhbmNlbCByZW1vdmUgdGhhdCBjbGljayBldmVudCBhZnRlciBhIHRpbWVvdXQgKGluIGNhc2UgdGhlIGNsaWNrIGlzIG5ldmVyIHRyaWdnZXJlZClcclxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBfc2Nyb2xsYmFyLFxyXG4gICAgICAgICdwb2ludGVyZG93bicsXHJcbiAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcmVtb3ZlQ2xpY2tFdmVudCA9IGFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgIF9kb2N1bWVudEVsbSxcclxuICAgICAgICAgICAgJ2NsaWNrJyxcclxuICAgICAgICAgICAgKGNsaWNrRXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgcmVtb3ZlUG9pbnRlckV2ZW50cygpO1xyXG4gICAgICAgICAgICAgIHN0b3BBbmRQcmV2ZW50KGNsaWNrRXZlbnQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgX29uY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgX2NhcHR1cmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgX3Bhc3NpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgY29uc3QgcmVtb3ZlUG9pbnRlckV2ZW50cyA9IGFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgIF9kb2N1bWVudEVsbSxcclxuICAgICAgICAgICAgJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJyxcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHJlbW92ZVBvaW50ZXJFdmVudHMoKTtcclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlbW92ZUNsaWNrRXZlbnQsIDE1MCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBfY2FwdHVyZTogdHJ1ZSxcclxuICAgICAgICAgICAgICBfcGFzc2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgX2NhcHR1cmU6IHRydWUsIF9wYXNzaXZlOiB0cnVlIH1cclxuICAgICAgKSxcclxuICAgICAgY3JlYXRlSW50ZXJhY3RpdmVTY3JvbGxFdmVudHMoKSxcclxuICAgICAgY2xlYXJXaGVlbFRpbWVvdXQsXHJcbiAgICAgIGNsZWFyU2Nyb2xsU25hcFNjcm9sbFRyYW5zaXRpb25UaW1lb3V0LFxyXG4gICAgXSk7XHJcbiAgfTtcclxufTtcclxuIiwiaW1wb3J0IHR5cGUgeyBPdmVyZmxvd0JlaGF2aW9yLCBSZWFkb25seU9wdGlvbnMgfSBmcm9tICcuLi8uLi9vcHRpb25zJztcclxuaW1wb3J0IHR5cGUgeyBTY3JvbGxiYXJzU2V0dXBFbGVtZW50c09iaiB9IGZyb20gJy4vc2Nyb2xsYmFyc1NldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHR5cGUge1xyXG4gIE9ic2VydmVyc1NldHVwU3RhdGUsXHJcbiAgT2JzZXJ2ZXJzU2V0dXBVcGRhdGVIaW50cyxcclxuICBTZXR1cCxcclxuICBTZXR1cFVwZGF0ZUluZm8sXHJcbiAgU3RydWN0dXJlU2V0dXBTdGF0ZSxcclxuICBTdHJ1Y3R1cmVTZXR1cFVwZGF0ZUhpbnRzLFxyXG59IGZyb20gJy4uLy4uL3NldHVwcyc7XHJcbmltcG9ydCB0eXBlIHsgSW5pdGlhbGl6YXRpb25UYXJnZXQgfSBmcm9tICcuLi8uLi9pbml0aWFsaXphdGlvbic7XHJcbmltcG9ydCB0eXBlIHsgT3ZlcmZsb3dTdHlsZSB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xyXG5pbXBvcnQgdHlwZSB7IFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmogfSBmcm9tICcuLi9zdHJ1Y3R1cmVTZXR1cC9zdHJ1Y3R1cmVTZXR1cC5lbGVtZW50cyc7XHJcbmltcG9ydCB7XHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFyVGhlbWVOb25lLFxyXG4gIGNsYXNzTmFtZVNjcm9sbGJhclZpc2libGUsXHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFyVW51c2FibGUsXHJcbiAgY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVybGVzcyxcclxuICBjbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZUhpZGRlbixcclxuICBjbGFzc05hbWVTY3JvbGxiYXJIYW5kbGVJbnRlcmFjdGl2ZSxcclxuICBjbGFzc05hbWVTY3JvbGxiYXJUcmFja0ludGVyYWN0aXZlLFxyXG4gIGNsYXNzTmFtZVNjcm9sbGJhclJ0bCxcclxuICBjbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZSxcclxufSBmcm9tICcuLi8uLi9jbGFzc25hbWVzJztcclxuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnQgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XHJcbmltcG9ydCB7XHJcbiAgYmluZCxcclxuICBub29wLFxyXG4gIGFkZEV2ZW50TGlzdGVuZXIsXHJcbiAgcHVzaCxcclxuICBydW5FYWNoQW5kQ2xlYXIsXHJcbiAgc2VsZkNsZWFyVGltZW91dCxcclxuICBzdHJTY3JvbGwsXHJcbiAgc3RyVmlzaWJsZSxcclxufSBmcm9tICcuLi8uLi9zdXBwb3J0JztcclxuaW1wb3J0IHsgY3JlYXRlU2Nyb2xsYmFyc1NldHVwRWxlbWVudHMgfSBmcm9tICcuL3Njcm9sbGJhcnNTZXR1cC5lbGVtZW50cyc7XHJcbmltcG9ydCB7IGNyZWF0ZVNjcm9sbGJhcnNTZXR1cEV2ZW50cyB9IGZyb20gJy4vc2Nyb2xsYmFyc1NldHVwLmV2ZW50cyc7XHJcbmltcG9ydCB7XHJcbiAgZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2UsXHJcbiAgU2Nyb2xsYmFyc0hpZGluZ1BsdWdpbixcclxuICBzY3JvbGxiYXJzSGlkaW5nUGx1Z2luTmFtZSxcclxufSBmcm9tICcuLi8uLi9wbHVnaW5zJztcclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktb2JqZWN0LXR5cGVcclxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxiYXJzU2V0dXBTdGF0ZSB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxiYXJzU2V0dXBVcGRhdGVJbmZvIGV4dGVuZHMgU2V0dXBVcGRhdGVJbmZvIHtcclxuICBfb2JzZXJ2ZXJzVXBkYXRlSGludHM/OiBPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzO1xyXG4gIF9zdHJ1Y3R1cmVVcGRhdGVIaW50cz86IFN0cnVjdHVyZVNldHVwVXBkYXRlSGludHM7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNjcm9sbGJhcnNTZXR1cCA9IFtcclxuICAuLi5TZXR1cDxTY3JvbGxiYXJzU2V0dXBVcGRhdGVJbmZvLCBTY3JvbGxiYXJzU2V0dXBTdGF0ZSwgdm9pZD4sXHJcbiAgLyoqIFRoZSBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoZSBzY3JvbGxiYXJzIHNldHVwLiAqL1xyXG4gIFNjcm9sbGJhcnNTZXR1cEVsZW1lbnRzT2JqLFxyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNjcm9sbGJhcnNTZXR1cCA9IChcclxuICB0YXJnZXQ6IEluaXRpYWxpemF0aW9uVGFyZ2V0LFxyXG4gIG9wdGlvbnM6IFJlYWRvbmx5T3B0aW9ucyxcclxuICBvYnNlcnZlcnNTZXR1cFN0YXRlOiBPYnNlcnZlcnNTZXR1cFN0YXRlLFxyXG4gIHN0cnVjdHVyZVNldHVwU3RhdGU6IFN0cnVjdHVyZVNldHVwU3RhdGUsXHJcbiAgc3RydWN0dXJlU2V0dXBFbGVtZW50czogU3RydWN0dXJlU2V0dXBFbGVtZW50c09iaixcclxuICBvblNjcm9sbDogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxyXG4pOiBTY3JvbGxiYXJzU2V0dXAgPT4ge1xyXG4gIGxldCBtb3VzZUluSG9zdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICBsZXQgYXV0b0hpZGVJc01vdmU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgbGV0IGF1dG9IaWRlSXNMZWF2ZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICBsZXQgYXV0b0hpZGVJc05ldmVyOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gIGxldCBwcmV2VGhlbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgbGV0IGluc3RhbmNlQXV0b0hpZGVTdXNwZW5kU2Nyb2xsRGVzdHJveUZuID0gbm9vcDtcclxuICBsZXQgaW5zdGFuY2VBdXRvSGlkZURlbGF5ID0gMDtcclxuICBjb25zdCBob3ZlcmFibGVQb2ludGVyVHlwZXMgPSBbJ21vdXNlJywgJ3BlbiddO1xyXG5cclxuICAvLyBuZWVkZWQgdG8gbm90IGZpcmUgdW5uZWNlc3Nhcnkgb3BlcmF0aW9ucyBmb3IgcG9pbnRlciBldmVudHMgb24gaW9zIHNhZmFyaSB3aGljaCB3aWxsIGNhdXNlIHNpZGUgZWZmZWN0czogaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhL092ZXJsYXlTY3JvbGxiYXJzL2lzc3Vlcy81NjBcclxuICBjb25zdCBpc0hvdmVyYWJsZVBvaW50ZXJUeXBlID0gKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+XHJcbiAgICBob3ZlcmFibGVQb2ludGVyVHlwZXMuaW5jbHVkZXMoZXZlbnQucG9pbnRlclR5cGUpO1xyXG5cclxuICBjb25zdCBbcmVxdWVzdFNjcm9sbEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxTY3JvbGxBbmltYXRpb25GcmFtZV0gPSBzZWxmQ2xlYXJUaW1lb3V0KCk7XHJcbiAgY29uc3QgW2F1dG9IaWRlSW5zdGFudEludGVyYWN0aW9uVGltZW91dCwgY2xlYXJBdXRvSGlkZUluc3RhbnRJbnRlcmFjdGlvblRpbWVvdXRdID1cclxuICAgIHNlbGZDbGVhclRpbWVvdXQoMTAwKTtcclxuICBjb25zdCBbYXV0b0hpZGVTdXNwZW5kVGltZW91dCwgY2xlYXJBdXRvSGlkZVN1c3BlbmRUaW1lb3V0XSA9IHNlbGZDbGVhclRpbWVvdXQoMTAwKTtcclxuICBjb25zdCBbYXVvdEhpZGVUaW1lb3V0LCBjbGVhckF1dG9IaWRlVGltZW91dF0gPSBzZWxmQ2xlYXJUaW1lb3V0KCgpID0+IGluc3RhbmNlQXV0b0hpZGVEZWxheSk7XHJcbiAgY29uc3QgW2VsZW1lbnRzLCBhcHBlbmRFbGVtZW50c10gPSBjcmVhdGVTY3JvbGxiYXJzU2V0dXBFbGVtZW50cyhcclxuICAgIHRhcmdldCxcclxuICAgIHN0cnVjdHVyZVNldHVwRWxlbWVudHMsXHJcbiAgICBzdHJ1Y3R1cmVTZXR1cFN0YXRlLFxyXG4gICAgY3JlYXRlU2Nyb2xsYmFyc1NldHVwRXZlbnRzKFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgICBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzLFxyXG4gICAgICBzdHJ1Y3R1cmVTZXR1cFN0YXRlLFxyXG4gICAgICAoZXZlbnQpID0+IGlzSG92ZXJhYmxlUG9pbnRlclR5cGUoZXZlbnQpICYmIG1hbmFnZVNjcm9sbGJhcnNBdXRvSGlkZUluc3RhbnRJbnRlcmFjdGlvbigpXHJcbiAgICApXHJcbiAgKTtcclxuICBjb25zdCB7IF9ob3N0LCBfc2Nyb2xsRXZlbnRFbGVtZW50LCBfaXNCb2R5IH0gPSBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzO1xyXG4gIGNvbnN0IHtcclxuICAgIF9zY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MsXHJcbiAgICBfcmVmcmVzaFNjcm9sbGJhcnNIYW5kbGVMZW5ndGgsXHJcbiAgICBfcmVmcmVzaFNjcm9sbGJhcnNIYW5kbGVPZmZzZXQsXHJcbiAgICBfcmVmcmVzaFNjcm9sbGJhcnNTY3JvbGxDb29yZGluYXRlcyxcclxuICAgIF9yZWZyZXNoU2Nyb2xsYmFyc1Njcm9sbGJhck9mZnNldCxcclxuICB9ID0gZWxlbWVudHM7XHJcbiAgY29uc3QgbWFuYWdlU2Nyb2xsYmFyc0F1dG9IaWRlID0gKHJlbW92ZUF1dG9IaWRlOiBib29sZWFuLCBkZWxheWxlc3M/OiBib29sZWFuKSA9PiB7XHJcbiAgICBjbGVhckF1dG9IaWRlVGltZW91dCgpO1xyXG4gICAgaWYgKHJlbW92ZUF1dG9IaWRlKSB7XHJcbiAgICAgIF9zY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MoY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGVIaWRkZW4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaGlkZSA9IGJpbmQoX3Njcm9sbGJhcnNBZGRSZW1vdmVDbGFzcywgY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGVIaWRkZW4sIHRydWUpO1xyXG4gICAgICBpZiAoaW5zdGFuY2VBdXRvSGlkZURlbGF5ID4gMCAmJiAhZGVsYXlsZXNzKSB7XHJcbiAgICAgICAgYXVvdEhpZGVUaW1lb3V0KGhpZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgbWFuYWdlU2Nyb2xsYmFyc0F1dG9IaWRlSW5zdGFudEludGVyYWN0aW9uID0gKCkgPT4ge1xyXG4gICAgaWYgKGF1dG9IaWRlSXNMZWF2ZSA/ICFtb3VzZUluSG9zdCA6ICFhdXRvSGlkZUlzTmV2ZXIpIHtcclxuICAgICAgbWFuYWdlU2Nyb2xsYmFyc0F1dG9IaWRlKHRydWUpO1xyXG4gICAgICBhdXRvSGlkZUluc3RhbnRJbnRlcmFjdGlvblRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIG1hbmFnZVNjcm9sbGJhcnNBdXRvSGlkZShmYWxzZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgbWFuYWdlQXV0b0hpZGVTdXNwZW5zaW9uID0gKGFkZDogYm9vbGVhbikgPT4ge1xyXG4gICAgX3Njcm9sbGJhcnNBZGRSZW1vdmVDbGFzcyhjbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZSwgYWRkLCB0cnVlKTtcclxuICAgIF9zY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MoY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGUsIGFkZCwgZmFsc2UpO1xyXG4gIH07XHJcbiAgY29uc3Qgb25Ib3N0TW91c2VFbnRlciA9IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICBpZiAoaXNIb3ZlcmFibGVQb2ludGVyVHlwZShldmVudCkpIHtcclxuICAgICAgbW91c2VJbkhvc3QgPSBhdXRvSGlkZUlzTGVhdmU7XHJcbiAgICAgIGlmIChhdXRvSGlkZUlzTGVhdmUpIHtcclxuICAgICAgICBtYW5hZ2VTY3JvbGxiYXJzQXV0b0hpZGUodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGRlc3Ryb3lGbnM6ICgoKSA9PiB2b2lkKVtdID0gW1xyXG4gICAgY2xlYXJBdXRvSGlkZVRpbWVvdXQsXHJcbiAgICBjbGVhckF1dG9IaWRlSW5zdGFudEludGVyYWN0aW9uVGltZW91dCxcclxuICAgIGNsZWFyQXV0b0hpZGVTdXNwZW5kVGltZW91dCxcclxuICAgIGNhbmNlbFNjcm9sbEFuaW1hdGlvbkZyYW1lLFxyXG4gICAgKCkgPT4gaW5zdGFuY2VBdXRvSGlkZVN1c3BlbmRTY3JvbGxEZXN0cm95Rm4oKSxcclxuXHJcbiAgICBhZGRFdmVudExpc3RlbmVyKF9ob3N0LCAncG9pbnRlcm92ZXInLCBvbkhvc3RNb3VzZUVudGVyLCB7IF9vbmNlOiB0cnVlIH0pLFxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihfaG9zdCwgJ3BvaW50ZXJlbnRlcicsIG9uSG9zdE1vdXNlRW50ZXIpLFxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihfaG9zdCwgJ3BvaW50ZXJsZWF2ZScsIChldmVudDogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChpc0hvdmVyYWJsZVBvaW50ZXJUeXBlKGV2ZW50KSkge1xyXG4gICAgICAgIG1vdXNlSW5Ib3N0ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGF1dG9IaWRlSXNMZWF2ZSkge1xyXG4gICAgICAgICAgbWFuYWdlU2Nyb2xsYmFyc0F1dG9IaWRlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pLFxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihfaG9zdCwgJ3BvaW50ZXJtb3ZlJywgKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgaWYgKGlzSG92ZXJhYmxlUG9pbnRlclR5cGUoZXZlbnQpICYmIGF1dG9IaWRlSXNNb3ZlKSB7XHJcbiAgICAgICAgbWFuYWdlU2Nyb2xsYmFyc0F1dG9IaWRlSW5zdGFudEludGVyYWN0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH0pLFxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihfc2Nyb2xsRXZlbnRFbGVtZW50LCAnc2Nyb2xsJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgIHJlcXVlc3RTY3JvbGxBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgX3JlZnJlc2hTY3JvbGxiYXJzSGFuZGxlT2Zmc2V0KCk7XHJcbiAgICAgICAgbWFuYWdlU2Nyb2xsYmFyc0F1dG9IaWRlSW5zdGFudEludGVyYWN0aW9uKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgb25TY3JvbGwoZXZlbnQpO1xyXG5cclxuICAgICAgX3JlZnJlc2hTY3JvbGxiYXJzU2Nyb2xsYmFyT2Zmc2V0KCk7XHJcbiAgICB9KSxcclxuICBdO1xyXG4gIGNvbnN0IHNjcm9sbGJhcnNIaWRpbmdQbHVnaW4gPSBnZXRTdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZTx0eXBlb2YgU2Nyb2xsYmFyc0hpZGluZ1BsdWdpbj4oXHJcbiAgICBzY3JvbGxiYXJzSGlkaW5nUGx1Z2luTmFtZVxyXG4gICk7XHJcblxyXG4gIHJldHVybiBbXHJcbiAgICAoKSA9PiBiaW5kKHJ1bkVhY2hBbmRDbGVhciwgcHVzaChkZXN0cm95Rm5zLCBhcHBlbmRFbGVtZW50cygpKSksXHJcbiAgICAoeyBfY2hlY2tPcHRpb24sIF9mb3JjZSwgX29ic2VydmVyc1VwZGF0ZUhpbnRzLCBfc3RydWN0dXJlVXBkYXRlSGludHMgfSkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgX292ZXJmbG93RWRnZUNoYW5nZWQsXHJcbiAgICAgICAgX292ZXJmbG93QW1vdW50Q2hhbmdlZCxcclxuICAgICAgICBfb3ZlcmZsb3dTdHlsZUNoYW5nZWQsXHJcbiAgICAgICAgX3Njcm9sbENvb3JkaW5hdGVzQ2hhbmdlZCxcclxuICAgICAgfSA9IF9zdHJ1Y3R1cmVVcGRhdGVIaW50cyB8fCB7fTtcclxuICAgICAgY29uc3QgeyBfZGlyZWN0aW9uQ2hhbmdlZCwgX2FwcGVhciB9ID0gX29ic2VydmVyc1VwZGF0ZUhpbnRzIHx8IHt9O1xyXG4gICAgICBjb25zdCB7IF9kaXJlY3Rpb25Jc1JUTCB9ID0gb2JzZXJ2ZXJzU2V0dXBTdGF0ZTtcclxuICAgICAgY29uc3QgeyBfbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLCBfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZyB9ID0gZ2V0RW52aXJvbm1lbnQoKTtcclxuICAgICAgY29uc3QgeyBfb3ZlcmZsb3dTdHlsZSwgX2hhc092ZXJmbG93IH0gPSBzdHJ1Y3R1cmVTZXR1cFN0YXRlO1xyXG4gICAgICBjb25zdCBbc2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFyc09wdGlvbiwgc2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFyc0NoYW5nZWRdID1cclxuICAgICAgICBfY2hlY2tPcHRpb24oJ3Nob3dOYXRpdmVPdmVybGFpZFNjcm9sbGJhcnMnKTtcclxuICAgICAgY29uc3QgW3RoZW1lLCB0aGVtZUNoYW5nZWRdID0gX2NoZWNrT3B0aW9uKCdzY3JvbGxiYXJzLnRoZW1lJyk7XHJcbiAgICAgIGNvbnN0IFt2aXNpYmlsaXR5LCB2aXNpYmlsaXR5Q2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ3Njcm9sbGJhcnMudmlzaWJpbGl0eScpO1xyXG4gICAgICBjb25zdCBbYXV0b0hpZGUsIGF1dG9IaWRlQ2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ3Njcm9sbGJhcnMuYXV0b0hpZGUnKTtcclxuICAgICAgY29uc3QgW2F1dG9IaWRlU3VzcGVuZCwgYXV0b0hpZGVTdXNwZW5kQ2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ3Njcm9sbGJhcnMuYXV0b0hpZGVTdXNwZW5kJyk7XHJcbiAgICAgIGNvbnN0IFthdXRvSGlkZURlbGF5XSA9IF9jaGVja09wdGlvbignc2Nyb2xsYmFycy5hdXRvSGlkZURlbGF5Jyk7XHJcbiAgICAgIGNvbnN0IFtkcmFnU2Nyb2xsLCBkcmFnU2Nyb2xsQ2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ3Njcm9sbGJhcnMuZHJhZ1Njcm9sbCcpO1xyXG4gICAgICBjb25zdCBbY2xpY2tTY3JvbGwsIGNsaWNrU2Nyb2xsQ2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ3Njcm9sbGJhcnMuY2xpY2tTY3JvbGwnKTtcclxuICAgICAgY29uc3QgW292ZXJmbG93LCBvdmVyZmxvd0NoYW5nZWRdID0gX2NoZWNrT3B0aW9uKCdvdmVyZmxvdycpO1xyXG4gICAgICBjb25zdCB0cnVseUFwcGVhcmVkID0gX2FwcGVhciAmJiAhX2ZvcmNlO1xyXG4gICAgICBjb25zdCBoYXNPdmVyZmxvdyA9IF9oYXNPdmVyZmxvdy54IHx8IF9oYXNPdmVyZmxvdy55O1xyXG4gICAgICBjb25zdCB1cGRhdGVTY3JvbGxiYXJzID1cclxuICAgICAgICBfb3ZlcmZsb3dFZGdlQ2hhbmdlZCB8fFxyXG4gICAgICAgIF9vdmVyZmxvd0Ftb3VudENoYW5nZWQgfHxcclxuICAgICAgICBfc2Nyb2xsQ29vcmRpbmF0ZXNDaGFuZ2VkIHx8XHJcbiAgICAgICAgX2RpcmVjdGlvbkNoYW5nZWQgfHxcclxuICAgICAgICBfZm9yY2U7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZVZpc2liaWxpdHkgPSBfb3ZlcmZsb3dTdHlsZUNoYW5nZWQgfHwgdmlzaWJpbGl0eUNoYW5nZWQgfHwgb3ZlcmZsb3dDaGFuZ2VkO1xyXG4gICAgICBjb25zdCBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzID1cclxuICAgICAgICBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzT3B0aW9uICYmXHJcbiAgICAgICAgX25hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC54ICYmXHJcbiAgICAgICAgX25hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC55O1xyXG4gICAgICBjb25zdCBjYW50SGlkZVNjcm9sbGJhcnMgPSAhX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmcgJiYgIXNjcm9sbGJhcnNIaWRpbmdQbHVnaW47XHJcbiAgICAgIGNvbnN0IHNob3dOYXRpdmVTY3JvbGxiYXJzID0gc2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFycyB8fCBjYW50SGlkZVNjcm9sbGJhcnM7XHJcblxyXG4gICAgICBjb25zdCBzZXRTY3JvbGxiYXJWaXNpYmlsaXR5ID0gKFxyXG4gICAgICAgIG92ZXJmbG93QmVoYXZpb3I6IE92ZXJmbG93QmVoYXZpb3IsXHJcbiAgICAgICAgb3ZlcmZsb3dTdHlsZTogT3ZlcmZsb3dTdHlsZSxcclxuICAgICAgICBpc0hvcml6b250YWw6IGJvb2xlYW5cclxuICAgICAgKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID1cclxuICAgICAgICAgIG92ZXJmbG93QmVoYXZpb3IuaW5jbHVkZXMoc3RyU2Nyb2xsKSAmJlxyXG4gICAgICAgICAgKHZpc2liaWxpdHkgPT09IHN0clZpc2libGUgfHwgKHZpc2liaWxpdHkgPT09ICdhdXRvJyAmJiBvdmVyZmxvd1N0eWxlID09PSBzdHJTY3JvbGwpKTtcclxuXHJcbiAgICAgICAgX3Njcm9sbGJhcnNBZGRSZW1vdmVDbGFzcyhjbGFzc05hbWVTY3JvbGxiYXJWaXNpYmxlLCBpc1Zpc2libGUsIGlzSG9yaXpvbnRhbCk7XHJcblxyXG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpbnN0YW5jZUF1dG9IaWRlRGVsYXkgPSBhdXRvSGlkZURlbGF5O1xyXG5cclxuICAgICAgaWYgKHRydWx5QXBwZWFyZWQpIHtcclxuICAgICAgICBpZiAoYXV0b0hpZGVTdXNwZW5kICYmIGhhc092ZXJmbG93KSB7XHJcbiAgICAgICAgICBtYW5hZ2VBdXRvSGlkZVN1c3BlbnNpb24oZmFsc2UpO1xyXG4gICAgICAgICAgaW5zdGFuY2VBdXRvSGlkZVN1c3BlbmRTY3JvbGxEZXN0cm95Rm4oKTtcclxuICAgICAgICAgIGF1dG9IaWRlU3VzcGVuZFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpbnN0YW5jZUF1dG9IaWRlU3VzcGVuZFNjcm9sbERlc3Ryb3lGbiA9IGFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgX3Njcm9sbEV2ZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAnc2Nyb2xsJyxcclxuICAgICAgICAgICAgICBiaW5kKG1hbmFnZUF1dG9IaWRlU3VzcGVuc2lvbiwgdHJ1ZSksXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX29uY2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1hbmFnZUF1dG9IaWRlU3VzcGVuc2lvbih0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzQ2hhbmdlZCB8fCBjYW50SGlkZVNjcm9sbGJhcnMpIHtcclxuICAgICAgICBfc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzKGNsYXNzTmFtZVNjcm9sbGJhclRoZW1lTm9uZSwgc2hvd05hdGl2ZVNjcm9sbGJhcnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhlbWVDaGFuZ2VkKSB7XHJcbiAgICAgICAgX3Njcm9sbGJhcnNBZGRSZW1vdmVDbGFzcyhwcmV2VGhlbWUpO1xyXG4gICAgICAgIF9zY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3ModGhlbWUsIHRydWUpO1xyXG5cclxuICAgICAgICBwcmV2VGhlbWUgPSB0aGVtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGF1dG9IaWRlU3VzcGVuZENoYW5nZWQgJiYgIWF1dG9IaWRlU3VzcGVuZCkge1xyXG4gICAgICAgIG1hbmFnZUF1dG9IaWRlU3VzcGVuc2lvbih0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGF1dG9IaWRlQ2hhbmdlZCkge1xyXG4gICAgICAgIGF1dG9IaWRlSXNNb3ZlID0gYXV0b0hpZGUgPT09ICdtb3ZlJztcclxuICAgICAgICBhdXRvSGlkZUlzTGVhdmUgPSBhdXRvSGlkZSA9PT0gJ2xlYXZlJztcclxuICAgICAgICBhdXRvSGlkZUlzTmV2ZXIgPSBhdXRvSGlkZSA9PT0gJ25ldmVyJztcclxuICAgICAgICBtYW5hZ2VTY3JvbGxiYXJzQXV0b0hpZGUoYXV0b0hpZGVJc05ldmVyLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRyYWdTY3JvbGxDaGFuZ2VkKSB7XHJcbiAgICAgICAgX3Njcm9sbGJhcnNBZGRSZW1vdmVDbGFzcyhjbGFzc05hbWVTY3JvbGxiYXJIYW5kbGVJbnRlcmFjdGl2ZSwgZHJhZ1Njcm9sbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjbGlja1Njcm9sbENoYW5nZWQpIHtcclxuICAgICAgICBfc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzKGNsYXNzTmFtZVNjcm9sbGJhclRyYWNrSW50ZXJhY3RpdmUsICEhY2xpY2tTY3JvbGwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhbHdheXMgdXBkYXRlIHNjcm9sbGJhciB2aXNpYmlsaXR5IGJlZm9yZSBzY3JvbGxiYXIgc2l6ZVxyXG4gICAgICAvLyB0aGUgc2Nyb2xsYmFyIHNpemUgaXMgaW5mbHVlbmNlZCB3aGV0aGVyIGJvdGggb3IganVzdCBvbmUgc2Nyb2xsYmFyIGlzIHZpc2libGUgKGJlY2F1c2Ugb2YgdGhlIGNvcm5lciBlbGVtZW50KVxyXG4gICAgICBpZiAodXBkYXRlVmlzaWJpbGl0eSkge1xyXG4gICAgICAgIGNvbnN0IHhWaXNpYmxlID0gc2V0U2Nyb2xsYmFyVmlzaWJpbGl0eShvdmVyZmxvdy54LCBfb3ZlcmZsb3dTdHlsZS54LCB0cnVlKTtcclxuICAgICAgICBjb25zdCB5VmlzaWJsZSA9IHNldFNjcm9sbGJhclZpc2liaWxpdHkob3ZlcmZsb3cueSwgX292ZXJmbG93U3R5bGUueSwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGhhc0Nvcm5lciA9IHhWaXNpYmxlICYmIHlWaXNpYmxlO1xyXG5cclxuICAgICAgICBfc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzKGNsYXNzTmFtZVNjcm9sbGJhckNvcm5lcmxlc3MsICFoYXNDb3JuZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhbHdheXMgdXBkYXRlIHNjcm9sbGJhciBzaXplcyBhZnRlciB0aGUgdmlzaWJpbGl0eVxyXG4gICAgICBpZiAodXBkYXRlU2Nyb2xsYmFycykge1xyXG4gICAgICAgIF9yZWZyZXNoU2Nyb2xsYmFyc0hhbmRsZU9mZnNldCgpO1xyXG4gICAgICAgIF9yZWZyZXNoU2Nyb2xsYmFyc0hhbmRsZUxlbmd0aCgpO1xyXG4gICAgICAgIF9yZWZyZXNoU2Nyb2xsYmFyc1Njcm9sbGJhck9mZnNldCgpO1xyXG4gICAgICAgIGlmIChfc2Nyb2xsQ29vcmRpbmF0ZXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgICBfcmVmcmVzaFNjcm9sbGJhcnNTY3JvbGxDb29yZGluYXRlcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3Njcm9sbGJhcnNBZGRSZW1vdmVDbGFzcyhjbGFzc05hbWVTY3JvbGxiYXJVbnVzYWJsZSwgIV9oYXNPdmVyZmxvdy54LCB0cnVlKTtcclxuICAgICAgICBfc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzKGNsYXNzTmFtZVNjcm9sbGJhclVudXNhYmxlLCAhX2hhc092ZXJmbG93LnksIGZhbHNlKTtcclxuICAgICAgICBfc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzKGNsYXNzTmFtZVNjcm9sbGJhclJ0bCwgX2RpcmVjdGlvbklzUlRMICYmICFfaXNCb2R5KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHt9LFxyXG4gICAgZWxlbWVudHMsXHJcbiAgXTtcclxufTtcclxuIiwiaW1wb3J0IHR5cGUge1xyXG4gIEluaXRpYWxpemF0aW9uVGFyZ2V0LFxyXG4gIEluaXRpYWxpemF0aW9uVGFyZ2V0RWxlbWVudCxcclxuICBJbml0aWFsaXphdGlvblRhcmdldE9iamVjdCxcclxufSBmcm9tICcuLi8uLi9pbml0aWFsaXphdGlvbic7XHJcbmltcG9ydCB7XHJcbiAgaXNIVE1MRWxlbWVudCxcclxuICBhcHBlbmRDaGlsZHJlbixcclxuICBjcmVhdGVEaXYsXHJcbiAgY29udGVudHMsXHJcbiAgcGFyZW50LFxyXG4gIHJlbW92ZUVsZW1lbnRzLFxyXG4gIHB1c2gsXHJcbiAgcnVuRWFjaEFuZENsZWFyLFxyXG4gIHJlbW92ZUF0dHJzLFxyXG4gIGhhc0F0dHJDbGFzcyxcclxuICBhZGRFdmVudExpc3RlbmVyLFxyXG4gIGJpbmQsXHJcbiAgaW5BcnJheSxcclxuICBhZGRBdHRyQ2xhc3MsXHJcbiAgYWRkUmVtb3ZlQXR0ckNsYXNzLFxyXG4gIHNldEF0dHJzLFxyXG4gIGdldEF0dHIsXHJcbiAgaXNCb2R5RWxlbWVudCxcclxuICBnZXRGb2N1c2VkRWxlbWVudCxcclxuICB3bmQsXHJcbiAgZm9jdXNFbGVtZW50LFxyXG4gIHN0b3BBbmRQcmV2ZW50LFxyXG4gIGdldE9mZnNldFNpemUsXHJcbiAgZ2V0U2Nyb2xsU2l6ZSxcclxuICBnZXRTdHlsZXMsXHJcbiAgc3RyT3ZlcmZsb3dYLFxyXG4gIHN0ck92ZXJmbG93WSxcclxufSBmcm9tICcuLi8uLi9zdXBwb3J0JztcclxuaW1wb3J0IHtcclxuICBkYXRhQXR0cmlidXRlSG9zdCxcclxuICBkYXRhQXR0cmlidXRlSW5pdGlhbGl6ZSxcclxuICBkYXRhQXR0cmlidXRlVmlld3BvcnQsXHJcbiAgZGF0YVZhbHVlVmlld3BvcnRTY3JvbGxiYXJIaWRkZW4sXHJcbiAgZGF0YUF0dHJpYnV0ZVBhZGRpbmcsXHJcbiAgZGF0YUF0dHJpYnV0ZUNvbnRlbnQsXHJcbiAgZGF0YUF0dHJpYnV0ZUh0bWxCb2R5LFxyXG4gIGRhdGFWYWx1ZUhvc3RJc0hvc3QsXHJcbiAgZGF0YVZhbHVlVmlld3BvcnRTY3JvbGxpbmcsXHJcbn0gZnJvbSAnLi4vLi4vY2xhc3NuYW1lcyc7XHJcbmltcG9ydCB7IGdldEVudmlyb25tZW50IH0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQnO1xyXG5pbXBvcnQge1xyXG4gIHN0YXRpY0luaXRpYWxpemF0aW9uRWxlbWVudCBhcyBnZW5lcmFsU3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50LFxyXG4gIGR5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnQgYXMgZ2VuZXJhbER5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnQsXHJcbn0gZnJvbSAnLi4vLi4vaW5pdGlhbGl6YXRpb24nO1xyXG5pbXBvcnQgeyBvdmVyZmxvd0lzVmlzaWJsZSB9IGZyb20gJy4vc3RydWN0dXJlU2V0dXAudXRpbHMnO1xyXG5cclxuZXhwb3J0IHR5cGUgU3RydWN0dXJlU2V0dXBFbGVtZW50cyA9IFtcclxuICBlbGVtZW50czogU3RydWN0dXJlU2V0dXBFbGVtZW50c09iaixcclxuICBhcHBlbmRFbGVtZW50czogKCkgPT4gKCkgPT4gdm9pZCxcclxuICBjYW5jZWxlZDogKCkgPT4gdm9pZCxcclxuXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RydWN0dXJlU2V0dXBFbGVtZW50c09iaiB7XHJcbiAgX3RhcmdldDogSW5pdGlhbGl6YXRpb25UYXJnZXRFbGVtZW50O1xyXG4gIF9ob3N0OiBIVE1MRWxlbWVudDtcclxuICBfdmlld3BvcnQ6IEhUTUxFbGVtZW50O1xyXG4gIF9wYWRkaW5nOiBIVE1MRWxlbWVudCB8IGZhbHNlO1xyXG4gIF9jb250ZW50OiBIVE1MRWxlbWVudCB8IGZhbHNlO1xyXG4gIF9zY3JvbGxPZmZzZXRFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuICBfc2Nyb2xsRXZlbnRFbGVtZW50OiBIVE1MRWxlbWVudCB8IERvY3VtZW50O1xyXG4gIF9vcmlnaW5hbFNjcm9sbE9mZnNldEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gIC8vIGN0eCAtLS0tXHJcbiAgX2lzQm9keTogYm9vbGVhbjtcclxuICBfZG9jdW1lbnRFbG06IERvY3VtZW50O1xyXG4gIF90YXJnZXRJc0VsbTogYm9vbGVhbjtcclxuICBfdmlld3BvcnRJc1RhcmdldDogYm9vbGVhbjtcclxuICBfd2luZG93RWxtOiAoKSA9PiBXaW5kb3c7XHJcbiAgX3ZpZXdwb3J0SGFzQ2xhc3M6ICh2aWV3cG9ydEF0dHJpYnV0ZUNsYXNzTmFtZTogc3RyaW5nKSA9PiBib29sZWFuO1xyXG4gIF92aWV3cG9ydEFkZFJlbW92ZUNsYXNzOiAodmlld3BvcnRBdHRyaWJ1dGVDbGFzc05hbWU6IHN0cmluZywgYWRkPzogYm9vbGVhbikgPT4gKCkgPT4gdm9pZDtcclxuICBfcmVtb3ZlU2Nyb2xsT2JzY3VyaW5nU3R5bGVzOiAoKSA9PiAoKSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlU3RydWN0dXJlU2V0dXBFbGVtZW50cyA9IChcclxuICB0YXJnZXQ6IEluaXRpYWxpemF0aW9uVGFyZ2V0XHJcbik6IFN0cnVjdHVyZVNldHVwRWxlbWVudHMgPT4ge1xyXG4gIGNvbnN0IGVudiA9IGdldEVudmlyb25tZW50KCk7XHJcbiAgY29uc3QgeyBfZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uLCBfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZyB9ID0gZW52O1xyXG4gIGNvbnN0IHsgZWxlbWVudHM6IGRlZmF1bHRJbml0RWxlbWVudHMgfSA9IF9nZXREZWZhdWx0SW5pdGlhbGl6YXRpb24oKTtcclxuICBjb25zdCB7XHJcbiAgICBwYWRkaW5nOiBkZWZhdWx0UGFkZGluZ0luaXRpYWxpemF0aW9uLFxyXG4gICAgdmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydEluaXRpYWxpemF0aW9uLFxyXG4gICAgY29udGVudDogZGVmYXVsdENvbnRlbnRJbml0aWFsaXphdGlvbixcclxuICB9ID0gZGVmYXVsdEluaXRFbGVtZW50cztcclxuICBjb25zdCB0YXJnZXRJc0VsbSA9IGlzSFRNTEVsZW1lbnQodGFyZ2V0KTtcclxuICBjb25zdCB0YXJnZXRTdHJ1Y3R1cmVJbml0aWFsaXphdGlvbiA9ICh0YXJnZXRJc0VsbSA/IHt9IDogdGFyZ2V0KSBhcyBJbml0aWFsaXphdGlvblRhcmdldE9iamVjdDtcclxuICBjb25zdCB7IGVsZW1lbnRzOiBpbml0RWxlbWVudHMgfSA9IHRhcmdldFN0cnVjdHVyZUluaXRpYWxpemF0aW9uO1xyXG4gIGNvbnN0IHtcclxuICAgIHBhZGRpbmc6IHBhZGRpbmdJbml0aWFsaXphdGlvbixcclxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydEluaXRpYWxpemF0aW9uLFxyXG4gICAgY29udGVudDogY29udGVudEluaXRpYWxpemF0aW9uLFxyXG4gIH0gPSBpbml0RWxlbWVudHMgfHwge307XHJcblxyXG4gIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0YXJnZXRJc0VsbSA/IHRhcmdldCA6IHRhcmdldFN0cnVjdHVyZUluaXRpYWxpemF0aW9uLnRhcmdldDtcclxuICBjb25zdCBpc0JvZHkgPSBpc0JvZHlFbGVtZW50KHRhcmdldEVsZW1lbnQpO1xyXG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSB0YXJnZXRFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XHJcbiAgY29uc3QgZG9jRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gIGNvbnN0IGdldERvY3VtZW50V2luZG93ID0gKCkgPT4gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3bmQ7XHJcbiAgY29uc3Qgc3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50ID0gYmluZChnZW5lcmFsU3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50LCBbdGFyZ2V0RWxlbWVudF0pO1xyXG4gIGNvbnN0IGR5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnQgPSBiaW5kKGdlbmVyYWxEeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50LCBbdGFyZ2V0RWxlbWVudF0pO1xyXG4gIGNvbnN0IGNyZWF0ZU5ld0RpdiA9IGJpbmQoY3JlYXRlRGl2LCAnJyk7XHJcbiAgY29uc3QgZ2VuZXJhdGVWaWV3cG9ydEVsZW1lbnQgPSBiaW5kKFxyXG4gICAgc3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50LFxyXG4gICAgY3JlYXRlTmV3RGl2LFxyXG4gICAgZGVmYXVsdFZpZXdwb3J0SW5pdGlhbGl6YXRpb25cclxuICApO1xyXG4gIGNvbnN0IGdlbmVyYXRlQ29udGVudEVsZW1lbnQgPSBiaW5kKFxyXG4gICAgZHluYW1pY0luaXRpYWxpemF0aW9uRWxlbWVudCxcclxuICAgIGNyZWF0ZU5ld0RpdixcclxuICAgIGRlZmF1bHRDb250ZW50SW5pdGlhbGl6YXRpb25cclxuICApO1xyXG4gIGNvbnN0IGVsZW1lbnRIYXNPdmVyZmxvdyA9IChlbG06IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICBjb25zdCBvZmZzZXRTaXplID0gZ2V0T2Zmc2V0U2l6ZShlbG0pO1xyXG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGdldFNjcm9sbFNpemUoZWxtKTtcclxuICAgIGNvbnN0IG92ZXJmbG93WCA9IGdldFN0eWxlcyhlbG0sIHN0ck92ZXJmbG93WCk7XHJcbiAgICBjb25zdCBvdmVyZmxvd1kgPSBnZXRTdHlsZXMoZWxtLCBzdHJPdmVyZmxvd1kpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIChzY3JvbGxTaXplLncgLSBvZmZzZXRTaXplLncgPiAwICYmICFvdmVyZmxvd0lzVmlzaWJsZShvdmVyZmxvd1gpKSB8fFxyXG4gICAgICAoc2Nyb2xsU2l6ZS5oIC0gb2Zmc2V0U2l6ZS5oID4gMCAmJiAhb3ZlcmZsb3dJc1Zpc2libGUob3ZlcmZsb3dZKSlcclxuICAgICk7XHJcbiAgfTtcclxuICBjb25zdCBwb3NzaWJsZVZpZXdwb3J0RWxlbWVudCA9IGdlbmVyYXRlVmlld3BvcnRFbGVtZW50KHZpZXdwb3J0SW5pdGlhbGl6YXRpb24pO1xyXG4gIGNvbnN0IHZpZXdwb3J0SXNUYXJnZXQgPSBwb3NzaWJsZVZpZXdwb3J0RWxlbWVudCA9PT0gdGFyZ2V0RWxlbWVudDtcclxuICBjb25zdCB2aWV3cG9ydElzVGFyZ2V0Qm9keSA9IHZpZXdwb3J0SXNUYXJnZXQgJiYgaXNCb2R5O1xyXG4gIGNvbnN0IHBvc3NpYmxlQ29udGVudEVsZW1lbnQgPSAhdmlld3BvcnRJc1RhcmdldCAmJiBnZW5lcmF0ZUNvbnRlbnRFbGVtZW50KGNvbnRlbnRJbml0aWFsaXphdGlvbik7XHJcbiAgLy8gZWRnZSBjYXNlIGlmIHBhc3NlZCB2aWV3cG9ydEVsZW1lbnQgaXMgY29udGVudEVsZW1lbnQ6XHJcbiAgLy8gdmlld3BvcnQgZWxlbWVudCBoYXMgaGlnaGVyIHByaW9yaXR5IGFuZCBjb250ZW50IGVsZW1lbnQgd2lsbCBub3QgYmUgZ2VuZXJhdGVkXHJcbiAgLy8gd2lsbCBhY3QgdGhlIHNhbWUgd2F5IGFzIGluaXRpYWxpemF0aW9uOiBgeyBlbGVtZW50czogeyB2aWV3cG9ydCwgY29udGVudDogZmFsc2UgfSB9YFxyXG4gIGNvbnN0IHZpZXdwb3J0SXNDb250ZW50ID0gIXZpZXdwb3J0SXNUYXJnZXQgJiYgcG9zc2libGVWaWV3cG9ydEVsZW1lbnQgPT09IHBvc3NpYmxlQ29udGVudEVsZW1lbnQ7XHJcbiAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gdmlld3BvcnRJc1RhcmdldEJvZHkgPyBkb2NFbGVtZW50IDogcG9zc2libGVWaWV3cG9ydEVsZW1lbnQ7XHJcbiAgY29uc3QgaG9zdEVsZW1lbnQgPSB2aWV3cG9ydElzVGFyZ2V0Qm9keSA/IHZpZXdwb3J0RWxlbWVudCA6IHRhcmdldEVsZW1lbnQ7XHJcbiAgY29uc3QgcGFkZGluZ0VsZW1lbnQgPVxyXG4gICAgIXZpZXdwb3J0SXNUYXJnZXQgJiZcclxuICAgIGR5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnQoY3JlYXRlTmV3RGl2LCBkZWZhdWx0UGFkZGluZ0luaXRpYWxpemF0aW9uLCBwYWRkaW5nSW5pdGlhbGl6YXRpb24pO1xyXG4gIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gIXZpZXdwb3J0SXNDb250ZW50ICYmIHBvc3NpYmxlQ29udGVudEVsZW1lbnQ7XHJcbiAgY29uc3QgZ2VuZXJhdGVkRWxlbWVudHMgPSBbY29udGVudEVsZW1lbnQsIHZpZXdwb3J0RWxlbWVudCwgcGFkZGluZ0VsZW1lbnQsIGhvc3RFbGVtZW50XS5tYXAoXHJcbiAgICAoZWxtKSA9PiBpc0hUTUxFbGVtZW50KGVsbSkgJiYgIXBhcmVudChlbG0pICYmIGVsbVxyXG4gICk7XHJcbiAgY29uc3QgZWxlbWVudElzR2VuZXJhdGVkID0gKGVsbTogSFRNTEVsZW1lbnQgfCBmYWxzZSkgPT4gZWxtICYmIGluQXJyYXkoZ2VuZXJhdGVkRWxlbWVudHMsIGVsbSk7XHJcbiAgY29uc3Qgb3JpZ2luYWxOb25Cb2R5U2Nyb2xsT2Zmc2V0RWxlbWVudCA9XHJcbiAgICAhZWxlbWVudElzR2VuZXJhdGVkKHZpZXdwb3J0RWxlbWVudCkgJiYgZWxlbWVudEhhc092ZXJmbG93KHZpZXdwb3J0RWxlbWVudClcclxuICAgICAgPyB2aWV3cG9ydEVsZW1lbnRcclxuICAgICAgOiB0YXJnZXRFbGVtZW50O1xyXG4gIGNvbnN0IHNjcm9sbE9mZnNldEVsZW1lbnQgPSB2aWV3cG9ydElzVGFyZ2V0Qm9keSA/IGRvY0VsZW1lbnQgOiB2aWV3cG9ydEVsZW1lbnQ7XHJcbiAgY29uc3Qgc2Nyb2xsRXZlbnRFbGVtZW50ID0gdmlld3BvcnRJc1RhcmdldEJvZHkgPyBvd25lckRvY3VtZW50IDogdmlld3BvcnRFbGVtZW50O1xyXG5cclxuICBjb25zdCBldmFsdWF0ZWRUYXJnZXRPYmo6IFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmogPSB7XHJcbiAgICBfdGFyZ2V0OiB0YXJnZXRFbGVtZW50LFxyXG4gICAgX2hvc3Q6IGhvc3RFbGVtZW50LFxyXG4gICAgX3ZpZXdwb3J0OiB2aWV3cG9ydEVsZW1lbnQsXHJcbiAgICBfcGFkZGluZzogcGFkZGluZ0VsZW1lbnQsXHJcbiAgICBfY29udGVudDogY29udGVudEVsZW1lbnQsXHJcbiAgICBfc2Nyb2xsT2Zmc2V0RWxlbWVudDogc2Nyb2xsT2Zmc2V0RWxlbWVudCxcclxuICAgIF9zY3JvbGxFdmVudEVsZW1lbnQ6IHNjcm9sbEV2ZW50RWxlbWVudCxcclxuICAgIF9vcmlnaW5hbFNjcm9sbE9mZnNldEVsZW1lbnQ6IGlzQm9keSA/IGRvY0VsZW1lbnQgOiBvcmlnaW5hbE5vbkJvZHlTY3JvbGxPZmZzZXRFbGVtZW50LFxyXG4gICAgX2RvY3VtZW50RWxtOiBvd25lckRvY3VtZW50LFxyXG4gICAgX2lzQm9keTogaXNCb2R5LFxyXG4gICAgX3RhcmdldElzRWxtOiB0YXJnZXRJc0VsbSxcclxuICAgIF92aWV3cG9ydElzVGFyZ2V0OiB2aWV3cG9ydElzVGFyZ2V0LFxyXG4gICAgX3dpbmRvd0VsbTogZ2V0RG9jdW1lbnRXaW5kb3csXHJcbiAgICBfdmlld3BvcnRIYXNDbGFzczogKHZpZXdwb3J0QXR0cmlidXRlQ2xhc3NOYW1lOiBzdHJpbmcpID0+XHJcbiAgICAgIGhhc0F0dHJDbGFzcyh2aWV3cG9ydEVsZW1lbnQsIGRhdGFBdHRyaWJ1dGVWaWV3cG9ydCwgdmlld3BvcnRBdHRyaWJ1dGVDbGFzc05hbWUpLFxyXG4gICAgX3ZpZXdwb3J0QWRkUmVtb3ZlQ2xhc3M6ICh2aWV3cG9ydEF0dHJpYnV0ZUNsYXNzTmFtZTogc3RyaW5nLCBhZGQ/OiBib29sZWFuKSA9PlxyXG4gICAgICBhZGRSZW1vdmVBdHRyQ2xhc3Modmlld3BvcnRFbGVtZW50LCBkYXRhQXR0cmlidXRlVmlld3BvcnQsIHZpZXdwb3J0QXR0cmlidXRlQ2xhc3NOYW1lLCBhZGQpLFxyXG4gICAgX3JlbW92ZVNjcm9sbE9ic2N1cmluZ1N0eWxlczogKCkgPT5cclxuICAgICAgYWRkUmVtb3ZlQXR0ckNsYXNzKFxyXG4gICAgICAgIHNjcm9sbE9mZnNldEVsZW1lbnQsXHJcbiAgICAgICAgZGF0YUF0dHJpYnV0ZVZpZXdwb3J0LFxyXG4gICAgICAgIGRhdGFWYWx1ZVZpZXdwb3J0U2Nyb2xsaW5nLFxyXG4gICAgICAgIHRydWVcclxuICAgICAgKSxcclxuICB9O1xyXG4gIGNvbnN0IHsgX3RhcmdldCwgX2hvc3QsIF9wYWRkaW5nLCBfdmlld3BvcnQsIF9jb250ZW50IH0gPSBldmFsdWF0ZWRUYXJnZXRPYmo7XHJcbiAgY29uc3QgZGVzdHJveUZuczogKCgpID0+IHZvaWQpW10gPSBbXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIC8vIGFsd2F5cyByZW1vdmUgZGF0YUF0dHJpYnV0ZUhvc3QgJiBkYXRhQXR0cmlidXRlSW5pdGlhbGl6ZSBmcm9tIGhvc3QgYW5kIGZyb20gPGh0bWw+IGVsZW1lbnQgaWYgdGFyZ2V0IGlzIGJvZHlcclxuICAgICAgcmVtb3ZlQXR0cnMoX2hvc3QsIFtkYXRhQXR0cmlidXRlSG9zdCwgZGF0YUF0dHJpYnV0ZUluaXRpYWxpemVdKTtcclxuICAgICAgcmVtb3ZlQXR0cnMoX3RhcmdldCwgZGF0YUF0dHJpYnV0ZUluaXRpYWxpemUpO1xyXG4gICAgICBpZiAoaXNCb2R5KSB7XHJcbiAgICAgICAgcmVtb3ZlQXR0cnMoZG9jRWxlbWVudCwgW2RhdGFBdHRyaWJ1dGVJbml0aWFsaXplLCBkYXRhQXR0cmlidXRlSG9zdF0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIF07XHJcbiAgbGV0IHRhcmdldENvbnRlbnRzID0gY29udGVudHMoXHJcbiAgICBbX2NvbnRlbnQsIF92aWV3cG9ydCwgX3BhZGRpbmcsIF9ob3N0LCBfdGFyZ2V0XS5maW5kKChlbG0pID0+IGVsbSAmJiAhZWxlbWVudElzR2VuZXJhdGVkKGVsbSkpXHJcbiAgKTtcclxuICBjb25zdCBjb250ZW50U2xvdCA9IHZpZXdwb3J0SXNUYXJnZXRCb2R5ID8gX3RhcmdldCA6IF9jb250ZW50IHx8IF92aWV3cG9ydDtcclxuICBjb25zdCBkZXN0cm95ID0gYmluZChydW5FYWNoQW5kQ2xlYXIsIGRlc3Ryb3lGbnMpO1xyXG4gIGNvbnN0IGFwcGVuZEVsZW1lbnRzID0gKCkgPT4ge1xyXG4gICAgY29uc3QgZG9jV25kID0gZ2V0RG9jdW1lbnRXaW5kb3coKTtcclxuICAgIGNvbnN0IGluaXRBY3RpdmVFbG0gPSBnZXRGb2N1c2VkRWxlbWVudCgpO1xyXG4gICAgY29uc3QgdW53cmFwID0gKGVsbTogSFRNTEVsZW1lbnQgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgYXBwZW5kQ2hpbGRyZW4ocGFyZW50KGVsbSksIGNvbnRlbnRzKGVsbSkpO1xyXG4gICAgICByZW1vdmVFbGVtZW50cyhlbG0pO1xyXG4gICAgfTtcclxuICAgIC8vIHdyYXBwaW5nIC8gdW53cmFwcGluZyB3aWxsIGNhdXNlIHRoZSBmb2N1c2VkIGVsZW1lbnQgdG8gYmx1ciwgdGhpcyBzaG91bGQgcHJldmVudCB0aG9zZSBldmVudHMgdG8gc3VyZmFjZVxyXG4gICAgY29uc3QgcHJlcGFyZVdyYXBVbndyYXBGb2N1cyA9IChhY3RpdmVFbGVtZW50OiBFbGVtZW50IHwgZmFsc2UgfCBudWxsIHwgdW5kZWZpbmVkKSA9PlxyXG4gICAgICBhZGRFdmVudExpc3RlbmVyKGFjdGl2ZUVsZW1lbnQsICdmb2N1c2luIGZvY3Vzb3V0IGZvY3VzIGJsdXInLCBzdG9wQW5kUHJldmVudCwge1xyXG4gICAgICAgIF9jYXB0dXJlOiB0cnVlLFxyXG4gICAgICAgIF9wYXNzaXZlOiBmYWxzZSxcclxuICAgICAgfSk7XHJcbiAgICBjb25zdCB0YWJJbmRleFN0ciA9ICd0YWJpbmRleCc7XHJcbiAgICBjb25zdCBvcmlnaW5hbFZpZXdwb3J0VGFiSW5kZXggPSBnZXRBdHRyKF92aWV3cG9ydCwgdGFiSW5kZXhTdHIpO1xyXG4gICAgY29uc3QgdW5kb0luaXRXcmFwVW5kd3JhcEZvY3VzID0gcHJlcGFyZVdyYXBVbndyYXBGb2N1cyhpbml0QWN0aXZlRWxtKTtcclxuICAgIHNldEF0dHJzKF9ob3N0LCBkYXRhQXR0cmlidXRlSG9zdCwgdmlld3BvcnRJc1RhcmdldCA/ICcnIDogZGF0YVZhbHVlSG9zdElzSG9zdCk7XHJcbiAgICBzZXRBdHRycyhfcGFkZGluZywgZGF0YUF0dHJpYnV0ZVBhZGRpbmcsICcnKTtcclxuICAgIHNldEF0dHJzKF92aWV3cG9ydCwgZGF0YUF0dHJpYnV0ZVZpZXdwb3J0LCAnJyk7XHJcbiAgICBzZXRBdHRycyhfY29udGVudCwgZGF0YUF0dHJpYnV0ZUNvbnRlbnQsICcnKTtcclxuXHJcbiAgICBpZiAoIXZpZXdwb3J0SXNUYXJnZXQpIHtcclxuICAgICAgc2V0QXR0cnMoX3ZpZXdwb3J0LCB0YWJJbmRleFN0ciwgb3JpZ2luYWxWaWV3cG9ydFRhYkluZGV4IHx8ICctMScpO1xyXG4gICAgICBpZiAoaXNCb2R5KSB7XHJcbiAgICAgICAgc2V0QXR0cnMoZG9jRWxlbWVudCwgZGF0YUF0dHJpYnV0ZUh0bWxCb2R5LCAnJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhcHBlbmRDaGlsZHJlbihjb250ZW50U2xvdCwgdGFyZ2V0Q29udGVudHMpO1xyXG4gICAgYXBwZW5kQ2hpbGRyZW4oX2hvc3QsIF9wYWRkaW5nKTtcclxuICAgIGFwcGVuZENoaWxkcmVuKF9wYWRkaW5nIHx8IF9ob3N0LCAhdmlld3BvcnRJc1RhcmdldCAmJiBfdmlld3BvcnQpO1xyXG4gICAgYXBwZW5kQ2hpbGRyZW4oX3ZpZXdwb3J0LCBfY29udGVudCk7XHJcblxyXG4gICAgcHVzaChkZXN0cm95Rm5zLCBbXHJcbiAgICAgIHVuZG9Jbml0V3JhcFVuZHdyYXBGb2N1cyxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lBY3RpdmVFbG0gPSBnZXRGb2N1c2VkRWxlbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SXNHZW5lcmF0ZWQgPSBlbGVtZW50SXNHZW5lcmF0ZWQoX3ZpZXdwb3J0KTtcclxuICAgICAgICAvLyBpZiB0aGUgZm9jdXNlZCBlbGVtZW50IGlzIHZpZXdwb3J0IGFuZCB2aWV3cG9ydCB3aWxsIGJlIGRlc3Ryb3llZCBzaGlmdCB0aGUgZm9jdXMgdG8gdGFyZ2V0XHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGtlZXAgdGhlIGZvY3VzZWQgZWxlbWVudFxyXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lGb2N1c0VsZW1lbnQgPVxyXG4gICAgICAgICAgdmlld3BvcnRJc0dlbmVyYXRlZCAmJiBkZXN0cm95QWN0aXZlRWxtID09PSBfdmlld3BvcnQgPyBfdGFyZ2V0IDogZGVzdHJveUFjdGl2ZUVsbTtcclxuICAgICAgICBjb25zdCB1bmRvRGVzdHJveVdyYXBVbmR3cmFwRm9jdXMgPSBwcmVwYXJlV3JhcFVud3JhcEZvY3VzKGRlc3Ryb3lGb2N1c0VsZW1lbnQpO1xyXG4gICAgICAgIHJlbW92ZUF0dHJzKF9wYWRkaW5nLCBkYXRhQXR0cmlidXRlUGFkZGluZyk7XHJcbiAgICAgICAgcmVtb3ZlQXR0cnMoX2NvbnRlbnQsIGRhdGFBdHRyaWJ1dGVDb250ZW50KTtcclxuICAgICAgICByZW1vdmVBdHRycyhfdmlld3BvcnQsIGRhdGFBdHRyaWJ1dGVWaWV3cG9ydCk7XHJcbiAgICAgICAgaWYgKGlzQm9keSkge1xyXG4gICAgICAgICAgcmVtb3ZlQXR0cnMoZG9jRWxlbWVudCwgZGF0YUF0dHJpYnV0ZUh0bWxCb2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsVmlld3BvcnRUYWJJbmRleCkge1xyXG4gICAgICAgICAgc2V0QXR0cnMoX3ZpZXdwb3J0LCB0YWJJbmRleFN0ciwgb3JpZ2luYWxWaWV3cG9ydFRhYkluZGV4KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVtb3ZlQXR0cnMoX3ZpZXdwb3J0LCB0YWJJbmRleFN0cik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZWxlbWVudElzR2VuZXJhdGVkKF9jb250ZW50KSkge1xyXG4gICAgICAgICAgdW53cmFwKF9jb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZpZXdwb3J0SXNHZW5lcmF0ZWQpIHtcclxuICAgICAgICAgIHVud3JhcChfdmlld3BvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlbWVudElzR2VuZXJhdGVkKF9wYWRkaW5nKSkge1xyXG4gICAgICAgICAgdW53cmFwKF9wYWRkaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvY3VzRWxlbWVudChkZXN0cm95Rm9jdXNFbGVtZW50KTtcclxuICAgICAgICB1bmRvRGVzdHJveVdyYXBVbmR3cmFwRm9jdXMoKTtcclxuICAgICAgfSxcclxuICAgIF0pO1xyXG5cclxuICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZyAmJiAhdmlld3BvcnRJc1RhcmdldCkge1xyXG4gICAgICBhZGRBdHRyQ2xhc3MoX3ZpZXdwb3J0LCBkYXRhQXR0cmlidXRlVmlld3BvcnQsIGRhdGFWYWx1ZVZpZXdwb3J0U2Nyb2xsYmFySGlkZGVuKTtcclxuICAgICAgcHVzaChkZXN0cm95Rm5zLCBiaW5kKHJlbW92ZUF0dHJzLCBfdmlld3BvcnQsIGRhdGFBdHRyaWJ1dGVWaWV3cG9ydCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGtlZXAgdGhlIG9yaWdpbmFsIGZvY3VzZWQgZWxlbWVudCBmb2N1c2VkIGV4Y2VwdCB3aGVuXHJcbiAgICAvLyB0aGUgdGFyZ2V0IGlzIGJvZHkgYW5kIHZpZXdwb3J0IGlzIG5vdCB0YXJnZXQsIHRoZW4gc2hpZnQgdGhlIGZvY3VzIHRvIHRoZSB2aWV3cG9ydCBlbGVtZW50XHJcbiAgICBmb2N1c0VsZW1lbnQoXHJcbiAgICAgICF2aWV3cG9ydElzVGFyZ2V0ICYmIGlzQm9keSAmJiBpbml0QWN0aXZlRWxtID09PSBfdGFyZ2V0ICYmIGRvY1duZC50b3AgPT09IGRvY1duZFxyXG4gICAgICAgID8gX3ZpZXdwb3J0XHJcbiAgICAgICAgOiBpbml0QWN0aXZlRWxtXHJcbiAgICApO1xyXG4gICAgdW5kb0luaXRXcmFwVW5kd3JhcEZvY3VzKCk7XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgdGFyZ2V0Q29udGVudHMgPSAwO1xyXG5cclxuICAgIHJldHVybiBkZXN0cm95O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBbZXZhbHVhdGVkVGFyZ2V0T2JqLCBhcHBlbmRFbGVtZW50cywgZGVzdHJveV07XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgQ3JlYXRlU3RydWN0dXJlVXBkYXRlU2VnbWVudCB9IGZyb20gJy4uL3N0cnVjdHVyZVNldHVwJztcclxuaW1wb3J0IHsgc2V0U3R5bGVzLCBzdHJIZWlnaHQgfSBmcm9tICcuLi8uLi8uLi9zdXBwb3J0JztcclxuXHJcbi8qKlxyXG4gKiBMaWZlY3ljbGUgd2l0aCB0aGUgcmVzcG9uc2liaWxpdHkgdG8gYWRqdXN0IHRoZSB0cmluc2ljIGJlaGF2aW9yIG9mIHRoZSBjb250ZW50IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBzdHJ1Y3R1cmVVcGRhdGVIdWJcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVUcmluc2ljVXBkYXRlU2VnbWVudDogQ3JlYXRlU3RydWN0dXJlVXBkYXRlU2VnbWVudCA9XHJcbiAgKHsgX2NvbnRlbnQgfSkgPT5cclxuICAoeyBfb2JzZXJ2ZXJzVXBkYXRlSGludHMsIF9vYnNlcnZlcnNTdGF0ZSwgX2ZvcmNlIH0pID0+IHtcclxuICAgIGNvbnN0IHsgX2hlaWdodEludHJpbnNpY0NoYW5nZWQgfSA9IF9vYnNlcnZlcnNVcGRhdGVIaW50cyB8fCB7fTtcclxuICAgIGNvbnN0IHsgX2hlaWdodEludHJpbnNpYyB9ID0gX29ic2VydmVyc1N0YXRlO1xyXG4gICAgY29uc3QgaGVpZ2h0SW50cmluc2ljQ2hhbmdlZCA9IF9jb250ZW50ICYmIChfaGVpZ2h0SW50cmluc2ljQ2hhbmdlZCB8fCBfZm9yY2UpO1xyXG5cclxuICAgIGlmIChoZWlnaHRJbnRyaW5zaWNDaGFuZ2VkKSB7XHJcbiAgICAgIHNldFN0eWxlcyhfY29udGVudCwge1xyXG4gICAgICAgIFtzdHJIZWlnaHRdOiBfaGVpZ2h0SW50cmluc2ljICYmICcxMDAlJyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuIiwiaW1wb3J0IHR5cGUgeyBTdHlsZU9iamVjdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xyXG5pbXBvcnQgdHlwZSB7IENyZWF0ZVN0cnVjdHVyZVVwZGF0ZVNlZ21lbnQgfSBmcm9tICcuLi9zdHJ1Y3R1cmVTZXR1cCc7XHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlQ2FjaGUsXHJcbiAgdG9wUmlnaHRCb3R0b21MZWZ0LFxyXG4gIGVxdWFsVFJCTCxcclxuICBhc3NpZ25EZWVwLFxyXG4gIGJpbmQsXHJcbiAgc3RyTWFyZ2luQm90dG9tLFxyXG4gIHN0ck1hcmdpbkxlZnQsXHJcbiAgc3RyTWFyZ2luUmlnaHQsXHJcbiAgc3RyUGFkZGluZ0JvdHRvbSxcclxuICBzdHJQYWRkaW5nTGVmdCxcclxuICBzdHJQYWRkaW5nUmlnaHQsXHJcbiAgc3RyUGFkZGluZ1RvcCxcclxuICBzdHJXaWR0aCxcclxuICBzZXRTdHlsZXMsXHJcbn0gZnJvbSAnLi4vLi4vLi4vc3VwcG9ydCc7XHJcbmltcG9ydCB7IGdldEVudmlyb25tZW50IH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQnO1xyXG5cclxuLyoqXHJcbiAqIExpZmVjeWNsZSB3aXRoIHRoZSByZXNwb25zaWJpbGl0eSB0byBhZGp1c3QgdGhlIHBhZGRpbmcgc3R5bGluZyBvZiB0aGUgcGFkZGluZyBhbmQgdmlld3BvcnQgZWxlbWVudC5cclxuICogQHBhcmFtIHN0cnVjdHVyZVVwZGF0ZUh1YlxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhZGRpbmdVcGRhdGVTZWdtZW50OiBDcmVhdGVTdHJ1Y3R1cmVVcGRhdGVTZWdtZW50ID0gKFxyXG4gIHsgX2hvc3QsIF9wYWRkaW5nLCBfdmlld3BvcnQsIF92aWV3cG9ydElzVGFyZ2V0IH0sXHJcbiAgc3RhdGVcclxuKSA9PiB7XHJcbiAgY29uc3QgW3VwZGF0ZVBhZGRpbmdDYWNoZSwgY3VycmVudFBhZGRpbmdDYWNoZV0gPSBjcmVhdGVDYWNoZShcclxuICAgIHtcclxuICAgICAgX2VxdWFsOiBlcXVhbFRSQkwsXHJcbiAgICAgIF9pbml0aWFsVmFsdWU6IHRvcFJpZ2h0Qm90dG9tTGVmdCgpLFxyXG4gICAgfSxcclxuICAgIGJpbmQodG9wUmlnaHRCb3R0b21MZWZ0LCBfaG9zdCwgJ3BhZGRpbmcnLCAnJylcclxuICApO1xyXG5cclxuICByZXR1cm4gKHsgX2NoZWNrT3B0aW9uLCBfb2JzZXJ2ZXJzVXBkYXRlSGludHMsIF9vYnNlcnZlcnNTdGF0ZSwgX2ZvcmNlIH0pID0+IHtcclxuICAgIGxldCBbcGFkZGluZywgcGFkZGluZ0NoYW5nZWRdID0gY3VycmVudFBhZGRpbmdDYWNoZShfZm9yY2UpO1xyXG4gICAgY29uc3QgeyBfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZyB9ID0gZ2V0RW52aXJvbm1lbnQoKTtcclxuICAgIGNvbnN0IHsgX3NpemVDaGFuZ2VkLCBfY29udGVudE11dGF0aW9uLCBfZGlyZWN0aW9uQ2hhbmdlZCB9ID0gX29ic2VydmVyc1VwZGF0ZUhpbnRzIHx8IHt9O1xyXG4gICAgY29uc3QgeyBfZGlyZWN0aW9uSXNSVEwgfSA9IF9vYnNlcnZlcnNTdGF0ZTtcclxuICAgIGNvbnN0IFtwYWRkaW5nQWJzb2x1dGUsIHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWRdID0gX2NoZWNrT3B0aW9uKCdwYWRkaW5nQWJzb2x1dGUnKTtcclxuICAgIGNvbnN0IGNvbnRlbnRNdXRhdGlvbiA9IF9mb3JjZSB8fCBfY29udGVudE11dGF0aW9uO1xyXG5cclxuICAgIGlmIChfc2l6ZUNoYW5nZWQgfHwgcGFkZGluZ0NoYW5nZWQgfHwgY29udGVudE11dGF0aW9uKSB7XHJcbiAgICAgIFtwYWRkaW5nLCBwYWRkaW5nQ2hhbmdlZF0gPSB1cGRhdGVQYWRkaW5nQ2FjaGUoX2ZvcmNlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYWRkaW5nU3R5bGVDaGFuZ2VkID1cclxuICAgICAgIV92aWV3cG9ydElzVGFyZ2V0ICYmIChwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IF9kaXJlY3Rpb25DaGFuZ2VkIHx8IHBhZGRpbmdDaGFuZ2VkKTtcclxuXHJcbiAgICBpZiAocGFkZGluZ1N0eWxlQ2hhbmdlZCkge1xyXG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBwYWRkaW5nIGVsZW1lbnQgYW5kIG5vIHNjcm9sbGJhciBzdHlsaW5nLCBwYWRkaW5nQWJzb2x1dGUgaXNuJ3Qgc3VwcG9ydGVkXHJcbiAgICAgIGNvbnN0IHBhZGRpbmdSZWxhdGl2ZSA9ICFwYWRkaW5nQWJzb2x1dGUgfHwgKCFfcGFkZGluZyAmJiAhX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmcpO1xyXG4gICAgICBjb25zdCBwYWRkaW5nSG9yaXpvbnRhbCA9IHBhZGRpbmcuciArIHBhZGRpbmcubDtcclxuICAgICAgY29uc3QgcGFkZGluZ1ZlcnRpY2FsID0gcGFkZGluZy50ICsgcGFkZGluZy5iO1xyXG5cclxuICAgICAgY29uc3QgcGFkZGluZ1N0eWxlOiBTdHlsZU9iamVjdCA9IHtcclxuICAgICAgICBbc3RyTWFyZ2luUmlnaHRdOiBwYWRkaW5nUmVsYXRpdmUgJiYgIV9kaXJlY3Rpb25Jc1JUTCA/IC1wYWRkaW5nSG9yaXpvbnRhbCA6IDAsXHJcbiAgICAgICAgW3N0ck1hcmdpbkJvdHRvbV06IHBhZGRpbmdSZWxhdGl2ZSA/IC1wYWRkaW5nVmVydGljYWwgOiAwLFxyXG4gICAgICAgIFtzdHJNYXJnaW5MZWZ0XTogcGFkZGluZ1JlbGF0aXZlICYmIF9kaXJlY3Rpb25Jc1JUTCA/IC1wYWRkaW5nSG9yaXpvbnRhbCA6IDAsXHJcbiAgICAgICAgdG9wOiBwYWRkaW5nUmVsYXRpdmUgPyAtcGFkZGluZy50IDogMCxcclxuICAgICAgICByaWdodDogcGFkZGluZ1JlbGF0aXZlID8gKF9kaXJlY3Rpb25Jc1JUTCA/IC1wYWRkaW5nLnIgOiAnYXV0bycpIDogMCxcclxuICAgICAgICBsZWZ0OiBwYWRkaW5nUmVsYXRpdmUgPyAoX2RpcmVjdGlvbklzUlRMID8gJ2F1dG8nIDogLXBhZGRpbmcubCkgOiAwLFxyXG4gICAgICAgIFtzdHJXaWR0aF06IHBhZGRpbmdSZWxhdGl2ZSAmJiBgY2FsYygxMDAlICsgJHtwYWRkaW5nSG9yaXpvbnRhbH1weClgLFxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCB2aWV3cG9ydFN0eWxlOiBTdHlsZU9iamVjdCA9IHtcclxuICAgICAgICBbc3RyUGFkZGluZ1RvcF06IHBhZGRpbmdSZWxhdGl2ZSA/IHBhZGRpbmcudCA6IDAsXHJcbiAgICAgICAgW3N0clBhZGRpbmdSaWdodF06IHBhZGRpbmdSZWxhdGl2ZSA/IHBhZGRpbmcuciA6IDAsXHJcbiAgICAgICAgW3N0clBhZGRpbmdCb3R0b21dOiBwYWRkaW5nUmVsYXRpdmUgPyBwYWRkaW5nLmIgOiAwLFxyXG4gICAgICAgIFtzdHJQYWRkaW5nTGVmdF06IHBhZGRpbmdSZWxhdGl2ZSA/IHBhZGRpbmcubCA6IDAsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBwYWRkaW5nIGVsZW1lbnQgYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSB2aWV3cG9ydCBlbGVtZW50IGluc3RlYWRcclxuICAgICAgc2V0U3R5bGVzKF9wYWRkaW5nIHx8IF92aWV3cG9ydCwgcGFkZGluZ1N0eWxlKTtcclxuICAgICAgc2V0U3R5bGVzKF92aWV3cG9ydCwgdmlld3BvcnRTdHlsZSk7XHJcblxyXG4gICAgICBhc3NpZ25EZWVwKHN0YXRlLCB7XHJcbiAgICAgICAgX3BhZGRpbmc6IHBhZGRpbmcsXHJcbiAgICAgICAgX3BhZGRpbmdBYnNvbHV0ZTogIXBhZGRpbmdSZWxhdGl2ZSxcclxuICAgICAgICBfdmlld3BvcnRQYWRkaW5nU3R5bGU6IF9wYWRkaW5nXHJcbiAgICAgICAgICA/IHZpZXdwb3J0U3R5bGVcclxuICAgICAgICAgIDogYXNzaWduRGVlcCh7fSwgcGFkZGluZ1N0eWxlLCB2aWV3cG9ydFN0eWxlKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgX3BhZGRpbmdTdHlsZUNoYW5nZWQ6IHBhZGRpbmdTdHlsZUNoYW5nZWQsXHJcbiAgICB9O1xyXG4gIH07XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgU2Nyb2xsQ29vcmRpbmF0ZXMsIFdILCBYWSB9IGZyb20gJy4uLy4uLy4uL3N1cHBvcnQnO1xyXG5pbXBvcnQgdHlwZSB7IFNjcm9sbGJhcnNIaWRpbmdQbHVnaW4gfSBmcm9tICcuLi8uLi8uLi9wbHVnaW5zL3Njcm9sbGJhcnNIaWRpbmdQbHVnaW4nO1xyXG5pbXBvcnQgdHlwZSB7IE92ZXJmbG93U3R5bGUgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcclxuaW1wb3J0IHR5cGUgeyBDcmVhdGVTdHJ1Y3R1cmVVcGRhdGVTZWdtZW50IH0gZnJvbSAnLi4vc3RydWN0dXJlU2V0dXAnO1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZUNhY2hlLFxyXG4gIGdldFNjcm9sbFNpemUsXHJcbiAgZ2V0RnJhY3Rpb25hbFNpemUsXHJcbiAgZXF1YWxXSCxcclxuICBnZXRDbGllbnRTaXplLFxyXG4gIGVxdWFsWFksXHJcbiAgYXNzaWduRGVlcCxcclxuICBiaW5kLFxyXG4gIHduZCxcclxuICBtYXRoTWF4LFxyXG4gIGdldFdpbmRvd1NpemUsXHJcbiAgYWRkUmVtb3ZlQXR0ckNsYXNzLFxyXG4gIGNhcGl0YWxpemVGaXJzdExldHRlcixcclxuICBzZXRTdHlsZXMsXHJcbiAgc3RyVmlzaWJsZSxcclxuICBzdHJIaWRkZW4sXHJcbiAga2V5cyxcclxuICBzdHJTY3JvbGwsXHJcbiAgc2Nyb2xsRWxlbWVudFRvLFxyXG4gIGdldEVsZW1lbnRTY3JvbGwsXHJcbiAgc2FuaXRpemVTY3JvbGxDb29yZGluYXRlcyxcclxuICBnZXRTdHlsZXMsXHJcbiAgZ2V0WmVyb1Njcm9sbENvb3JkaW5hdGVzLFxyXG4gIGhhc0RpbWVuc2lvbnMsXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcixcclxuICBzdG9wUHJvcGFnYXRpb24sXHJcbiAgckFGLFxyXG4gIGhhc0F0dHJDbGFzcyxcclxuICBtYXRoQWJzLFxyXG4gIGVxdWFsLFxyXG4gIGNvbmNhdCxcclxuICBkZWR1cGxpY2F0ZUFycmF5LFxyXG4gIGlzU3RyaW5nLFxyXG59IGZyb20gJy4uLy4uLy4uL3N1cHBvcnQnO1xyXG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudCB9IGZyb20gJy4uLy4uLy4uL2Vudmlyb25tZW50JztcclxuaW1wb3J0IHtcclxuICBkYXRhQXR0cmlidXRlSG9zdCxcclxuICBkYXRhVmFsdWVOb0NsaXBwaW5nLFxyXG4gIGRhdGFWYWx1ZVZpZXdwb3J0U2Nyb2xsYmFySGlkZGVuLFxyXG4gIGRhdGFBdHRyaWJ1dGVQYWRkaW5nLFxyXG4gIGRhdGFWYWx1ZVZpZXdwb3J0T3ZlcmZsb3dYUHJlZml4LFxyXG4gIGRhdGFWYWx1ZVZpZXdwb3J0T3ZlcmZsb3dZUHJlZml4LFxyXG4gIGRhdGFWYWx1ZVZpZXdwb3J0Tm9Db250ZW50LFxyXG4gIGRhdGFWYWx1ZVZpZXdwb3J0TWVhc3VyaW5nLFxyXG59IGZyb20gJy4uLy4uLy4uL2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgeyBnZXRTdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZSwgc2Nyb2xsYmFyc0hpZGluZ1BsdWdpbk5hbWUgfSBmcm9tICcuLi8uLi8uLi9wbHVnaW5zJztcclxuaW1wb3J0IHtcclxuICBnZXRTaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzLFxyXG4gIGdldEVsZW1lbnRPdmVyZmxvd1N0eWxlLFxyXG4gIG92ZXJmbG93QmVoYXZpb3JUb092ZXJmbG93U3R5bGUsXHJcbiAgb3ZlcmZsb3dDc3NWYWx1ZVRvT3ZlcmZsb3dTdHlsZSxcclxuICBvdmVyZmxvd0lzVmlzaWJsZSxcclxufSBmcm9tICcuLi9zdHJ1Y3R1cmVTZXR1cC51dGlscyc7XHJcbmltcG9ydCB7IE92ZXJmbG93QmVoYXZpb3IgfSBmcm9tICcuLi8uLi8uLi9vcHRpb25zJztcclxuXHJcbmludGVyZmFjZSBGbG93RGlyZWN0aW9uU3R5bGVzIHtcclxuICBkaXNwbGF5Pzogc3RyaW5nO1xyXG4gIGRpcmVjdGlvbj86IHN0cmluZztcclxuICBmbGV4RGlyZWN0aW9uPzogc3RyaW5nO1xyXG4gIHdyaXRpbmdNb2RlPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogTGlmZWN5Y2xlIHdpdGggdGhlIHJlc3BvbnNpYmlsaXR5IHRvIHNldCB0aGUgY29ycmVjdCBvdmVyZmxvdyBhbmQgc2Nyb2xsYmFyIGhpZGluZyBzdHlsZXMgb2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBzdHJ1Y3R1cmVVcGRhdGVIdWJcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVPdmVyZmxvd1VwZGF0ZVNlZ21lbnQ6IENyZWF0ZVN0cnVjdHVyZVVwZGF0ZVNlZ21lbnQgPSAoXHJcbiAgc3RydWN0dXJlU2V0dXBFbGVtZW50cyxcclxuICBzdHJ1Y3R1cmVTZXR1cFN0YXRlXHJcbikgPT4ge1xyXG4gIGNvbnN0IGVudiA9IGdldEVudmlyb25tZW50KCk7XHJcbiAgY29uc3Qge1xyXG4gICAgX2hvc3QsXHJcbiAgICBfcGFkZGluZyxcclxuICAgIF92aWV3cG9ydCxcclxuICAgIF92aWV3cG9ydElzVGFyZ2V0LFxyXG4gICAgX3Njcm9sbEV2ZW50RWxlbWVudCxcclxuICAgIF9zY3JvbGxPZmZzZXRFbGVtZW50LFxyXG4gICAgX2lzQm9keSxcclxuICAgIF92aWV3cG9ydEFkZFJlbW92ZUNsYXNzLFxyXG4gICAgX3dpbmRvd0VsbSxcclxuICB9ID0gc3RydWN0dXJlU2V0dXBFbGVtZW50cztcclxuICBjb25zdCB7IF9uYXRpdmVTY3JvbGxiYXJzSGlkaW5nIH0gPSBlbnY7XHJcbiAgY29uc3Qgdmlld3BvcnRJc1RhcmdldEJvZHkgPSBfaXNCb2R5ICYmIF92aWV3cG9ydElzVGFyZ2V0O1xyXG4gIGNvbnN0IG1heDAgPSBiaW5kKG1hdGhNYXgsIDApO1xyXG4gIGNvbnN0IGZsb3dEaXJlY3Rpb25DYW5CZU5vbkRlZmF1bHRNYXA6IFJlY29yZDxcclxuICAgIGtleW9mIEZsb3dEaXJlY3Rpb25TdHlsZXMsXHJcbiAgICAoc3R5bGVWYWx1ZTogc3RyaW5nKSA9PiBib29sZWFuXHJcbiAgPiA9IHtcclxuICAgIGRpc3BsYXk6ICgpID0+IGZhbHNlLFxyXG4gICAgZGlyZWN0aW9uOiAoZGlyZWN0aW9uU3R5bGUpID0+IGRpcmVjdGlvblN0eWxlICE9PSAnbHRyJyxcclxuICAgIGZsZXhEaXJlY3Rpb246IChmbGV4RGlyZWN0aW9uU3R5bGUpID0+IGZsZXhEaXJlY3Rpb25TdHlsZS5lbmRzV2l0aCgnLXJldmVyc2UnKSxcclxuICAgIHdyaXRpbmdNb2RlOiAod3JpdGluZ01vZGVTdHlsZSkgPT4gd3JpdGluZ01vZGVTdHlsZSAhPT0gJ2hvcml6b250YWwtdGInLFxyXG4gIH07XHJcbiAgY29uc3QgZmxvd0RpcmVjdGlvblN0eWxlQXJyID0ga2V5cyhmbG93RGlyZWN0aW9uQ2FuQmVOb25EZWZhdWx0TWFwKSBhcyBBcnJheTxcclxuICAgIGtleW9mIEZsb3dEaXJlY3Rpb25TdHlsZXNcclxuICA+O1xyXG4gIGNvbnN0IHdoQ2FjaGVPcHRpb25zID0ge1xyXG4gICAgX2VxdWFsOiBlcXVhbFdILFxyXG4gICAgX2luaXRpYWxWYWx1ZTogeyB3OiAwLCBoOiAwIH0sXHJcbiAgfTtcclxuICBjb25zdCBwYXJ0aWFsWFlPcHRpb25zID0ge1xyXG4gICAgX2VxdWFsOiBlcXVhbFhZLFxyXG4gICAgX2luaXRpYWxWYWx1ZToge30sXHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2V0TWVhc3VyaW5nTW9kZSA9IChhY3RpdmU6IGJvb2xlYW4pID0+IHtcclxuICAgIC8vIHZpZXdwb3J0SXNUYXJnZXRCb2R5IG5ldmVyIG5lZWRzIG1lYXN1cmluZ1xyXG4gICAgX3ZpZXdwb3J0QWRkUmVtb3ZlQ2xhc3MoZGF0YVZhbHVlVmlld3BvcnRNZWFzdXJpbmcsICF2aWV3cG9ydElzVGFyZ2V0Qm9keSAmJiBhY3RpdmUpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldEZsb3dEaXJlY3Rpb25TdHlsZXMgPSAoKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPT5cclxuICAgIGdldFN0eWxlcyhfdmlld3BvcnQsIGZsb3dEaXJlY3Rpb25TdHlsZUFycik7XHJcbiAgY29uc3QgZ2V0TWVhc3VyZWRTY3JvbGxDb29yZGluYXRlcyA9IChcclxuICAgIGZsb3dEaXJlY3Rpb25TdHlsZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxyXG4gICAgZmxvd0RpcmVjdGlvblN0eWxlc0lzRm9yZWlnbjogYm9vbGVhblxyXG4gICkgPT4ge1xyXG4gICAgY29uc3Qgc2tpcE5vbkRlZmF1bHRTY3JvbGxDb29yZGluYXRlc0NoZWNrID0gIWtleXMoZmxvd0RpcmVjdGlvblN0eWxlcykubGVuZ3RoO1xyXG4gICAgY29uc3QgZmxvd0RpcmVjdGlvblN0eWxlc0luZGljYXRlTm9uRGVmYXVsdEZsb3dEaXJlY3Rpb24gPVxyXG4gICAgICAhZmxvd0RpcmVjdGlvblN0eWxlc0lzRm9yZWlnbiAmJlxyXG4gICAgICBmbG93RGlyZWN0aW9uU3R5bGVBcnIuc29tZSgoc3R5bGVOYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVWYWx1ZSA9IGZsb3dEaXJlY3Rpb25TdHlsZXNbc3R5bGVOYW1lXTtcclxuICAgICAgICByZXR1cm4gaXNTdHJpbmcoc3R5bGVWYWx1ZSkgJiYgZmxvd0RpcmVjdGlvbkNhbkJlTm9uRGVmYXVsdE1hcFtzdHlsZU5hbWVdKHN0eWxlVmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIGNvbnN0IGZsb3dEaXJlY3Rpb25Jc0RlZmF1bHQgPVxyXG4gICAgICBza2lwTm9uRGVmYXVsdFNjcm9sbENvb3JkaW5hdGVzQ2hlY2sgJiYgIWZsb3dEaXJlY3Rpb25TdHlsZXNJbmRpY2F0ZU5vbkRlZmF1bHRGbG93RGlyZWN0aW9uO1xyXG5cclxuICAgIC8vIGlmIHRoZSBkaXJlY3Rpb24gaXMgZGVmYXVsdCBvciB0aGUgZWxlbWVudCBoYXMgbm8gZGltZW5zaW9ucyByZXR1cm4gZGVmYXVsdCBzY3JvbGwgY29vcmRpbmF0ZXMgKG9ubHkgdGhlIHNpZ24gb2YgdGhlIG51bWJlcnMgbWF0dGVycylcclxuICAgIGlmIChmbG93RGlyZWN0aW9uSXNEZWZhdWx0IHx8ICFoYXNEaW1lbnNpb25zKF92aWV3cG9ydCkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBfc3RhcnQ6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgIF9lbmQ6IHsgeDogMSwgeTogMSB9LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHNldE1lYXN1cmluZ01vZGUodHJ1ZSk7XHJcblxyXG4gICAgY29uc3Qgb3JpZ2luYWxTY3JvbGxPZmZzZXQgPSBnZXRFbGVtZW50U2Nyb2xsKF9zY3JvbGxPZmZzZXRFbGVtZW50KTtcclxuICAgIGNvbnN0IHJlbW92ZU5vQ29udGVudCA9IF92aWV3cG9ydEFkZFJlbW92ZUNsYXNzKGRhdGFWYWx1ZVZpZXdwb3J0Tm9Db250ZW50LCB0cnVlKTtcclxuICAgIGNvbnN0IHJlbW92ZVNjcm9sbEJsb2NrID0gYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgX3Njcm9sbEV2ZW50RWxlbWVudCxcclxuICAgICAgc3RyU2Nyb2xsLFxyXG4gICAgICAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBzY3JvbGxFdmVudFNjcm9sbE9mZnNldCA9IGdldEVsZW1lbnRTY3JvbGwoX3Njcm9sbE9mZnNldEVsZW1lbnQpO1xyXG4gICAgICAgIC8vIGlmIHNjcm9sbCBvZmZzZXQgZGlkbnQgY2hhbmdlXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZXZlbnQuaXNUcnVzdGVkICYmXHJcbiAgICAgICAgICBzY3JvbGxFdmVudFNjcm9sbE9mZnNldC54ID09PSBvcmlnaW5hbFNjcm9sbE9mZnNldC54ICYmXHJcbiAgICAgICAgICBzY3JvbGxFdmVudFNjcm9sbE9mZnNldC55ID09PSBvcmlnaW5hbFNjcm9sbE9mZnNldC55XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIF9jYXB0dXJlOiB0cnVlLFxyXG4gICAgICAgIF9vbmNlOiB0cnVlLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHNjcm9sbEVsZW1lbnRUbyhfc2Nyb2xsT2Zmc2V0RWxlbWVudCwge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwLFxyXG4gICAgfSk7XHJcbiAgICByZW1vdmVOb0NvbnRlbnQoKTtcclxuXHJcbiAgICBjb25zdCBfc3RhcnQgPSBnZXRFbGVtZW50U2Nyb2xsKF9zY3JvbGxPZmZzZXRFbGVtZW50KTtcclxuICAgIGNvbnN0IHNjcm9sbFNpemUgPSBnZXRTY3JvbGxTaXplKF9zY3JvbGxPZmZzZXRFbGVtZW50KTtcclxuICAgIHNjcm9sbEVsZW1lbnRUbyhfc2Nyb2xsT2Zmc2V0RWxlbWVudCwge1xyXG4gICAgICB4OiBzY3JvbGxTaXplLncsXHJcbiAgICAgIHk6IHNjcm9sbFNpemUuaCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcG9zaXRpdmVTY3JvbGwgPSBnZXRFbGVtZW50U2Nyb2xsKF9zY3JvbGxPZmZzZXRFbGVtZW50KTtcclxuICAgIGNvbnN0IHBvc2l0aXZlRGlzdGFuY2UgPSB7XHJcbiAgICAgIHg6IHBvc2l0aXZlU2Nyb2xsLnggLSBfc3RhcnQueCxcclxuICAgICAgeTogcG9zaXRpdmVTY3JvbGwueSAtIF9zdGFydC55LFxyXG4gICAgfTtcclxuXHJcbiAgICBzY3JvbGxFbGVtZW50VG8oX3Njcm9sbE9mZnNldEVsZW1lbnQsIHtcclxuICAgICAgeDogLXNjcm9sbFNpemUudyxcclxuICAgICAgeTogLXNjcm9sbFNpemUuaCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbmVnYXRpdmVTY3JvbGwgPSBnZXRFbGVtZW50U2Nyb2xsKF9zY3JvbGxPZmZzZXRFbGVtZW50KTtcclxuICAgIGNvbnN0IG5lZ2F0aXZlRGlzdGFuY2UgPSB7XHJcbiAgICAgIHg6IG5lZ2F0aXZlU2Nyb2xsLnggLSBfc3RhcnQueCxcclxuICAgICAgeTogbmVnYXRpdmVTY3JvbGwueSAtIF9zdGFydC55LFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0YWtlIHRoZSBzY3JvbGwgcG9zaXRpb25zIHdoaWNoIHNjcm9sbGVkIHRoZSBncmVhdGVzdCBkaXN0YW5jZVxyXG4gICAgLy8gYmVjYXVzZSBvZjogaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhL092ZXJsYXlTY3JvbGxiYXJzL2lzc3Vlcy82MjUjaXNzdWVjb21tZW50LTM3NzgwNDg5MzZcclxuICAgIC8vIHRoaXMgbG9naWMgaXMgaW4gcGxhY2UgZHVlIHRvIHJvdW5kaW5nIGlzc3VlcyBvZiB0aGUgYHNjcm9sbFRvcGAgLyBgc2Nyb2xsTGVmdGAgcHJvcGVydGllc1xyXG4gICAgLy8gaXRzIHBvc3NpYmxlIHRoYXQgZXZlbiBpZiB0aGUgc2Nyb2xsIGNvb3JkaW5hdGVzIGFyZSBlZmZlY3RpdmVseSAwLi4tMTAwIHRoZSBzY3JvbGwgdmFsdWUgaXMgMSB3aGljaCBpcyBvdXRzaWRlIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgLy8gdGhpcyBoYXBwZW5zIGJlY2F1c2UgdGhlIGJyb3dzZXIgcm91bmRzIHRoZSB2YWx1ZSB0byAxIGV2ZW4gaWYgaXQgc2hvdWxkIGJlIDBcclxuICAgIGNvbnN0IF9lbmQgPSB7XHJcbiAgICAgIHg6XHJcbiAgICAgICAgbWF0aEFicyhwb3NpdGl2ZURpc3RhbmNlLngpID49IG1hdGhBYnMobmVnYXRpdmVEaXN0YW5jZS54KVxyXG4gICAgICAgICAgPyBwb3NpdGl2ZVNjcm9sbC54XHJcbiAgICAgICAgICA6IG5lZ2F0aXZlU2Nyb2xsLngsXHJcbiAgICAgIHk6XHJcbiAgICAgICAgbWF0aEFicyhwb3NpdGl2ZURpc3RhbmNlLnkpID49IG1hdGhBYnMobmVnYXRpdmVEaXN0YW5jZS55KVxyXG4gICAgICAgICAgPyBwb3NpdGl2ZVNjcm9sbC55XHJcbiAgICAgICAgICA6IG5lZ2F0aXZlU2Nyb2xsLnksXHJcbiAgICB9O1xyXG4gICAgc2Nyb2xsRWxlbWVudFRvKF9zY3JvbGxPZmZzZXRFbGVtZW50LCBvcmlnaW5hbFNjcm9sbE9mZnNldCk7XHJcbiAgICByQUYoKCkgPT4gcmVtb3ZlU2Nyb2xsQmxvY2soKSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgX3N0YXJ0LFxyXG4gICAgICBfZW5kLFxyXG4gICAgfTtcclxuICB9O1xyXG4gIGNvbnN0IGdldE92ZXJmbG93QW1vdW50ID0gKFxyXG4gICAgdmlld3BvcnRTY3JvbGxTaXplOiBXSDxudW1iZXI+LFxyXG4gICAgdmlld3BvcnRDbGllbnRTaXplOiBXSDxudW1iZXI+XHJcbiAgKTogV0g8bnVtYmVyPiA9PiB7XHJcbiAgICBjb25zdCB0b2xsZXJhbmNlID0gd25kLmRldmljZVBpeGVsUmF0aW8gJSAxICE9PSAwID8gMSA6IDA7XHJcbiAgICBjb25zdCBhbW91bnQgPSB7XHJcbiAgICAgIHc6IG1heDAodmlld3BvcnRTY3JvbGxTaXplLncgLSB2aWV3cG9ydENsaWVudFNpemUudyksXHJcbiAgICAgIGg6IG1heDAodmlld3BvcnRTY3JvbGxTaXplLmggLSB2aWV3cG9ydENsaWVudFNpemUuaCksXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHc6IGFtb3VudC53ID4gdG9sbGVyYW5jZSA/IGFtb3VudC53IDogMCxcclxuICAgICAgaDogYW1vdW50LmggPiB0b2xsZXJhbmNlID8gYW1vdW50LmggOiAwLFxyXG4gICAgfTtcclxuICB9O1xyXG4gIGNvbnN0IGdldFZpZXdwb3J0T3ZlcmZsb3dTdHlsZSA9IChcclxuICAgIGhhc092ZXJmbG93OiBQYXJ0aWFsPFhZPGJvb2xlYW4+PixcclxuICAgIG92ZXJmbG93QmVoYXZpb3I6IFhZPE92ZXJmbG93QmVoYXZpb3I+XHJcbiAgKTogWFk8T3ZlcmZsb3dTdHlsZT4gPT4ge1xyXG4gICAgY29uc3QgZ2V0QXhpc092ZXJmbG93U3R5bGUgPSAoXHJcbiAgICAgIGF4aXNCZWhhdmlvcjogT3ZlcmZsb3dCZWhhdmlvcixcclxuICAgICAgYXhpc0hhc092ZXJmbG93OiBib29sZWFuIHwgdW5kZWZpbmVkLFxyXG4gICAgICBwZXJwZW5kaWN1bGFyQmVoYXZpb3I6IE92ZXJmbG93QmVoYXZpb3IsXHJcbiAgICAgIHBlcnBlbmRpY3VsYXJPdmVyZmxvdzogYm9vbGVhbiB8IHVuZGVmaW5lZFxyXG4gICAgKTogT3ZlcmZsb3dTdHlsZSA9PiB7XHJcbiAgICAgIC8vIGNvbnZlcnQgYmVoYXZpb3IgdG8gc3R5bGU6XHJcbiAgICAgIC8vICd2aXNpYmxlJyAgICAgICAgLT4gJ2hpZGRlbidcclxuICAgICAgLy8gJ2hpZGRlbicgICAgICAgICAtPiAnaGlkZGVuJ1xyXG4gICAgICAvLyAnc2Nyb2xsJyAgICAgICAgIC0+ICdzY3JvbGwnXHJcbiAgICAgIC8vICd2aXNpYmxlLWhpZGRlbicgLT4gJ2hpZGRlbidcclxuICAgICAgLy8gJ3Zpc2libGUtc2Nyb2xsJyAtPiAnc2Nyb2xsJ1xyXG4gICAgICBjb25zdCBiZWhhdmlvclN0eWxlID1cclxuICAgICAgICBheGlzQmVoYXZpb3IgPT09IHN0clZpc2libGUgPyBzdHJIaWRkZW4gOiBvdmVyZmxvd0JlaGF2aW9yVG9PdmVyZmxvd1N0eWxlKGF4aXNCZWhhdmlvcik7XHJcbiAgICAgIGNvbnN0IGF4aXNPdmVyZmxvd1Zpc2libGUgPSBvdmVyZmxvd0lzVmlzaWJsZShheGlzQmVoYXZpb3IpO1xyXG4gICAgICBjb25zdCBwZXJwZW5kaWN1bGFyT3ZlcmZsb3dWaXNpYmxlID0gb3ZlcmZsb3dJc1Zpc2libGUocGVycGVuZGljdWxhckJlaGF2aW9yKTtcclxuXHJcbiAgICAgIC8vIGlmIG5vIGF4aXMgaGFzIG92ZXJmbG93IHNldCAnaGlkZGVuJ1xyXG4gICAgICBpZiAoIWF4aXNIYXNPdmVyZmxvdyAmJiAhcGVycGVuZGljdWxhck92ZXJmbG93KSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ckhpZGRlbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgYm90aCBheGlzIGhhdmUgYSB2aXNpYmxlIGJlaGF2aW9yICgndmlzaWJsZScsICd2aXNpYmxlLWhpZGRlbicsICd2aXNpYmxlLXNjcm9sbCcpIHNldCAndmlzaWJsZSdcclxuICAgICAgaWYgKGF4aXNPdmVyZmxvd1Zpc2libGUgJiYgcGVycGVuZGljdWxhck92ZXJmbG93VmlzaWJsZSkge1xyXG4gICAgICAgIHJldHVybiBzdHJWaXNpYmxlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0aGlzIHRoaXMgYXhpcyBoYXMgYSB2aXNpYmxlIGJlaGF2aW9yXHJcbiAgICAgIGlmIChheGlzT3ZlcmZsb3dWaXNpYmxlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9uUGVycGVuZGljdWxhck92ZXJmbG93ID0gYXhpc0hhc092ZXJmbG93ID8gc3RyVmlzaWJsZSA6IHN0ckhpZGRlbjtcclxuICAgICAgICByZXR1cm4gYXhpc0hhc092ZXJmbG93ICYmIHBlcnBlbmRpY3VsYXJPdmVyZmxvd1xyXG4gICAgICAgICAgPyBiZWhhdmlvclN0eWxlIC8vIGlmIGJvdGggYXhpcyBoYXZlIGFuIG92ZXJmbG93IHNldCAoJ2hpZGRlbicgb3IgJ3Njcm9sbCcpXHJcbiAgICAgICAgICA6IG5vblBlcnBlbmRpY3VsYXJPdmVyZmxvdzsgLy8gaWYgb25seSB0aGlzIGF4aXMgaGFzIGFuIG92ZXJmbG93IHNldCAndmlzaWJsZScsIGlmIG5vIGF4aXMgaGFzIGFuIG92ZXJmbG93IHNldCAnaGlkZGVuJ1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBub25PdmVyZmxvdyA9XHJcbiAgICAgICAgcGVycGVuZGljdWxhck92ZXJmbG93VmlzaWJsZSAmJiBwZXJwZW5kaWN1bGFyT3ZlcmZsb3cgPyBzdHJWaXNpYmxlIDogc3RySGlkZGVuO1xyXG4gICAgICByZXR1cm4gYXhpc0hhc092ZXJmbG93XHJcbiAgICAgICAgPyBiZWhhdmlvclN0eWxlIC8vIGlmIHRoaXMgYXhpcyBoYXMgYW4gb3ZlcmZsb3dcclxuICAgICAgICA6IG5vbk92ZXJmbG93OyAvLyBpZiB0aGUgcGVycC4gYXhpcyBoYXMgYSB2aXNpYmxlIGJlaGF2aW9yIGFuZCBoYXMgYW4gb3ZlcmZsb3cgc2V0ICd2aXNpYmxlJywgb3RoZXJ3aXNlIHNldCAnaGlkZGVuJ1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBnZXRBeGlzT3ZlcmZsb3dTdHlsZShvdmVyZmxvd0JlaGF2aW9yLngsIGhhc092ZXJmbG93LngsIG92ZXJmbG93QmVoYXZpb3IueSwgaGFzT3ZlcmZsb3cueSksXHJcbiAgICAgIHk6IGdldEF4aXNPdmVyZmxvd1N0eWxlKG92ZXJmbG93QmVoYXZpb3IueSwgaGFzT3ZlcmZsb3cueSwgb3ZlcmZsb3dCZWhhdmlvci54LCBoYXNPdmVyZmxvdy54KSxcclxuICAgIH07XHJcbiAgfTtcclxuICBjb25zdCBzZXRWaWV3cG9ydE92ZXJmbG93U3R5bGUgPSAodmlld3BvcnRPdmVyZmxvd1N0eWxlOiBYWTxPdmVyZmxvd1N0eWxlPikgPT4ge1xyXG4gICAgLy8gYGNyZWF0ZUFsbE92ZXJmbG93U3R5bGVDbGFzc05hbWVzYCBhbmQgYGFsbE92ZXJmbG93U3R5bGVDbGFzc05hbWVzYCBjb3VsZCBiZSBvbmUgc2NvcGUgZnVydGhlciB1cCBidXQgd291bGQgaW5jcmVhc2UgYnVuZGxlIHNpemVcclxuICAgIGNvbnN0IGNyZWF0ZUFsbE92ZXJmbG93U3R5bGVDbGFzc05hbWVzID0gKGlzSG9yaXpvbnRhbD86IGJvb2xlYW4pID0+XHJcbiAgICAgIFtzdHJWaXNpYmxlLCBzdHJIaWRkZW4sIHN0clNjcm9sbF0ubWFwKChzdHlsZSkgPT5cclxuICAgICAgICBjcmVhdGVWaWV3cG9ydE92ZXJmbG93U3R5bGVDbGFzc05hbWUob3ZlcmZsb3dDc3NWYWx1ZVRvT3ZlcmZsb3dTdHlsZShzdHlsZSksIGlzSG9yaXpvbnRhbClcclxuICAgICAgKTtcclxuICAgIGNvbnN0IGFsbE92ZXJmbG93U3R5bGVDbGFzc05hbWVzID0gY3JlYXRlQWxsT3ZlcmZsb3dTdHlsZUNsYXNzTmFtZXModHJ1ZSlcclxuICAgICAgLmNvbmNhdChjcmVhdGVBbGxPdmVyZmxvd1N0eWxlQ2xhc3NOYW1lcygpKVxyXG4gICAgICAuam9pbignICcpO1xyXG5cclxuICAgIF92aWV3cG9ydEFkZFJlbW92ZUNsYXNzKGFsbE92ZXJmbG93U3R5bGVDbGFzc05hbWVzKTtcclxuICAgIF92aWV3cG9ydEFkZFJlbW92ZUNsYXNzKFxyXG4gICAgICAoa2V5cyh2aWV3cG9ydE92ZXJmbG93U3R5bGUpIGFzIEFycmF5PGtleW9mIHR5cGVvZiB2aWV3cG9ydE92ZXJmbG93U3R5bGU+KVxyXG4gICAgICAgIC5tYXAoKGF4aXMpID0+XHJcbiAgICAgICAgICBjcmVhdGVWaWV3cG9ydE92ZXJmbG93U3R5bGVDbGFzc05hbWUodmlld3BvcnRPdmVyZmxvd1N0eWxlW2F4aXNdLCBheGlzID09PSAneCcpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5qb2luKCcgJyksXHJcbiAgICAgIHRydWVcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgW3VwZGF0ZVNpemVGcmFjdGlvbiwgZ2V0Q3VycmVudFNpemVGcmFjdGlvbl0gPSBjcmVhdGVDYWNoZTxXSDxudW1iZXI+PihcclxuICAgIHdoQ2FjaGVPcHRpb25zLFxyXG4gICAgYmluZChnZXRGcmFjdGlvbmFsU2l6ZSwgX3ZpZXdwb3J0KVxyXG4gICk7XHJcbiAgY29uc3QgW3VwZGF0ZVZpZXdwb3J0U2Nyb2xsU2l6ZUNhY2hlLCBnZXRDdXJyZW50Vmlld3BvcnRTY3JvbGxTaXplQ2FjaGVdID0gY3JlYXRlQ2FjaGU8XHJcbiAgICBXSDxudW1iZXI+XHJcbiAgPih3aENhY2hlT3B0aW9ucywgYmluZChnZXRTY3JvbGxTaXplLCBfdmlld3BvcnQpKTtcclxuICBjb25zdCBbdXBkYXRlT3ZlcmZsb3dBbW91bnRDYWNoZSwgZ2V0Q3VycmVudE92ZXJmbG93QW1vdW50Q2FjaGVdID1cclxuICAgIGNyZWF0ZUNhY2hlPFdIPG51bWJlcj4+KHdoQ2FjaGVPcHRpb25zKTtcclxuICBjb25zdCBbdXBkYXRlSGFzT3ZlcmZsb3dDYWNoZV0gPSBjcmVhdGVDYWNoZTxQYXJ0aWFsPFhZPGJvb2xlYW4+Pj4ocGFydGlhbFhZT3B0aW9ucyk7XHJcbiAgY29uc3QgW3VwZGF0ZU92ZXJmbG93RWRnZSwgZ2V0Q3VycmVudE92ZXJmbG93RWRnZUNhY2hlXSA9IGNyZWF0ZUNhY2hlPFdIPG51bWJlcj4+KHdoQ2FjaGVPcHRpb25zKTtcclxuICBjb25zdCBbdXBkYXRlT3ZlcmZsb3dTdHlsZUNhY2hlXSA9IGNyZWF0ZUNhY2hlPFBhcnRpYWw8WFk8T3ZlcmZsb3dTdHlsZT4+PihwYXJ0aWFsWFlPcHRpb25zKTtcclxuICBjb25zdCBbdXBkYXRlTm9uRGVmYXVsdEZsb3dEaXJlY3Rpb25TdHlsZXNdID0gY3JlYXRlQ2FjaGU8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KHtcclxuICAgIF9lcXVhbDogKGN1cnJWYWwsIG5ld1ZhbCkgPT5cclxuICAgICAgZXF1YWwoY3VyclZhbCwgbmV3VmFsLCBkZWR1cGxpY2F0ZUFycmF5KGNvbmNhdChrZXlzKGN1cnJWYWwpLCBrZXlzKG5ld1ZhbCkpKSksXHJcbiAgICBfaW5pdGlhbFZhbHVlOiB7fSxcclxuICB9KTtcclxuICBjb25zdCBbdXBkYXRlTWVhc3VyZWRTY3JvbGxDb29yZGluYXRlcywgZ2V0Q3VycmVudE1lYXN1cmVkU2Nyb2xsQ29vcmRpbmF0ZXNdID1cclxuICAgIGNyZWF0ZUNhY2hlPFNjcm9sbENvb3JkaW5hdGVzPih7XHJcbiAgICAgIF9lcXVhbDogKGN1cnJWYWwsIG5ld1ZhbCkgPT5cclxuICAgICAgICBlcXVhbFhZKGN1cnJWYWwuX3N0YXJ0LCBuZXdWYWwuX3N0YXJ0KSAmJiBlcXVhbFhZKGN1cnJWYWwuX2VuZCwgbmV3VmFsLl9lbmQpLFxyXG4gICAgICBfaW5pdGlhbFZhbHVlOiBnZXRaZXJvU2Nyb2xsQ29vcmRpbmF0ZXMoKSxcclxuICAgIH0pO1xyXG5cclxuICBjb25zdCBzY3JvbGxiYXJzSGlkaW5nUGx1Z2luID0gZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2U8dHlwZW9mIFNjcm9sbGJhcnNIaWRpbmdQbHVnaW4+KFxyXG4gICAgc2Nyb2xsYmFyc0hpZGluZ1BsdWdpbk5hbWVcclxuICApO1xyXG5cclxuICBjb25zdCBjcmVhdGVWaWV3cG9ydE92ZXJmbG93U3R5bGVDbGFzc05hbWUgPSAoXHJcbiAgICBvdmVyZmxvd1N0eWxlOiBPdmVyZmxvd1N0eWxlLFxyXG4gICAgaXNIb3Jpem9udGFsPzogYm9vbGVhblxyXG4gICkgPT4ge1xyXG4gICAgY29uc3QgcHJlZml4ID0gaXNIb3Jpem9udGFsXHJcbiAgICAgID8gZGF0YVZhbHVlVmlld3BvcnRPdmVyZmxvd1hQcmVmaXhcclxuICAgICAgOiBkYXRhVmFsdWVWaWV3cG9ydE92ZXJmbG93WVByZWZpeDtcclxuICAgIHJldHVybiBgJHtwcmVmaXh9JHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIob3ZlcmZsb3dTdHlsZSl9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgeyBfY2hlY2tPcHRpb24sIF9vYnNlcnZlcnNVcGRhdGVIaW50cywgX29ic2VydmVyc1N0YXRlLCBfZm9yY2UgfSxcclxuICAgIHsgX3BhZGRpbmdTdHlsZUNoYW5nZWQgfVxyXG4gICkgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBfc2l6ZUNoYW5nZWQsXHJcbiAgICAgIF9ob3N0TXV0YXRpb24sXHJcbiAgICAgIF9jb250ZW50TXV0YXRpb24sXHJcbiAgICAgIF9kaXJlY3Rpb25DaGFuZ2VkLFxyXG4gICAgICBfYXBwZWFyLFxyXG4gICAgICBfc2Nyb2xsYmFyU2l6ZUNoYW5nZWQsXHJcbiAgICB9ID0gX29ic2VydmVyc1VwZGF0ZUhpbnRzIHx8IHt9O1xyXG4gICAgY29uc3Qgc2Nyb2xsYmFyc0hpZGluZ1BsdWdpblZpZXdwb3J0QXJyYW5nZW1lbnQgPVxyXG4gICAgICBzY3JvbGxiYXJzSGlkaW5nUGx1Z2luICYmXHJcbiAgICAgIHNjcm9sbGJhcnNIaWRpbmdQbHVnaW4uX3ZpZXdwb3J0QXJyYW5nZW1lbnQoXHJcbiAgICAgICAgc3RydWN0dXJlU2V0dXBFbGVtZW50cyxcclxuICAgICAgICBzdHJ1Y3R1cmVTZXR1cFN0YXRlLFxyXG4gICAgICAgIF9vYnNlcnZlcnNTdGF0ZSxcclxuICAgICAgICBlbnYsXHJcbiAgICAgICAgX2NoZWNrT3B0aW9uXHJcbiAgICAgICk7XHJcblxyXG4gICAgY29uc3QgeyBfYXJyYW5nZVZpZXdwb3J0LCBfdW5kb1ZpZXdwb3J0QXJyYW5nZSwgX2hpZGVOYXRpdmVTY3JvbGxiYXJzIH0gPVxyXG4gICAgICBzY3JvbGxiYXJzSGlkaW5nUGx1Z2luVmlld3BvcnRBcnJhbmdlbWVudCB8fCB7fTtcclxuXHJcbiAgICBjb25zdCBbc2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFycywgc2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFyc0NoYW5nZWRdID1cclxuICAgICAgZ2V0U2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFycyhfY2hlY2tPcHRpb24sIGVudik7XHJcbiAgICBjb25zdCBbb3ZlcmZsb3csIG92ZXJmbG93Q2hhbmdlZF0gPSBfY2hlY2tPcHRpb24oJ292ZXJmbG93Jyk7XHJcbiAgICBjb25zdCBvdmVyZmxvd1hWaXNpYmxlID0gb3ZlcmZsb3dJc1Zpc2libGUob3ZlcmZsb3cueCk7XHJcbiAgICBjb25zdCBvdmVyZmxvd1lWaXNpYmxlID0gb3ZlcmZsb3dJc1Zpc2libGUob3ZlcmZsb3cueSk7XHJcblxyXG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID1cclxuICAgICAgX3NpemVDaGFuZ2VkIHx8XHJcbiAgICAgIF9wYWRkaW5nU3R5bGVDaGFuZ2VkIHx8XHJcbiAgICAgIF9jb250ZW50TXV0YXRpb24gfHxcclxuICAgICAgX2RpcmVjdGlvbkNoYW5nZWQgfHxcclxuICAgICAgX3Njcm9sbGJhclNpemVDaGFuZ2VkIHx8XHJcbiAgICAgIHNob3dOYXRpdmVPdmVybGFpZFNjcm9sbGJhcnNDaGFuZ2VkO1xyXG5cclxuICAgIGxldCBzaXplRnJhY3Rpb25DYWNoZSA9IGdldEN1cnJlbnRTaXplRnJhY3Rpb24oX2ZvcmNlKTtcclxuICAgIGxldCB2aWV3cG9ydFNjcm9sbFNpemVDYWNoZSA9IGdldEN1cnJlbnRWaWV3cG9ydFNjcm9sbFNpemVDYWNoZShfZm9yY2UpO1xyXG4gICAgbGV0IG92ZXJmbG93QW11bnRDYWNoZSA9IGdldEN1cnJlbnRPdmVyZmxvd0Ftb3VudENhY2hlKF9mb3JjZSk7XHJcbiAgICBsZXQgb3ZlcmZsb3dFZGdlQ2FjaGUgPSBnZXRDdXJyZW50T3ZlcmZsb3dFZGdlQ2FjaGUoX2ZvcmNlKTtcclxuXHJcbiAgICBpZiAoc2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFyc0NoYW5nZWQgJiYgX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmcpIHtcclxuICAgICAgX3ZpZXdwb3J0QWRkUmVtb3ZlQ2xhc3MoZGF0YVZhbHVlVmlld3BvcnRTY3JvbGxiYXJIaWRkZW4sICFzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XHJcbiAgICAgIGlmIChoYXNBdHRyQ2xhc3MoX2hvc3QsIGRhdGFBdHRyaWJ1dGVIb3N0LCBkYXRhVmFsdWVOb0NsaXBwaW5nKSkge1xyXG4gICAgICAgIHNldE1lYXN1cmluZ01vZGUodHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlZG9WaWV3cG9ydEFycmFuZ2UgPSBfdW5kb1ZpZXdwb3J0QXJyYW5nZSAmJiBfdW5kb1ZpZXdwb3J0QXJyYW5nZSgpO1xyXG5cclxuICAgICAgY29uc3QgW3NpemVGcmFjdGlvbl0gPSAoc2l6ZUZyYWN0aW9uQ2FjaGUgPSB1cGRhdGVTaXplRnJhY3Rpb24oX2ZvcmNlKSk7XHJcbiAgICAgIGNvbnN0IFt2aWV3cG9ydFNjcm9sbFNpemVdID0gKHZpZXdwb3J0U2Nyb2xsU2l6ZUNhY2hlID1cclxuICAgICAgICB1cGRhdGVWaWV3cG9ydFNjcm9sbFNpemVDYWNoZShfZm9yY2UpKTtcclxuICAgICAgY29uc3Qgdmlld3BvcnRDbGllbnRTaXplID0gZ2V0Q2xpZW50U2l6ZShfdmlld3BvcnQpO1xyXG4gICAgICBjb25zdCB3aW5kb3dJbm5lclNpemUgPSB2aWV3cG9ydElzVGFyZ2V0Qm9keSAmJiBnZXRXaW5kb3dTaXplKF93aW5kb3dFbG0oKSk7XHJcbiAgICAgIGNvbnN0IG92ZXJmbG93QW1vdW50U2Nyb2xsU2l6ZSA9IHtcclxuICAgICAgICB3OiBtYXgwKHZpZXdwb3J0U2Nyb2xsU2l6ZS53ICsgc2l6ZUZyYWN0aW9uLncpLFxyXG4gICAgICAgIGg6IG1heDAodmlld3BvcnRTY3JvbGxTaXplLmggKyBzaXplRnJhY3Rpb24uaCksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBvdmVyZmxvd0Ftb3VudENsaWVudFNpemUgPSB7XHJcbiAgICAgICAgdzogbWF4MChcclxuICAgICAgICAgICh3aW5kb3dJbm5lclNpemVcclxuICAgICAgICAgICAgPyB3aW5kb3dJbm5lclNpemUud1xyXG4gICAgICAgICAgICA6IHZpZXdwb3J0Q2xpZW50U2l6ZS53ICsgbWF4MCh2aWV3cG9ydENsaWVudFNpemUudyAtIHZpZXdwb3J0U2Nyb2xsU2l6ZS53KSkgK1xyXG4gICAgICAgICAgICBzaXplRnJhY3Rpb24ud1xyXG4gICAgICAgICksXHJcbiAgICAgICAgaDogbWF4MChcclxuICAgICAgICAgICh3aW5kb3dJbm5lclNpemVcclxuICAgICAgICAgICAgPyB3aW5kb3dJbm5lclNpemUuaFxyXG4gICAgICAgICAgICA6IHZpZXdwb3J0Q2xpZW50U2l6ZS5oICsgbWF4MCh2aWV3cG9ydENsaWVudFNpemUuaCAtIHZpZXdwb3J0U2Nyb2xsU2l6ZS5oKSkgK1xyXG4gICAgICAgICAgICBzaXplRnJhY3Rpb24uaFxyXG4gICAgICAgICksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAocmVkb1ZpZXdwb3J0QXJyYW5nZSkge1xyXG4gICAgICAgIHJlZG9WaWV3cG9ydEFycmFuZ2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgb3ZlcmZsb3dFZGdlQ2FjaGUgPSB1cGRhdGVPdmVyZmxvd0VkZ2Uob3ZlcmZsb3dBbW91bnRDbGllbnRTaXplKTtcclxuICAgICAgb3ZlcmZsb3dBbXVudENhY2hlID0gdXBkYXRlT3ZlcmZsb3dBbW91bnRDYWNoZShcclxuICAgICAgICBnZXRPdmVyZmxvd0Ftb3VudChvdmVyZmxvd0Ftb3VudFNjcm9sbFNpemUsIG92ZXJmbG93QW1vdW50Q2xpZW50U2l6ZSksXHJcbiAgICAgICAgX2ZvcmNlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgW292ZXJmbG93RWRnZSwgb3ZlcmZsb3dFZGdlQ2hhbmdlZF0gPSBvdmVyZmxvd0VkZ2VDYWNoZTtcclxuICAgIGNvbnN0IFtvdmVyZmxvd0Ftb3VudCwgb3ZlcmZsb3dBbW91bnRDaGFuZ2VkXSA9IG92ZXJmbG93QW11bnRDYWNoZTtcclxuICAgIGNvbnN0IFt2aWV3cG9ydFNjcm9sbFNpemUsIHZpZXdwb3J0U2Nyb2xsU2l6ZUNoYW5nZWRdID0gdmlld3BvcnRTY3JvbGxTaXplQ2FjaGU7XHJcbiAgICBjb25zdCBbc2l6ZUZyYWN0aW9uLCBzaXplRnJhY3Rpb25DaGFuZ2VkXSA9IHNpemVGcmFjdGlvbkNhY2hlO1xyXG4gICAgY29uc3QgW2hhc092ZXJmbG93LCBoYXNPdmVyZmxvd0NoYW5nZWRdID0gdXBkYXRlSGFzT3ZlcmZsb3dDYWNoZSh7XHJcbiAgICAgIHg6IG92ZXJmbG93QW1vdW50LncgPiAwLFxyXG4gICAgICB5OiBvdmVyZmxvd0Ftb3VudC5oID4gMCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVtb3ZlQ2xpcHBpbmcgPVxyXG4gICAgICAob3ZlcmZsb3dYVmlzaWJsZSAmJiBvdmVyZmxvd1lWaXNpYmxlICYmIChoYXNPdmVyZmxvdy54IHx8IGhhc092ZXJmbG93LnkpKSB8fFxyXG4gICAgICAob3ZlcmZsb3dYVmlzaWJsZSAmJiBoYXNPdmVyZmxvdy54ICYmICFoYXNPdmVyZmxvdy55KSB8fFxyXG4gICAgICAob3ZlcmZsb3dZVmlzaWJsZSAmJiBoYXNPdmVyZmxvdy55ICYmICFoYXNPdmVyZmxvdy54KTtcclxuICAgIGNvbnN0IGFkanVzdFZpZXdwb3J0U3R5bGUgPVxyXG4gICAgICBfcGFkZGluZ1N0eWxlQ2hhbmdlZCB8fFxyXG4gICAgICBfZGlyZWN0aW9uQ2hhbmdlZCB8fFxyXG4gICAgICBfc2Nyb2xsYmFyU2l6ZUNoYW5nZWQgfHxcclxuICAgICAgc2l6ZUZyYWN0aW9uQ2hhbmdlZCB8fFxyXG4gICAgICB2aWV3cG9ydFNjcm9sbFNpemVDaGFuZ2VkIHx8XHJcbiAgICAgIG92ZXJmbG93RWRnZUNoYW5nZWQgfHxcclxuICAgICAgb3ZlcmZsb3dBbW91bnRDaGFuZ2VkIHx8XHJcbiAgICAgIG92ZXJmbG93Q2hhbmdlZCB8fFxyXG4gICAgICBzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzQ2hhbmdlZCB8fFxyXG4gICAgICB2aWV3cG9ydENoYW5nZWQgfHxcclxuICAgICAgKF9ob3N0TXV0YXRpb24gJiYgdmlld3BvcnRJc1RhcmdldEJvZHkpO1xyXG4gICAgY29uc3QgW2Zsb3dEaXJlY3Rpb25TdHlsZXNPcHRpb25dID0gX2NoZWNrT3B0aW9uKCd1cGRhdGUuZmxvd0RpcmVjdGlvblN0eWxlcycpO1xyXG4gICAgY29uc3QgW2Zsb3dEaXJlY3Rpb25TdHlsZXMsIGZsb3dEaXJlY3Rpb25TdHlsZXNDaGFuZ2VkXSA9IHVwZGF0ZU5vbkRlZmF1bHRGbG93RGlyZWN0aW9uU3R5bGVzKFxyXG4gICAgICBmbG93RGlyZWN0aW9uU3R5bGVzT3B0aW9uID8gZmxvd0RpcmVjdGlvblN0eWxlc09wdGlvbihfdmlld3BvcnQpIDogZ2V0Rmxvd0RpcmVjdGlvblN0eWxlcygpLFxyXG4gICAgICBfZm9yY2VcclxuICAgICk7XHJcbiAgICBjb25zdCBhZGp1c3RNZWFzdXJlZFNjcm9sbENvb3JkaW5hdGVzID1cclxuICAgICAgX2RpcmVjdGlvbkNoYW5nZWQgfHwgX2FwcGVhciB8fCBmbG93RGlyZWN0aW9uU3R5bGVzQ2hhbmdlZCB8fCBoYXNPdmVyZmxvd0NoYW5nZWQgfHwgX2ZvcmNlO1xyXG4gICAgY29uc3QgW3Njcm9sbENvb3JkaW5hdGVzLCBzY3JvbGxDb29yZGluYXRlc0NoYW5nZWRdID0gYWRqdXN0TWVhc3VyZWRTY3JvbGxDb29yZGluYXRlc1xyXG4gICAgICA/IHVwZGF0ZU1lYXN1cmVkU2Nyb2xsQ29vcmRpbmF0ZXMoXHJcbiAgICAgICAgICBnZXRNZWFzdXJlZFNjcm9sbENvb3JkaW5hdGVzKGZsb3dEaXJlY3Rpb25TdHlsZXMsICEhZmxvd0RpcmVjdGlvblN0eWxlc09wdGlvbiksXHJcbiAgICAgICAgICBfZm9yY2VcclxuICAgICAgICApXHJcbiAgICAgIDogZ2V0Q3VycmVudE1lYXN1cmVkU2Nyb2xsQ29vcmRpbmF0ZXMoKTtcclxuXHJcbiAgICBsZXQgdmlld3BvcnRPdmVyZmxvd1N0eWxlID0gZ2V0Vmlld3BvcnRPdmVyZmxvd1N0eWxlKGhhc092ZXJmbG93LCBvdmVyZmxvdyk7XHJcblxyXG4gICAgc2V0TWVhc3VyaW5nTW9kZShmYWxzZSk7XHJcblxyXG4gICAgaWYgKGFkanVzdFZpZXdwb3J0U3R5bGUpIHtcclxuICAgICAgc2V0Vmlld3BvcnRPdmVyZmxvd1N0eWxlKHZpZXdwb3J0T3ZlcmZsb3dTdHlsZSk7XHJcblxyXG4gICAgICB2aWV3cG9ydE92ZXJmbG93U3R5bGUgPSBnZXRFbGVtZW50T3ZlcmZsb3dTdHlsZShfdmlld3BvcnQsIGhhc092ZXJmbG93KTtcclxuXHJcbiAgICAgIGlmIChfaGlkZU5hdGl2ZVNjcm9sbGJhcnMgJiYgX2FycmFuZ2VWaWV3cG9ydCkge1xyXG4gICAgICAgIF9hcnJhbmdlVmlld3BvcnQodmlld3BvcnRPdmVyZmxvd1N0eWxlLCB2aWV3cG9ydFNjcm9sbFNpemUsIHNpemVGcmFjdGlvbik7XHJcblxyXG4gICAgICAgIHNldFN0eWxlcyhfdmlld3BvcnQsIF9oaWRlTmF0aXZlU2Nyb2xsYmFycyh2aWV3cG9ydE92ZXJmbG93U3R5bGUpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFtvdmVyZmxvd1N0eWxlLCBvdmVyZmxvd1N0eWxlQ2hhbmdlZF0gPSB1cGRhdGVPdmVyZmxvd1N0eWxlQ2FjaGUodmlld3BvcnRPdmVyZmxvd1N0eWxlKTtcclxuXHJcbiAgICBhZGRSZW1vdmVBdHRyQ2xhc3MoX2hvc3QsIGRhdGFBdHRyaWJ1dGVIb3N0LCBkYXRhVmFsdWVOb0NsaXBwaW5nLCByZW1vdmVDbGlwcGluZyk7XHJcbiAgICBhZGRSZW1vdmVBdHRyQ2xhc3MoX3BhZGRpbmcsIGRhdGFBdHRyaWJ1dGVQYWRkaW5nLCBkYXRhVmFsdWVOb0NsaXBwaW5nLCByZW1vdmVDbGlwcGluZyk7XHJcblxyXG4gICAgYXNzaWduRGVlcChzdHJ1Y3R1cmVTZXR1cFN0YXRlLCB7XHJcbiAgICAgIF9vdmVyZmxvd1N0eWxlOiBvdmVyZmxvd1N0eWxlLFxyXG4gICAgICBfb3ZlcmZsb3dFZGdlOiB7XHJcbiAgICAgICAgeDogb3ZlcmZsb3dFZGdlLncsXHJcbiAgICAgICAgeTogb3ZlcmZsb3dFZGdlLmgsXHJcbiAgICAgIH0sXHJcbiAgICAgIF9vdmVyZmxvd0Ftb3VudDoge1xyXG4gICAgICAgIHg6IG92ZXJmbG93QW1vdW50LncsXHJcbiAgICAgICAgeTogb3ZlcmZsb3dBbW91bnQuaCxcclxuICAgICAgfSxcclxuICAgICAgX2hhc092ZXJmbG93OiBoYXNPdmVyZmxvdyxcclxuICAgICAgX3Njcm9sbENvb3JkaW5hdGVzOiBzYW5pdGl6ZVNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbENvb3JkaW5hdGVzLCBvdmVyZmxvd0Ftb3VudCksXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBfb3ZlcmZsb3dTdHlsZUNoYW5nZWQ6IG92ZXJmbG93U3R5bGVDaGFuZ2VkLFxyXG4gICAgICBfb3ZlcmZsb3dFZGdlQ2hhbmdlZDogb3ZlcmZsb3dFZGdlQ2hhbmdlZCxcclxuICAgICAgX292ZXJmbG93QW1vdW50Q2hhbmdlZDogb3ZlcmZsb3dBbW91bnRDaGFuZ2VkLFxyXG4gICAgICBfc2Nyb2xsQ29vcmRpbmF0ZXNDaGFuZ2VkOiBzY3JvbGxDb29yZGluYXRlc0NoYW5nZWQgfHwgb3ZlcmZsb3dBbW91bnRDaGFuZ2VkLFxyXG4gICAgfTtcclxuICB9O1xyXG59O1xyXG4iLCJpbXBvcnQgdHlwZSB7IFRSQkwsIFhZLCBTY3JvbGxDb29yZGluYXRlcyB9IGZyb20gJy4uLy4uL3N1cHBvcnQnO1xyXG5pbXBvcnQgdHlwZSB7IFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmogfSBmcm9tICcuL3N0cnVjdHVyZVNldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHR5cGUge1xyXG4gIE9ic2VydmVyc1NldHVwU3RhdGUsXHJcbiAgT2JzZXJ2ZXJzU2V0dXBVcGRhdGVIaW50cyxcclxuICBTZXR1cCxcclxuICBTZXR1cFVwZGF0ZUluZm8sXHJcbn0gZnJvbSAnLi4vLi4vc2V0dXBzJztcclxuaW1wb3J0IHR5cGUgeyBJbml0aWFsaXphdGlvblRhcmdldCB9IGZyb20gJy4uLy4uL2luaXRpYWxpemF0aW9uJztcclxuaW1wb3J0IHR5cGUgeyBTdHlsZU9iamVjdCwgT3ZlcmZsb3dTdHlsZSB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xyXG5pbXBvcnQge1xyXG4gIGFzc2lnbkRlZXAsXHJcbiAgZWFjaCxcclxuICBnZXRFbGVtZW50U2Nyb2xsLFxyXG4gIGdldFplcm9TY3JvbGxDb29yZGluYXRlcyxcclxuICBzY3JvbGxFbGVtZW50VG8sXHJcbiAgc3RySGlkZGVuLFxyXG4gIHN0ck1hcmdpbkJvdHRvbSxcclxuICBzdHJNYXJnaW5MZWZ0LFxyXG4gIHN0ck1hcmdpblJpZ2h0LFxyXG4gIHN0clBhZGRpbmdCb3R0b20sXHJcbiAgc3RyUGFkZGluZ0xlZnQsXHJcbiAgc3RyUGFkZGluZ1JpZ2h0LFxyXG4gIHN0clBhZGRpbmdUb3AsXHJcbn0gZnJvbSAnLi4vLi4vc3VwcG9ydCc7XHJcbmltcG9ydCB7IGdldEVudmlyb25tZW50IH0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQnO1xyXG5pbXBvcnQgeyBjcmVhdGVTdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzIH0gZnJvbSAnLi9zdHJ1Y3R1cmVTZXR1cC5lbGVtZW50cyc7XHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlT3ZlcmZsb3dVcGRhdGVTZWdtZW50LFxyXG4gIGNyZWF0ZVBhZGRpbmdVcGRhdGVTZWdtZW50LFxyXG4gIGNyZWF0ZVRyaW5zaWNVcGRhdGVTZWdtZW50LFxyXG59IGZyb20gJy4vdXBkYXRlU2VnbWVudHMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdHJ1Y3R1cmVTZXR1cFN0YXRlIHtcclxuICBfcGFkZGluZzogVFJCTDtcclxuICBfcGFkZGluZ0Fic29sdXRlOiBib29sZWFuO1xyXG4gIF92aWV3cG9ydFBhZGRpbmdTdHlsZTogU3R5bGVPYmplY3Q7XHJcbiAgX292ZXJmbG93RWRnZTogWFk8bnVtYmVyPjtcclxuICBfb3ZlcmZsb3dBbW91bnQ6IFhZPG51bWJlcj47XHJcbiAgX292ZXJmbG93U3R5bGU6IFhZPE92ZXJmbG93U3R5bGU+O1xyXG4gIF9oYXNPdmVyZmxvdzogWFk8Ym9vbGVhbj47XHJcbiAgX3Njcm9sbENvb3JkaW5hdGVzOiBTY3JvbGxDb29yZGluYXRlcztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdHJ1Y3R1cmVTZXR1cFVwZGF0ZUluZm8gZXh0ZW5kcyBTZXR1cFVwZGF0ZUluZm8ge1xyXG4gIF9vYnNlcnZlcnNTdGF0ZTogT2JzZXJ2ZXJzU2V0dXBTdGF0ZTtcclxuICBfb2JzZXJ2ZXJzVXBkYXRlSGludHM/OiBPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdHJ1Y3R1cmVTZXR1cFVwZGF0ZUhpbnRzID0ge1xyXG4gIF9vdmVyZmxvd0VkZ2VDaGFuZ2VkPzogYm9vbGVhbjtcclxuICBfb3ZlcmZsb3dBbW91bnRDaGFuZ2VkPzogYm9vbGVhbjtcclxuICBfb3ZlcmZsb3dTdHlsZUNoYW5nZWQ/OiBib29sZWFuO1xyXG4gIF9wYWRkaW5nU3R5bGVDaGFuZ2VkPzogYm9vbGVhbjtcclxuICBfc2Nyb2xsQ29vcmRpbmF0ZXNDaGFuZ2VkPzogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFN0cnVjdHVyZVNldHVwID0gW1xyXG4gIC4uLlNldHVwPFN0cnVjdHVyZVNldHVwVXBkYXRlSW5mbywgU3RydWN0dXJlU2V0dXBTdGF0ZSwgU3RydWN0dXJlU2V0dXBVcGRhdGVIaW50cz4sXHJcbiAgLyoqIFRoZSBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoZSBzdHJ1Y3R1cmUgc2V0dXAuICovXHJcbiAgU3RydWN0dXJlU2V0dXBFbGVtZW50c09iaixcclxuICAvKiogRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGluaXRpYWxpemF0aW9uIHdhcyBjYW5jZWxlZC4gKi9cclxuICAoKSA9PiB2b2lkLFxyXG5dO1xyXG5cclxuZXhwb3J0IHR5cGUgU3RydWN0dXJlVXBkYXRlU2VnbWVudCA9IChcclxuICB1cGRhdGVJbmZvOiBTdHJ1Y3R1cmVTZXR1cFVwZGF0ZUluZm8sXHJcbiAgdXBkYXRlSGludHM6IFJlYWRvbmx5PFN0cnVjdHVyZVNldHVwVXBkYXRlSGludHM+XHJcbikgPT4gU3RydWN0dXJlU2V0dXBVcGRhdGVIaW50cyB8IHZvaWQ7XHJcblxyXG5leHBvcnQgdHlwZSBDcmVhdGVTdHJ1Y3R1cmVVcGRhdGVTZWdtZW50ID0gKFxyXG4gIHN0cnVjdHVyZVNldHVwRWxlbWVudHM6IFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmosXHJcbiAgc3RhdGU6IFN0cnVjdHVyZVNldHVwU3RhdGVcclxuKSA9PiBTdHJ1Y3R1cmVVcGRhdGVTZWdtZW50O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0cnVjdHVyZVNldHVwID0gKHRhcmdldDogSW5pdGlhbGl6YXRpb25UYXJnZXQpOiBTdHJ1Y3R1cmVTZXR1cCA9PiB7XHJcbiAgY29uc3QgW2VsZW1lbnRzLCBhcHBlbmRTdHJ1Y3R1cmVFbGVtZW50cywgY2FuY2VsZWRdID0gY3JlYXRlU3RydWN0dXJlU2V0dXBFbGVtZW50cyh0YXJnZXQpO1xyXG4gIGNvbnN0IHN0YXRlOiBTdHJ1Y3R1cmVTZXR1cFN0YXRlID0ge1xyXG4gICAgX3BhZGRpbmc6IHtcclxuICAgICAgdDogMCxcclxuICAgICAgcjogMCxcclxuICAgICAgYjogMCxcclxuICAgICAgbDogMCxcclxuICAgIH0sXHJcbiAgICBfcGFkZGluZ0Fic29sdXRlOiBmYWxzZSxcclxuICAgIF92aWV3cG9ydFBhZGRpbmdTdHlsZToge1xyXG4gICAgICBbc3RyTWFyZ2luUmlnaHRdOiAwLFxyXG4gICAgICBbc3RyTWFyZ2luQm90dG9tXTogMCxcclxuICAgICAgW3N0ck1hcmdpbkxlZnRdOiAwLFxyXG4gICAgICBbc3RyUGFkZGluZ1RvcF06IDAsXHJcbiAgICAgIFtzdHJQYWRkaW5nUmlnaHRdOiAwLFxyXG4gICAgICBbc3RyUGFkZGluZ0JvdHRvbV06IDAsXHJcbiAgICAgIFtzdHJQYWRkaW5nTGVmdF06IDAsXHJcbiAgICB9LFxyXG4gICAgX292ZXJmbG93RWRnZTogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICBfb3ZlcmZsb3dBbW91bnQ6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgX292ZXJmbG93U3R5bGU6IHtcclxuICAgICAgeDogc3RySGlkZGVuLFxyXG4gICAgICB5OiBzdHJIaWRkZW4sXHJcbiAgICB9LFxyXG4gICAgX2hhc092ZXJmbG93OiB7XHJcbiAgICAgIHg6IGZhbHNlLFxyXG4gICAgICB5OiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICBfc2Nyb2xsQ29vcmRpbmF0ZXM6IGdldFplcm9TY3JvbGxDb29yZGluYXRlcygpLFxyXG4gIH07XHJcbiAgY29uc3QgeyBfdGFyZ2V0LCBfc2Nyb2xsT2Zmc2V0RWxlbWVudCwgX3ZpZXdwb3J0SXNUYXJnZXQsIF9yZW1vdmVTY3JvbGxPYnNjdXJpbmdTdHlsZXMgfSA9XHJcbiAgICBlbGVtZW50cztcclxuICBjb25zdCB7IF9uYXRpdmVTY3JvbGxiYXJzSGlkaW5nLCBfbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkIH0gPSBnZXRFbnZpcm9ubWVudCgpO1xyXG4gIGNvbnN0IGRvVmlld3BvcnRBcnJhbmdlID1cclxuICAgICFfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZyAmJiAoX25hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC54IHx8IF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQueSk7XHJcblxyXG4gIGNvbnN0IHVwZGF0ZVNlZ21lbnRzOiBTdHJ1Y3R1cmVVcGRhdGVTZWdtZW50W10gPSBbXHJcbiAgICBjcmVhdGVUcmluc2ljVXBkYXRlU2VnbWVudChlbGVtZW50cywgc3RhdGUpLFxyXG4gICAgY3JlYXRlUGFkZGluZ1VwZGF0ZVNlZ21lbnQoZWxlbWVudHMsIHN0YXRlKSxcclxuICAgIGNyZWF0ZU92ZXJmbG93VXBkYXRlU2VnbWVudChlbGVtZW50cywgc3RhdGUpLFxyXG4gIF07XHJcblxyXG4gIHJldHVybiBbXHJcbiAgICBhcHBlbmRTdHJ1Y3R1cmVFbGVtZW50cyxcclxuICAgICh1cGRhdGVJbmZvKSA9PiB7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZUhpbnRzOiBTdHJ1Y3R1cmVTZXR1cFVwZGF0ZUhpbnRzID0ge307XHJcbiAgICAgIGNvbnN0IGFkanVzdFNjcm9sbE9mZnNldCA9IGRvVmlld3BvcnRBcnJhbmdlO1xyXG4gICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSBhZGp1c3RTY3JvbGxPZmZzZXQgJiYgZ2V0RWxlbWVudFNjcm9sbChfc2Nyb2xsT2Zmc2V0RWxlbWVudCk7XHJcbiAgICAgIGNvbnN0IHJldmVydFNjcm9sbE9ic2N1cmluZ1N0eWxlcyA9IHNjcm9sbE9mZnNldCAmJiBfcmVtb3ZlU2Nyb2xsT2JzY3VyaW5nU3R5bGVzKCk7XHJcblxyXG4gICAgICBlYWNoKHVwZGF0ZVNlZ21lbnRzLCAodXBkYXRlU2VnbWVudCkgPT4ge1xyXG4gICAgICAgIGFzc2lnbkRlZXAodXBkYXRlSGludHMsIHVwZGF0ZVNlZ21lbnQodXBkYXRlSW5mbywgdXBkYXRlSGludHMpIHx8IHt9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzY3JvbGxFbGVtZW50VG8oX3Njcm9sbE9mZnNldEVsZW1lbnQsIHNjcm9sbE9mZnNldCk7XHJcbiAgICAgIGlmIChyZXZlcnRTY3JvbGxPYnNjdXJpbmdTdHlsZXMpIHtcclxuICAgICAgICByZXZlcnRTY3JvbGxPYnNjdXJpbmdTdHlsZXMoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIV92aWV3cG9ydElzVGFyZ2V0KSB7XHJcbiAgICAgICAgc2Nyb2xsRWxlbWVudFRvKF90YXJnZXQsIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdXBkYXRlSGludHM7XHJcbiAgICB9LFxyXG4gICAgc3RhdGUsXHJcbiAgICBlbGVtZW50cyxcclxuICAgIGNhbmNlbGVkLFxyXG4gIF07XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgT3B0aW9uc0NoZWNrRm4sIE9wdGlvbnMsIFBhcnRpYWxPcHRpb25zLCBSZWFkb25seU9wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zJztcclxuaW1wb3J0IHR5cGUgeyBEZWVwUmVhZG9ubHkgfSBmcm9tICcuLi90eXBpbmdzJztcclxuaW1wb3J0IHR5cGUgeyBJbml0aWFsaXphdGlvblRhcmdldCB9IGZyb20gJy4uL2luaXRpYWxpemF0aW9uJztcclxuaW1wb3J0IHR5cGUgeyBPYnNlcnZlcnNTZXR1cFN0YXRlLCBPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzIH0gZnJvbSAnLi9vYnNlcnZlcnNTZXR1cCc7XHJcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlU2V0dXBTdGF0ZSwgU3RydWN0dXJlU2V0dXBVcGRhdGVIaW50cyB9IGZyb20gJy4vc3RydWN0dXJlU2V0dXAnO1xyXG5pbXBvcnQgdHlwZSB7IFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmogfSBmcm9tICcuL3N0cnVjdHVyZVNldHVwL3N0cnVjdHVyZVNldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHR5cGUgeyBTY3JvbGxiYXJzU2V0dXBFbGVtZW50c09iaiB9IGZyb20gJy4vc2Nyb2xsYmFyc1NldHVwL3Njcm9sbGJhcnNTZXR1cC5lbGVtZW50cyc7XHJcbmltcG9ydCB7IGNyZWF0ZU9wdGlvbkNoZWNrIH0gZnJvbSAnLi4vb3B0aW9ucyc7XHJcbmltcG9ydCB7XHJcbiAgYXNzaWduRGVlcCxcclxuICBiaW5kLFxyXG4gIGdldEVsZW1lbnRTY3JvbGwsXHJcbiAgaXNFbXB0eU9iamVjdCxcclxuICBrZXlzLFxyXG4gIHJ1bkVhY2hBbmRDbGVhcixcclxuICBzY3JvbGxFbGVtZW50VG8sXHJcbn0gZnJvbSAnLi4vc3VwcG9ydCc7XHJcbmltcG9ydCB7IGNyZWF0ZU9ic2VydmVyc1NldHVwIH0gZnJvbSAnLi9vYnNlcnZlcnNTZXR1cCc7XHJcbmltcG9ydCB7IGNyZWF0ZVNjcm9sbGJhcnNTZXR1cCB9IGZyb20gJy4vc2Nyb2xsYmFyc1NldHVwJztcclxuaW1wb3J0IHsgY3JlYXRlU3RydWN0dXJlU2V0dXAgfSBmcm9tICcuL3N0cnVjdHVyZVNldHVwJztcclxuXHJcbmV4cG9ydCB0eXBlIFNldHVwVXBkYXRlSGludHMgPSBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+PjtcclxuXHJcbmV4cG9ydCB0eXBlIFNldHVwVXBkYXRlSW5mbyA9IHtcclxuICBfY2hlY2tPcHRpb246IE9wdGlvbnNDaGVja0ZuPE9wdGlvbnM+O1xyXG4gIF9jaGFuZ2VkT3B0aW9uczogUGFydGlhbE9wdGlvbnM7XHJcbiAgX2ZvcmNlOiBib29sZWFuO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgU2V0dXA8XHJcbiAgVSBleHRlbmRzIFNldHVwVXBkYXRlSW5mbyxcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIFMgZXh0ZW5kcyBSZWFkb25seTxSZWNvcmQ8c3RyaW5nLCBhbnk+PixcclxuICBIIGV4dGVuZHMgU2V0dXBVcGRhdGVIaW50cyB8IHZvaWQsXHJcbj4gPSBbXHJcbiAgLyoqIFRoZSBjcmVhdGUgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgYGRlc3Ryb3lgIGZ1bmN0aW9uLiAqL1xyXG4gIF9jcmVhdGU6ICgpID0+ICgpID0+IHZvaWQsXHJcbiAgLyoqIEZ1bmN0aW9uIHdoaWNoIHVwZGF0ZXMgdGhlIHNldHVwIGFuZCByZXR1cm5zIHRoZSB1cGRhdGUgcmVzdWx0LiAqL1xyXG4gIF91cGRhdGU6ICh1cGRhdGVJbmZvOiBVKSA9PiBILFxyXG4gIC8qKiBGdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlLiAqL1xyXG4gIF9zdGF0ZTogUyxcclxuXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2V0dXBzVXBkYXRlSW5mbyB7XHJcbiAgLyoqIFRoZSBvcHRpb25zIHRoYXQgY2hhbmdlZCBvciBgdW5kZWZpbmVkYCBpZiBub25lIGNoYW5nZWQuICovXHJcbiAgX2NoYW5nZWRPcHRpb25zPzogUGFydGlhbE9wdGlvbnM7XHJcbiAgLyoqIFdoZXRoZXIgY2hhY2hlIHNob3VsZCBiZSBpZ25vcmVkLiAqL1xyXG4gIF9mb3JjZT86IGJvb2xlYW47XHJcbiAgLyoqIFdoZXRoZXIgb2JzZXJ2ZXJzIHNob3VsZCB0YWtlIHRoZWlyIHJlY29yZHMgYW5kIHRodXMgdXBkYXRlIGFzIHdlbGwuICovXHJcbiAgX3Rha2VSZWNvcmRzPzogYm9vbGVhbjtcclxuICAvKiogV2hldGhlciBvbmUgb3IgbW9yZSBzY3JvbGxiYXJzIGhhcyBiZWVuIGNsb25lZC4gKi9cclxuICBfY2xvbmVTY3JvbGxiYXI/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNldHVwc1VwZGF0ZUhpbnRzIHtcclxuICByZWFkb25seSBfb2JzZXJ2ZXJzVXBkYXRlSGludHM6IERlZXBSZWFkb25seTxPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzPjtcclxuICByZWFkb25seSBfc3RydWN0dXJlVXBkYXRlSGludHM6IERlZXBSZWFkb25seTxTdHJ1Y3R1cmVTZXR1cFVwZGF0ZUhpbnRzPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXR1cHNTdGF0ZSB7XHJcbiAgcmVhZG9ubHkgX29ic2VydmVyc1NldHVwU3RhdGU6IERlZXBSZWFkb25seTxPYnNlcnZlcnNTZXR1cFN0YXRlPjtcclxuICByZWFkb25seSBfc3RydWN0dXJlU2V0dXBTdGF0ZTogRGVlcFJlYWRvbmx5PFN0cnVjdHVyZVNldHVwU3RhdGU+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNldHVwc0VsZW1lbnRzIHtcclxuICByZWFkb25seSBfc3RydWN0dXJlU2V0dXBFbGVtZW50czogRGVlcFJlYWRvbmx5PFN0cnVjdHVyZVNldHVwRWxlbWVudHNPYmo+O1xyXG4gIHJlYWRvbmx5IF9zY3JvbGxiYXJzU2V0dXBFbGVtZW50czogRGVlcFJlYWRvbmx5PFNjcm9sbGJhcnNTZXR1cEVsZW1lbnRzT2JqPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU2V0dXBzID0gW1xyXG4gIGNvbnN0cnVjdDogKCkgPT4gKCkgPT4gdm9pZCxcclxuICB1cGRhdGU6ICh1cGRhdGVJbmZvOiBTZXR1cHNVcGRhdGVJbmZvKSA9PiBib29sZWFuLFxyXG4gIGdldFN0YXRlOiAoKSA9PiBTZXR1cHNTdGF0ZSxcclxuICBlbGVtZW50czogU2V0dXBzRWxlbWVudHMsXHJcbiAgY2FuY2VsZWQ6ICgpID0+IHZvaWQsXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlU2V0dXBzID0gKFxyXG4gIHRhcmdldDogSW5pdGlhbGl6YXRpb25UYXJnZXQsXHJcbiAgb3B0aW9uczogUmVhZG9ubHlPcHRpb25zLFxyXG4gIGlzRGVzdHJveWVkOiAoKSA9PiBib29sZWFuLFxyXG4gIG9uVXBkYXRlZDogKHVwZGF0ZUluZm86IFNldHVwc1VwZGF0ZUluZm8sIHVwZGF0ZUhpbnRzOiBTZXR1cHNVcGRhdGVIaW50cykgPT4gdm9pZCxcclxuICBvblNjcm9sbDogKHNjcm9sbEV2ZW50OiBFdmVudCkgPT4gdm9pZFxyXG4pOiBTZXR1cHMgPT4ge1xyXG4gIGxldCBjYWNoZUFuZE9wdGlvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gIGNvbnN0IGdldEN1cnJlbnRPcHRpb24gPSBjcmVhdGVPcHRpb25DaGVjayhvcHRpb25zLCB7fSk7XHJcbiAgY29uc3QgW1xyXG4gICAgc3RydWN0dXJlU2V0dXBDcmVhdGUsXHJcbiAgICBzdHJ1Y3R1cmVTZXR1cFVwZGF0ZSxcclxuICAgIHN0cnVjdHVyZVNldHVwU3RhdGUsXHJcbiAgICBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzLFxyXG4gICAgc3RydWN0dXJlU2V0dXBDYW5jZWxlZCxcclxuICBdID0gY3JlYXRlU3RydWN0dXJlU2V0dXAodGFyZ2V0KTtcclxuICBjb25zdCBbb2JzZXJ2ZXJzU2V0dXBDcmVhdGUsIG9ic2VydmVyc1NldHVwVXBkYXRlLCBvYnNlcnZlcnNTZXR1cFN0YXRlXSA9IGNyZWF0ZU9ic2VydmVyc1NldHVwKFxyXG4gICAgc3RydWN0dXJlU2V0dXBFbGVtZW50cyxcclxuICAgIHN0cnVjdHVyZVNldHVwU3RhdGUsXHJcbiAgICBnZXRDdXJyZW50T3B0aW9uLFxyXG4gICAgKG9ic2VydmVyc1VwZGF0ZUhpbnRzKSA9PiB7XHJcbiAgICAgIHVwZGF0ZSh7fSwgb2JzZXJ2ZXJzVXBkYXRlSGludHMpO1xyXG4gICAgfVxyXG4gICk7XHJcbiAgY29uc3QgW3Njcm9sbGJhcnNTZXR1cENyZWF0ZSwgc2Nyb2xsYmFyc1NldHVwVXBkYXRlLCAsIHNjcm9sbGJhcnNTZXR1cEVsZW1lbnRzXSA9XHJcbiAgICBjcmVhdGVTY3JvbGxiYXJzU2V0dXAoXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgb3B0aW9ucyxcclxuICAgICAgb2JzZXJ2ZXJzU2V0dXBTdGF0ZSxcclxuICAgICAgc3RydWN0dXJlU2V0dXBTdGF0ZSxcclxuICAgICAgc3RydWN0dXJlU2V0dXBFbGVtZW50cyxcclxuICAgICAgb25TY3JvbGxcclxuICAgICk7XHJcblxyXG4gIGNvbnN0IHVwZGF0ZUhpbnRzQXJlVHJ1dGh5ID0gKGhpbnRzOiBTZXR1cFVwZGF0ZUhpbnRzKSA9PlxyXG4gICAga2V5cyhoaW50cykuc29tZSgoa2V5KSA9PiAhIWhpbnRzW2tleSBhcyBrZXlvZiB0eXBlb2YgaGludHNdKTtcclxuXHJcbiAgY29uc3QgdXBkYXRlID0gKFxyXG4gICAgdXBkYXRlSW5mbzogU2V0dXBzVXBkYXRlSW5mbyxcclxuICAgIG9ic2VydmVyVXBkYXRlSGludHM/OiBPYnNlcnZlcnNTZXR1cFVwZGF0ZUhpbnRzXHJcbiAgKTogYm9vbGVhbiA9PiB7XHJcbiAgICBpZiAoaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBfY2hhbmdlZE9wdGlvbnM6IHJhd0NoYW5nZWRPcHRpb25zLFxyXG4gICAgICBfZm9yY2U6IHJhd0ZvcmNlLFxyXG4gICAgICBfdGFrZVJlY29yZHMsXHJcbiAgICAgIF9jbG9uZVNjcm9sbGJhcixcclxuICAgIH0gPSB1cGRhdGVJbmZvO1xyXG5cclxuICAgIGNvbnN0IF9jaGFuZ2VkT3B0aW9ucyA9IHJhd0NoYW5nZWRPcHRpb25zIHx8IHt9O1xyXG4gICAgY29uc3QgX2ZvcmNlID0gISFyYXdGb3JjZSB8fCAhY2FjaGVBbmRPcHRpb25zSW5pdGlhbGl6ZWQ7XHJcbiAgICBjb25zdCBiYXNlVXBkYXRlSW5mb09iajogU2V0dXBVcGRhdGVJbmZvID0ge1xyXG4gICAgICBfY2hlY2tPcHRpb246IGNyZWF0ZU9wdGlvbkNoZWNrKG9wdGlvbnMsIF9jaGFuZ2VkT3B0aW9ucywgX2ZvcmNlKSxcclxuICAgICAgX2NoYW5nZWRPcHRpb25zLFxyXG4gICAgICBfZm9yY2UsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChfY2xvbmVTY3JvbGxiYXIpIHtcclxuICAgICAgc2Nyb2xsYmFyc1NldHVwVXBkYXRlKGJhc2VVcGRhdGVJbmZvT2JqKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9ic2VydmVyc0hpbnRzID1cclxuICAgICAgb2JzZXJ2ZXJVcGRhdGVIaW50cyB8fFxyXG4gICAgICBvYnNlcnZlcnNTZXR1cFVwZGF0ZShcclxuICAgICAgICBhc3NpZ25EZWVwKHt9LCBiYXNlVXBkYXRlSW5mb09iaiwge1xyXG4gICAgICAgICAgX3Rha2VSZWNvcmRzLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgY29uc3Qgc3RydWN0dXJlSGludHMgPSBzdHJ1Y3R1cmVTZXR1cFVwZGF0ZShcclxuICAgICAgYXNzaWduRGVlcCh7fSwgYmFzZVVwZGF0ZUluZm9PYmosIHtcclxuICAgICAgICBfb2JzZXJ2ZXJzU3RhdGU6IG9ic2VydmVyc1NldHVwU3RhdGUsXHJcbiAgICAgICAgX29ic2VydmVyc1VwZGF0ZUhpbnRzOiBvYnNlcnZlcnNIaW50cyxcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgc2Nyb2xsYmFyc1NldHVwVXBkYXRlKFxyXG4gICAgICBhc3NpZ25EZWVwKHt9LCBiYXNlVXBkYXRlSW5mb09iaiwge1xyXG4gICAgICAgIF9vYnNlcnZlcnNVcGRhdGVIaW50czogb2JzZXJ2ZXJzSGludHMsXHJcbiAgICAgICAgX3N0cnVjdHVyZVVwZGF0ZUhpbnRzOiBzdHJ1Y3R1cmVIaW50cyxcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgdHJ1dGh5T2JzZXJ2ZXJzSGludHMgPSB1cGRhdGVIaW50c0FyZVRydXRoeShvYnNlcnZlcnNIaW50cyk7XHJcbiAgICBjb25zdCB0cnV0aHlTdHJ1Y3R1cmVIaW50cyA9IHVwZGF0ZUhpbnRzQXJlVHJ1dGh5KHN0cnVjdHVyZUhpbnRzKTtcclxuICAgIGNvbnN0IGNoYW5nZWQgPVxyXG4gICAgICB0cnV0aHlPYnNlcnZlcnNIaW50cyB8fCB0cnV0aHlTdHJ1Y3R1cmVIaW50cyB8fCAhaXNFbXB0eU9iamVjdChfY2hhbmdlZE9wdGlvbnMpIHx8IF9mb3JjZTtcclxuXHJcbiAgICBjYWNoZUFuZE9wdGlvbnNJbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgb25VcGRhdGVkKHVwZGF0ZUluZm8sIHtcclxuICAgICAgICBfb2JzZXJ2ZXJzVXBkYXRlSGludHM6IG9ic2VydmVyc0hpbnRzLFxyXG4gICAgICAgIF9zdHJ1Y3R1cmVVcGRhdGVIaW50czogc3RydWN0dXJlSGludHMsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjaGFuZ2VkO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBbXHJcbiAgICAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgX29yaWdpbmFsU2Nyb2xsT2Zmc2V0RWxlbWVudCwgX3Njcm9sbE9mZnNldEVsZW1lbnQsIF9yZW1vdmVTY3JvbGxPYnNjdXJpbmdTdHlsZXMgfSA9XHJcbiAgICAgICAgc3RydWN0dXJlU2V0dXBFbGVtZW50cztcclxuICAgICAgY29uc3QgaW5pdGlhbFNjcm9sbCA9IGdldEVsZW1lbnRTY3JvbGwoX29yaWdpbmFsU2Nyb2xsT2Zmc2V0RWxlbWVudCk7XHJcbiAgICAgIGNvbnN0IGRlc3Ryb3lGbnMgPSBbb2JzZXJ2ZXJzU2V0dXBDcmVhdGUoKSwgc3RydWN0dXJlU2V0dXBDcmVhdGUoKSwgc2Nyb2xsYmFyc1NldHVwQ3JlYXRlKCldO1xyXG4gICAgICBjb25zdCByZXZlcnRTY3JvbGxPYnNjdXJpbmdTdHlsZXMgPSBfcmVtb3ZlU2Nyb2xsT2JzY3VyaW5nU3R5bGVzKCk7XHJcblxyXG4gICAgICBzY3JvbGxFbGVtZW50VG8oX3Njcm9sbE9mZnNldEVsZW1lbnQsIGluaXRpYWxTY3JvbGwpO1xyXG4gICAgICByZXZlcnRTY3JvbGxPYnNjdXJpbmdTdHlsZXMoKTtcclxuXHJcbiAgICAgIHJldHVybiBiaW5kKHJ1bkVhY2hBbmRDbGVhciwgZGVzdHJveUZucyk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlLFxyXG4gICAgKCkgPT4gKHtcclxuICAgICAgX29ic2VydmVyc1NldHVwU3RhdGU6IG9ic2VydmVyc1NldHVwU3RhdGUsXHJcbiAgICAgIF9zdHJ1Y3R1cmVTZXR1cFN0YXRlOiBzdHJ1Y3R1cmVTZXR1cFN0YXRlLFxyXG4gICAgfSksXHJcbiAgICB7XHJcbiAgICAgIF9zdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzOiBzdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzLFxyXG4gICAgICBfc2Nyb2xsYmFyc1NldHVwRWxlbWVudHM6IHNjcm9sbGJhcnNTZXR1cEVsZW1lbnRzLFxyXG4gICAgfSxcclxuICAgIHN0cnVjdHVyZVNldHVwQ2FuY2VsZWQsXHJcbiAgXTtcclxufTtcclxuIiwiaW1wb3J0IHR5cGUgeyBPdmVybGF5U2Nyb2xsYmFycyB9IGZyb20gJy4vb3ZlcmxheXNjcm9sbGJhcnMnO1xyXG5cclxuY29uc3QgdGFyZ2V0SW5zdGFuY2VNYXA6IFdlYWtNYXA8RWxlbWVudCwgT3ZlcmxheVNjcm9sbGJhcnM+ID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBnaXZlbiBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICogQHBhcmFtIHRhcmdldCBUaGUgZWxlbWVudCB3aGljaCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZS5cclxuICogQHBhcmFtIG9zSW5zdGFuY2UgVGhlIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFkZEluc3RhbmNlID0gKHRhcmdldDogRWxlbWVudCwgb3NJbnN0YW5jZTogT3ZlcmxheVNjcm9sbGJhcnMpOiB2b2lkID0+IHtcclxuICB0YXJnZXRJbnN0YW5jZU1hcC5zZXQodGFyZ2V0LCBvc0luc3RhbmNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGEgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICogQHBhcmFtIHRhcmdldCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIGl0cyBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSBzaGFsbCBiZSByZW1vdmVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbW92ZUluc3RhbmNlID0gKHRhcmdldDogRWxlbWVudCk6IHZvaWQgPT4ge1xyXG4gIHRhcmdldEluc3RhbmNlTWFwLmRlbGV0ZSh0YXJnZXQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIE92ZXJsYXlTY3JvbGxiYXJzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUuXHJcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGVsZW1lbnQgb2Ygd2hpY2ggaXRzIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIHNoYWxsIGJlIGdldC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZSA9ICh0YXJnZXQ6IEVsZW1lbnQpOiBPdmVybGF5U2Nyb2xsYmFycyB8IHVuZGVmaW5lZCA9PlxyXG4gIHRhcmdldEluc3RhbmNlTWFwLmdldCh0YXJnZXQpO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXHJcbmltcG9ydCB0eXBlIHsgWFksIFRSQkwgfSBmcm9tICcuL3N1cHBvcnQnO1xyXG5pbXBvcnQgdHlwZSB7IE9wdGlvbnMsIFBhcnRpYWxPcHRpb25zLCBSZWFkb25seU9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xyXG5pbXBvcnQgdHlwZSB7XHJcbiAgSW5mZXJJbnN0YW5jZVBsdWdpbk1vZHVsZUluc3RhbmNlLFxyXG4gIEluZmVyU3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2UsXHJcbiAgSW5zdGFuY2VQbHVnaW4sXHJcbiAgT3B0aW9uc1ZhbGlkYXRpb25QbHVnaW4sXHJcbiAgUGx1Z2luLFxyXG4gIFBsdWdpbk1vZHVsZUluc3RhbmNlLFxyXG4gIFN0YXRpY1BsdWdpbixcclxufSBmcm9tICcuL3BsdWdpbnMnO1xyXG5pbXBvcnQgdHlwZSB7IEluaXRpYWxpemF0aW9uLCBJbml0aWFsaXphdGlvblRhcmdldCwgUGFydGlhbEluaXRpYWxpemF0aW9uIH0gZnJvbSAnLi9pbml0aWFsaXphdGlvbic7XHJcbmltcG9ydCB0eXBlIHsgT3ZlcmZsb3dTdHlsZSB9IGZyb20gJy4vdHlwaW5ncyc7XHJcbmltcG9ydCB0eXBlIHsgRXZlbnRMaXN0ZW5lckFyZ3MsIEV2ZW50TGlzdGVuZXIsIEV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnLi9ldmVudExpc3RlbmVycyc7XHJcbmltcG9ydCB0eXBlIHtcclxuICBTY3JvbGxiYXJzU2V0dXBFbGVtZW50LFxyXG4gIFNjcm9sbGJhclN0cnVjdHVyZSxcclxufSBmcm9tICcuL3NldHVwcy9zY3JvbGxiYXJzU2V0dXAvc2Nyb2xsYmFyc1NldHVwLmVsZW1lbnRzJztcclxuaW1wb3J0IHtcclxuICBhZGRQbHVnaW5zLFxyXG4gIGdldFN0YXRpY1BsdWdpbk1vZHVsZUluc3RhbmNlLFxyXG4gIG9wdGlvbnNWYWxpZGF0aW9uUGx1Z2luTW9kdWxlTmFtZSxcclxuICBwbHVnaW5Nb2R1bGVzLFxyXG4gIHJlZ2lzdGVyUGx1Z2luTW9kdWxlSW5zdGFuY2VzLFxyXG59IGZyb20gJy4vcGx1Z2lucyc7XHJcbmltcG9ydCB7IGNyZWF0ZVNldHVwcyB9IGZyb20gJy4vc2V0dXBzJztcclxuaW1wb3J0IHsgYWRkSW5zdGFuY2UsIGdldEluc3RhbmNlLCByZW1vdmVJbnN0YW5jZSB9IGZyb20gJy4vaW5zdGFuY2VzJztcclxuaW1wb3J0IHsgY2FuY2VsSW5pdGlhbGl6YXRpb24gfSBmcm9tICcuL2luaXRpYWxpemF0aW9uJztcclxuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnQgfSBmcm9tICcuL2Vudmlyb25tZW50JztcclxuaW1wb3J0IHsgZ2V0T3B0aW9uc0RpZmYgfSBmcm9tICcuL29wdGlvbnMnO1xyXG5pbXBvcnQge1xyXG4gIGFzc2lnbkRlZXAsXHJcbiAgaXNFbXB0eU9iamVjdCxcclxuICBpc0Z1bmN0aW9uLFxyXG4gIGlzSFRNTEVsZW1lbnQsXHJcbiAgY3JlYXRlRXZlbnRMaXN0ZW5lckh1YixcclxuICBpc1BsYWluT2JqZWN0LFxyXG4gIGtleXMsXHJcbiAgaXNBcnJheSxcclxuICBwdXNoLFxyXG4gIHJ1bkVhY2hBbmRDbGVhcixcclxuICBiaW5kLFxyXG4gIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMsXHJcbn0gZnJvbSAnLi9zdXBwb3J0JztcclxuaW1wb3J0IHsgc2V0Tm9uY2UgfSBmcm9tICcuL25vbmNlJztcclxuaW1wb3J0IHsgc2V0VHJ1c3RlZFR5cGVQb2xpY3kgfSBmcm9tICcuL3RydXN0ZWRUeXBlUG9saWN5JztcclxuXHJcbi8vIE5vdGVzOlxyXG4vLyBIZWlnaHQgaW50cmluc2ljIGRldGVjdGlvbiB1c2UgXCJjb250ZW50OiB0cnVlXCIgaW5pdCBzdHJhdGVneSAtIG9yIG9wZW4gdGlja2V0IGZvciBjdXN0b20gaGVpZ2h0IGludHJpbnNpYyBvYnNlcnZlclxyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgT3ZlcmxheVNjcm9sbGJhcnMgZW52aXJvbm1lbnQuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEVudmlyb25tZW50IHtcclxuICAvKiogVGhlIG5hdGl2ZSBzY3JvbGxiYXJzIHNpemUgb2YgdGhlIGJyb3dzZXIgLyBzeXN0ZW0uICovXHJcbiAgc2Nyb2xsYmFyc1NpemU6IFhZPG51bWJlcj47XHJcbiAgLyoqIFdoZXRoZXIgdGhlIG5hdGl2ZSBzY3JvbGxiYXJzIGFyZSBvdmVybGFpZC4gKi9cclxuICBzY3JvbGxiYXJzT3ZlcmxhaWQ6IFhZPGJvb2xlYW4+O1xyXG4gIC8qKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIG5hdGl2ZSBzY3JvbGxiYXJzIGhpZGluZy4gKi9cclxuICBzY3JvbGxiYXJzSGlkaW5nOiBib29sZWFuO1xyXG4gIC8qKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBTY3JvbGxUaW1lbGluZSBBUEkuICovXHJcbiAgc2Nyb2xsVGltZWxpbmU6IGJvb2xlYW47XHJcbiAgLyoqIFRoZSBkZWZhdWx0IEluaXRpYWxpemF0aW9uIHRvIHVzZSBpZiBub3RoaW5nIGVsc2UgaXMgc3BlY2lmaWVkLiAqL1xyXG4gIHN0YXRpY0RlZmF1bHRJbml0aWFsaXphdGlvbjogSW5pdGlhbGl6YXRpb247XHJcbiAgLyoqIFRoZSBkZWZhdWx0IE9wdGlvbnMgdG8gdXNlIGlmIG5vdGhpbmcgZWxzZSBpcyBzcGVjaWZpZWQuICovXHJcbiAgc3RhdGljRGVmYXVsdE9wdGlvbnM6IE9wdGlvbnM7XHJcblxyXG4gIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlZmF1bHQgSW5pdGlhbGl6YXRpb24uICovXHJcbiAgZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uKCk6IEluaXRpYWxpemF0aW9uO1xyXG4gIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlZmF1bHQgT3B0aW9ucy4gKi9cclxuICBnZXREZWZhdWx0T3B0aW9ucygpOiBPcHRpb25zO1xyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgbmV3IGRlZmF1bHQgSW5pdGlhbGl6YXRpb24uXHJcbiAgICogSWYgdGhlIG5ldyBkZWZhdWx0IEluaXRpYWxpemF0aW9uIGlzIHBhcnRpYWxseSBmaWxsZWQsIGl0cyBkZWVwbHkgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgZGVmYXVsdCBJbml0aWFsaXphdGlvbi5cclxuICAgKiBAcGFyYW0gbmV3RGVmYXVsdEluaXRpYWxpemF0aW9uIFRoZSBuZXcgZGVmYXVsdCBJbml0aWFsaXphdGlvbi5cclxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBkZWZhdWx0IEluaXRpYWxpemF0aW9uLlxyXG4gICAqL1xyXG4gIHNldERlZmF1bHRJbml0aWFsaXphdGlvbihuZXdEZWZhdWx0SW5pdGlhbGl6YXRpb246IFBhcnRpYWxJbml0aWFsaXphdGlvbik6IEluaXRpYWxpemF0aW9uO1xyXG4gIC8qKlxyXG4gICAqIFNldHMgbmV3IGRlZmF1bHQgT3B0aW9ucy5cclxuICAgKiBJZiB0aGUgbmV3IGRlZmF1bHQgT3B0aW9ucyBhcmUgcGFydGlhbGx5IGZpbGxlZCwgdGhleSdyZSBkZWVwbHkgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgZGVmYXVsdCBPcHRpb25zLlxyXG4gICAqIEBwYXJhbSBuZXdEZWZhdWx0T3B0aW9ucyBUaGUgbmV3IGRlZmF1bHQgT3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBkZWZhdWx0IG9wdGlvbnMuXHJcbiAgICovXHJcbiAgc2V0RGVmYXVsdE9wdGlvbnMobmV3RGVmYXVsdE9wdGlvbnM6IFBhcnRpYWxPcHRpb25zKTogT3B0aW9ucztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBwcmltYXJ5IGVudHJ5IHBvaW50IHRvIE92ZXJsYXlTY3JvbGxiYXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBPdmVybGF5U2Nyb2xsYmFyc1N0YXRpYyB7XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSBpZiB0aGUgdGFyZ2V0IGFscmVhZHkgaGFzIGFuIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIGluaXRpYWxpemF0aW9uIHRhcmdldCB0byBmcm9tIHdoaWNoIHRoZSBpbnN0YW5jZSBzaGFsbCBiZSByZXR1cm5lZC5cclxuICAgKi9cclxuICAodGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldCk6IE92ZXJsYXlTY3JvbGxiYXJzIHwgdW5kZWZpbmVkO1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIHRvIHRoZSBnaXZlbiB0YXJnZXRcclxuICAgKiBvciByZXR1cm5zIHRoZSBjdXJyZW50IE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIGlmIHRoZSB0YXJnZXQgYWxyZWFkeSBoYXMgYW4gaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0LlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zLiAoQ2FuIGJlIGp1c3QgYW4gZW1wdHkgb2JqZWN0KVxyXG4gICAqIEBwYXJhbSBldmVudExpc3RlbmVycyBPcHRpb25hbCBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICovXHJcbiAgKFxyXG4gICAgdGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldCxcclxuICAgIG9wdGlvbnM6IFBhcnRpYWxPcHRpb25zLFxyXG4gICAgZXZlbnRMaXN0ZW5lcnM/OiBFdmVudExpc3RlbmVyc1xyXG4gICk6IE92ZXJsYXlTY3JvbGxiYXJzO1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgdmFsaWQgYW5kIG5vdCBkZXN0cm95ZWQgb3ZlcmxheXNjcm9sbGJhcnMgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIG9zSW5zdGFuY2UgVGhlIHZhbHVlIHdoaWNoIHNoYWxsIGJlIGNoZWNrZWQuXHJcbiAgICovXHJcbiAgdmFsaWQob3NJbnN0YW5jZTogYW55KTogb3NJbnN0YW5jZSBpcyBPdmVybGF5U2Nyb2xsYmFycztcclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBlbnZpcm9ubWVudC5cclxuICAgKi9cclxuICBlbnYoKTogRW52aXJvbm1lbnQ7XHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgbm9uY2UgYXR0cmlidXRlIGZvciBpbmxpbmUgc3R5bGVzLlxyXG4gICAqL1xyXG4gIG5vbmNlKG5ld05vbmNlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiB2b2lkO1xyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHRydXN0ZWQgdHlwZSBwb2xpY3kgdXNlZCBmb3IgRE9NIG9wZXJhdGlvbnMuXHJcbiAgICovXHJcbiAgdHJ1c3RlZFR5cGVQb2xpY3kobmV3VHJ1c3RlZFR5cGVQb2xpY3k6IHVua25vd24gfCB1bmRlZmluZWQpOiB2b2lkO1xyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBzaW5nbGUgcGx1Z2luLlxyXG4gICAqIEBwYXJhbSBwbHVnaW4gVGhlIHBsdWdpbiB0byBiZSBhZGRlZC5cclxuICAgKiBAcmV0dXJucyBUaGUgcGx1Z2lucyBzdGF0aWMgbW9kdWxlcyBpbnN0YW5jZSBvciBgdm9pZGAgaWYgbm8gaW5zdGFuY2Ugd2FzIGZvdW5kLlxyXG4gICAqL1xyXG4gIHBsdWdpbjxQIGV4dGVuZHMgUGx1Z2luPihcclxuICAgIHBsdWdpbjogUFxyXG4gICk6IFAgZXh0ZW5kcyBTdGF0aWNQbHVnaW4gPyBJbmZlclN0YXRpY1BsdWdpbk1vZHVsZUluc3RhbmNlPFA+IDogdm9pZDtcclxuICAvKipcclxuICAgKiBBZGRzIG11bHRpcGxlIHBsdWdpbnMuXHJcbiAgICogQHBhcmFtIHBsdWdpbnMgVGhlIHBsdWdpbnMgdG8gYmUgYWRkZWQuXHJcbiAgICogQHJldHVybnMgVGhlIHBsdWdpbnMgc3RhdGljIG1vZHVsZXMgaW5zdGFuY2VzIG9yIGB2b2lkYCBpZiBubyBpbnN0YW5jZSB3YXMgZm91bmQuXHJcbiAgICovXHJcbiAgcGx1Z2luPFAgZXh0ZW5kcyBbUGx1Z2luLCAuLi5QbHVnaW5bXV0+KFxyXG4gICAgcGx1Z2luczogUFxyXG4gICk6IFAgZXh0ZW5kcyBbUGx1Z2luLCAuLi5QbHVnaW5bXV1cclxuICAgID8ge1xyXG4gICAgICAgIFtLIGluIGtleW9mIFBdOiBQW0tdIGV4dGVuZHMgU3RhdGljUGx1Z2luID8gSW5mZXJTdGF0aWNQbHVnaW5Nb2R1bGVJbnN0YW5jZTxQW0tdPiA6IHZvaWQ7XHJcbiAgICAgIH1cclxuICAgIDogdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlcyBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGUge1xyXG4gIC8qKiBEZXNjcmliZXMgdGhlIGN1cnJlbnQgcGFkZGluZyBpbiBwaXhlbC4gKi9cclxuICBwYWRkaW5nOiBUUkJMO1xyXG4gIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IHBhZGRpbmcgaXMgYWJzb2x1dGUuICovXHJcbiAgcGFkZGluZ0Fic29sdXRlOiBib29sZWFuO1xyXG4gIC8qKiBUaGUgY2xpZW50IHdpZHRoICh4KSAmIGhlaWdodCAoeSkgb2YgdGhlIHZpZXdwb3J0IGluIHBpeGVsLiAqL1xyXG4gIG92ZXJmbG93RWRnZTogWFk8bnVtYmVyPjtcclxuICAvKiogVGhlIG92ZXJmbG93IGFtb3VudCBpbiBwaXhlbC4gKi9cclxuICBvdmVyZmxvd0Ftb3VudDogWFk8bnVtYmVyPjtcclxuICAvKiogVGhlIGNzcyBvdmVyZmxvdyBzdHlsZSBvZiB0aGUgdmlld3BvcnQuICovXHJcbiAgb3ZlcmZsb3dTdHlsZTogWFk8T3ZlcmZsb3dTdHlsZT47XHJcbiAgLyoqIFdoZXRoZXIgdGhlIHZpZXdwb3J0IGhhcyBhbiBvdmVyZmxvdy4gKi9cclxuICBoYXNPdmVyZmxvdzogWFk8Ym9vbGVhbj47XHJcbiAgLyoqIFRoZSBzY3JvbGwgY29vcmRpbmF0ZXMgb2YgdGhlIHZpZXdwb3J0LiAqL1xyXG4gIHNjcm9sbENvb3JkaW5hdGVzOiB7XHJcbiAgICAvKiogVGhlIHN0YXJ0IChvcmlnaW4pIHNjcm9sbCBjb29yZGluYXRlcyBmb3IgZWFjaCBheGlzLiAqL1xyXG4gICAgc3RhcnQ6IFhZPG51bWJlcj47XHJcbiAgICAvKiogVGhlIGVuZCBzY3JvbGwgY29vcmRpbmF0ZXMgZm9yIGVhY2ggYXhpcy4gKi9cclxuICAgIGVuZDogWFk8bnVtYmVyPjtcclxuICB9O1xyXG4gIC8qKiBXaGV0aGVyIHRoZSBkaXJlY3Rpb24gaXMgY29uc2lkZXJlZCBydGwuICovXHJcbiAgZGlyZWN0aW9uUlRMOiBib29sZWFuO1xyXG4gIC8qKiBXaGV0aGVyIHRoZSBpbnN0YW5jZSBpcyBjb25zaWRlcmVkIGRlc3Ryb3llZC4gKi9cclxuICBkZXN0cm95ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgdGhlIGVsZW1lbnRzIG9mIGEgc2Nyb2xsYmFyLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxiYXJFbGVtZW50cyB7XHJcbiAgLyoqXHJcbiAgICogVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgc2Nyb2xsYmFyLlxyXG4gICAqIFRoZSBIVE1MIHN0cnVjdHVyZSBsb29rcyBsaWtlIHRoaXM6XHJcbiAgICogPHNjcm9sbGJhcj5cclxuICAgKiAgIDx0cmFjaz5cclxuICAgKiAgICAgPGhhbmRsZSAvPlxyXG4gICAqICAgPC90cmFjaz5cclxuICAgKiA8L3Njcm9sbGJhcj5cclxuICAgKi9cclxuICBzY3JvbGxiYXI6IEhUTUxFbGVtZW50O1xyXG4gIC8qKiBUaGUgdHJhY2sgZWxlbWVudCBvZiB0aGUgc2Nyb2xsYmFyLiAqL1xyXG4gIHRyYWNrOiBIVE1MRWxlbWVudDtcclxuICAvKiogVGhlIGhhbmRsZSBlbGVtZW50IG9mIHRoZSBzY3JvbGxiYXIuICovXHJcbiAgaGFuZGxlOiBIVE1MRWxlbWVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgZWxlbWVudHMgb2YgYSBzY3JvbGxiYXIgYW5kIHByb3ZpZGVzIHRoZSBwb3NzaWJpbGl0eSB0byBjbG9uZSB0aGVtLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBDbG9uZWFibGVTY3JvbGxiYXJFbGVtZW50cyBleHRlbmRzIFNjcm9sbGJhckVsZW1lbnRzIHtcclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhlIGN1cnJlbnQgc2Nyb2xsYmFyIGFuZCByZXR1cm5zIHRoZSBjbG9uZWQgZWxlbWVudHMuXHJcbiAgICogVGhlIHJldHVybmVkIGVsZW1lbnRzIGFyZW4ndCBhZGRlZCB0byB0aGUgRE9NLlxyXG4gICAqL1xyXG4gIGNsb25lKCk6IFNjcm9sbGJhckVsZW1lbnRzO1xyXG59XHJcblxyXG4vKipcclxuICogRGVzY3JpYmVzIHRoZSBlbGVtZW50cyBvZiBhIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50cyB7XHJcbiAgLyoqIFRoZSBlbGVtZW50IHRoZSBpbnN0YW5jZSB3YXMgYXBwbGllZCB0by4gKi9cclxuICB0YXJnZXQ6IEhUTUxFbGVtZW50O1xyXG4gIC8qKiBUaGUgaG9zdCBlbGVtZW50LiBJdHMgdGhlIHJvb3Qgb2YgYWxsIG90aGVyIGVsZW1lbnRzLiAqL1xyXG4gIGhvc3Q6IEhUTUxFbGVtZW50O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBlbGVtZW50IHdoaWNoIGlzIHJlc3BvbnNpYmxlIHRvIGFwcGx5IGNvcnJlY3QgcGFkZGluZ3MuXHJcbiAgICogRGVwZW5kaW5nIG9uIHRoZSBJbml0aWFsaXphdGlvbiBpdCBjYW4gYmUgdGhlIHNhbWUgYXMgdGhlIHZpZXdwb3J0IGVsZW1lbnQuXHJcbiAgICovXHJcbiAgcGFkZGluZzogSFRNTEVsZW1lbnQ7XHJcbiAgLyoqIFRoZSBlbGVtZW50IHdoaWNoIGlzIHJlc3BvbnNpYmxlIHRvIGRvIGFueSBzY3JvbGxpbmcuICovXHJcbiAgdmlld3BvcnQ6IEhUTUxFbGVtZW50O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBlbGVtZW50IHdoaWNoIGlzIHJlc3BvbnNpYmxlIHRvIGhvbGQgdGhlIGNvbnRlbnQuXHJcbiAgICogRGVwZW5kaW5nIG9uIHRoZSBJbml0aWFsaXphdGlvbiBpdCBjYW4gYmUgdGhlIHNhbWUgYXMgdGhlIHZpZXdwb3J0IGVsZW1lbnQuXHJcbiAgICovXHJcbiAgY29udGVudDogSFRNTEVsZW1lbnQ7XHJcbiAgLyoqXHJcbiAgICogVGhlIGVsZW1lbnQgdGhyb3VnaCB3aGljaCB5b3UgY2FuIGdldCB0aGUgY3VycmVudCBgc2Nyb2xsTGVmdGAgb3IgYHNjcm9sbFRvcGAgb2Zmc2V0LlxyXG4gICAqIERlcGVuZGluZyBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXQgY2FuIGJlIHRoZSBzYW1lIGFzIHRoZSB2aWV3cG9ydCBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHNjcm9sbE9mZnNldEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBlbGVtZW50IHRocm91Z2ggd2hpY2ggeW91IGNhbiBhZGQgYHNjcm9sbGAgZXZlbnRzLlxyXG4gICAqIERlcGVuZGluZyBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXQgY2FuIGJlIHRoZSBzYW1lIGFzIHRoZSB2aWV3cG9ydCBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHNjcm9sbEV2ZW50RWxlbWVudDogSFRNTEVsZW1lbnQgfCBEb2N1bWVudDtcclxuICAvKiogVGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIGVsZW1lbnRzLiAqL1xyXG4gIHNjcm9sbGJhckhvcml6b250YWw6IENsb25lYWJsZVNjcm9sbGJhckVsZW1lbnRzO1xyXG4gIC8qKiBUaGUgdmVydGljYWwgc2Nyb2xsYmFyIGVsZW1lbnRzLiAqL1xyXG4gIHNjcm9sbGJhclZlcnRpY2FsOiBDbG9uZWFibGVTY3JvbGxiYXJFbGVtZW50cztcclxufVxyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBPdmVybGF5U2Nyb2xsYmFycyB7XHJcbiAgLyoqIEdldHMgdGhlIGN1cnJlbnQgb3B0aW9ucyBvZiB0aGUgaW5zdGFuY2UuICovXHJcbiAgb3B0aW9ucygpOiBPcHRpb25zO1xyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIG9wdGlvbnMgb2YgdGhlIGluc3RhbmNlLlxyXG4gICAqIElmIHRoZSBuZXcgb3B0aW9ucyBhcmUgcGFydGlhbGx5IGZpbGxlZCwgdGhleSdyZSBkZWVwbHkgbWVyZ2VkIHdpdGggZWl0aGVyIHRoZSBjdXJyZW50IG9wdGlvbnMgb3IgdGhlIGN1cnJlbnQgZGVmYXVsdCBvcHRpb25zLlxyXG4gICAqIEBwYXJhbSBuZXdPcHRpb25zIFRoZSBuZXcgb3B0aW9ucyB3aGljaCBzaG91bGQgYmUgYXBwbGllZC5cclxuICAgKiBAcGFyYW0gcHVyZSBXaGV0aGVyIHRoZSBvcHRpb25zIHNob3VsZCBiZSByZXNldCBiZWZvcmUgdGhlIG5ldyBvcHRpb25zIGFyZSBhZGRlZC5cclxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IG9wdGlvbnMgb2YgdGhlIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIG9wdGlvbnMobmV3T3B0aW9uczogUGFydGlhbE9wdGlvbnMsIHB1cmU/OiBib29sZWFuKTogT3B0aW9ucztcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSBldmVudExpc3RlbmVycyBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGFkZGVkIGxpc3RlbmVycy5cclxuICAgKiBAcGFyYW0gcHVyZSBXaGV0aGVyIGFsbCBhbHJlYWR5IGFkZGVkIGV2ZW50IGxpc3RlbmVycyBzaG91bGQgYmUgcmVtb3ZlZCBiZWZvcmUgdGhlIG5ldyBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxyXG4gICAqIEByZXR1cm5zIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZW1vdmVzIHRoZSBhZGRlZCBsaXN0ZW5lcnMuXHJcbiAgICovXHJcbiAgb24oZXZlbnRMaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzLCBwdXJlPzogYm9vbGVhbik6ICgpID0+IHZvaWQ7XHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHNpbmdsZSBldmVudCBsaXN0ZW5lciB0byB0aGUgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgd2hpY2ggaXMgaW52b2tlZCBvbiB0aGF0IGV2ZW50LlxyXG4gICAqIEByZXR1cm5zIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZW1vdmVzIHRoZSBhZGRlZCBsaXN0ZW5lcnMuXHJcbiAgICovXHJcbiAgb248TiBleHRlbmRzIGtleW9mIEV2ZW50TGlzdGVuZXJBcmdzPihuYW1lOiBOLCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxOPik6ICgpID0+IHZvaWQ7XHJcbiAgLyoqXHJcbiAgICogQWRkcyBtdWx0aXBsZSBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVycyB3aGljaCBhcmUgaW52b2tlZCBvbiB0aGF0IGV2ZW50LlxyXG4gICAqIEByZXR1cm5zIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZW1vdmVzIHRoZSBhZGRlZCBsaXN0ZW5lcnMuXHJcbiAgICovXHJcbiAgb248TiBleHRlbmRzIGtleW9mIEV2ZW50TGlzdGVuZXJBcmdzPihuYW1lOiBOLCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxOPltdKTogKCkgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhIHNpbmdsZSBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB3aGljaCBzaGFsbCBiZSByZW1vdmVkLlxyXG4gICAqL1xyXG4gIG9mZjxOIGV4dGVuZHMga2V5b2YgRXZlbnRMaXN0ZW5lckFyZ3M+KG5hbWU6IE4sIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPE4+KTogdm9pZDtcclxuICAvKipcclxuICAgKiBSZW1vdmVzIG11bHRpcGxlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lcnMgd2hpY2ggc2hhbGwgYmUgcmVtb3ZlZC5cclxuICAgKi9cclxuICBvZmY8TiBleHRlbmRzIGtleW9mIEV2ZW50TGlzdGVuZXJBcmdzPihuYW1lOiBOLCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxOPltdKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIGZvcmNlIFdoZXRoZXIgdGhlIHVwZGF0ZSBzaG91bGQgZm9yY2UgdGhlIGNhY2hlIHRvIGJlIGludmFsaWRhdGVkLlxyXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgYHVwZGF0ZWAgZXZlbnQgd2FzIHRyaWdnZXJlZCB0aHJvdWdoIHRoaXMgdXBkYXRlLlxyXG4gICAqIFRoZSB1cGRhdGUgZXZlbnQgaXMgb25seSB0cmlnZ2VyZWQgaWYgc29tZXRoaW5nIGNoYW5nZWQgYmVjYXVzZSBvZiB0aGlzIHVwZGF0ZS5cclxuICAgKi9cclxuICB1cGRhdGUoZm9yY2U/OiBib29sZWFuKTogYm9vbGVhbjtcclxuICAvKiogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhlIGluc3RhbmNlLiAqL1xyXG4gIHN0YXRlKCk6IFN0YXRlO1xyXG4gIC8qKiBSZXR1cm5zIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5zdGFuY2UuICovXHJcbiAgZWxlbWVudHMoKTogRWxlbWVudHM7XHJcbiAgLyoqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBhbmQgcmVtb3ZlcyBhbGwgYWRkZWQgZWxlbWVudHMuICovXHJcbiAgZGVzdHJveSgpOiB2b2lkO1xyXG4gIC8qKiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkIHBsdWdpbiBvciBgdW5kZWZpbmVkYCBpZiBubyBpbnN0YW5jZSB3YXMgZm91bmQuICovXHJcbiAgcGx1Z2luPFAgZXh0ZW5kcyBJbnN0YW5jZVBsdWdpbj4ob3NQbHVnaW46IFApOiBJbmZlckluc3RhbmNlUGx1Z2luTW9kdWxlSW5zdGFuY2U8UD4gfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBPdmVybGF5U2Nyb2xsYmFyczogT3ZlcmxheVNjcm9sbGJhcnNTdGF0aWMgPSAoXHJcbiAgdGFyZ2V0OiBJbml0aWFsaXphdGlvblRhcmdldCxcclxuICBvcHRpb25zPzogUGFydGlhbE9wdGlvbnMsXHJcbiAgZXZlbnRMaXN0ZW5lcnM/OiBFdmVudExpc3RlbmVyc1xyXG4pID0+IHtcclxuICBjb25zdCB7IF9nZXREZWZhdWx0T3B0aW9ucyB9ID0gZ2V0RW52aXJvbm1lbnQoKTtcclxuICBjb25zdCB0YXJnZXRJc0VsZW1lbnQgPSBpc0hUTUxFbGVtZW50KHRhcmdldCk7XHJcbiAgY29uc3QgaW5zdGFuY2VUYXJnZXQgPSB0YXJnZXRJc0VsZW1lbnQgPyB0YXJnZXQgOiB0YXJnZXQudGFyZ2V0O1xyXG4gIGNvbnN0IHBvdGVudGlhbEluc3RhbmNlID0gZ2V0SW5zdGFuY2UoaW5zdGFuY2VUYXJnZXQpO1xyXG4gIGlmIChvcHRpb25zICYmICFwb3RlbnRpYWxJbnN0YW5jZSkge1xyXG4gICAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgZGVzdHJveUZuczogKCgpID0+IHZvaWQpW10gPSBbXTtcclxuICAgIGNvbnN0IGluc3RhbmNlUGx1Z2luTW9kdWxlSW5zdGFuY2VzOiBSZWNvcmQ8c3RyaW5nLCBQbHVnaW5Nb2R1bGVJbnN0YW5jZT4gPSB7fTtcclxuICAgIGNvbnN0IHZhbGlkYXRlT3B0aW9ucyA9IChuZXdPcHRpb25zOiBQYXJ0aWFsT3B0aW9ucykgPT4ge1xyXG4gICAgICBjb25zdCBuZXdPcHRpb25zV2l0aG91dFVuZGVmaW5lZCA9IHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMobmV3T3B0aW9ucywgdHJ1ZSk7XHJcbiAgICAgIGNvbnN0IHBsdWdpblZhbGlkYXRlID0gZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2U8dHlwZW9mIE9wdGlvbnNWYWxpZGF0aW9uUGx1Z2luPihcclxuICAgICAgICBvcHRpb25zVmFsaWRhdGlvblBsdWdpbk1vZHVsZU5hbWVcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHBsdWdpblZhbGlkYXRlXHJcbiAgICAgICAgPyBwbHVnaW5WYWxpZGF0ZShuZXdPcHRpb25zV2l0aG91dFVuZGVmaW5lZCwgdHJ1ZSlcclxuICAgICAgICA6IG5ld09wdGlvbnNXaXRob3V0VW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGN1cnJlbnRPcHRpb25zOiBSZWFkb25seU9wdGlvbnMgPSBhc3NpZ25EZWVwKFxyXG4gICAgICB7fSxcclxuICAgICAgX2dldERlZmF1bHRPcHRpb25zKCksXHJcbiAgICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IFthZGRQbHVnaW5FdmVudCwgcmVtb3ZlUGx1Z2luRXZlbnRzLCB0cmlnZ2VyUGx1Z2luRXZlbnRdID1cclxuICAgICAgY3JlYXRlRXZlbnRMaXN0ZW5lckh1YjxFdmVudExpc3RlbmVyQXJncz4oKTtcclxuICAgIGNvbnN0IFthZGRJbnN0YW5jZUV2ZW50LCByZW1vdmVJbnN0YW5jZUV2ZW50cywgdHJpZ2dlckluc3RhbmNlRXZlbnRdID1cclxuICAgICAgY3JlYXRlRXZlbnRMaXN0ZW5lckh1YihldmVudExpc3RlbmVycyk7XHJcbiAgICBjb25zdCB0cmlnZ2VyRXZlbnQ6IHR5cGVvZiB0cmlnZ2VyUGx1Z2luRXZlbnQgPSAobmFtZSwgYXJncykgPT4ge1xyXG4gICAgICB0cmlnZ2VySW5zdGFuY2VFdmVudChuYW1lLCBhcmdzKTtcclxuICAgICAgdHJpZ2dlclBsdWdpbkV2ZW50KG5hbWUsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IFtzZXR1cHNDb25zdHJ1Y3QsIHNldHVwc1VwZGF0ZSwgc2V0dXBzU3RhdGUsIHNldHVwc0VsZW1lbnRzLCBzZXR1cHNDYW5jZWxlZF0gPVxyXG4gICAgICBjcmVhdGVTZXR1cHMoXHJcbiAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgIGN1cnJlbnRPcHRpb25zLFxyXG4gICAgICAgICgpID0+IGRlc3Ryb3llZCxcclxuICAgICAgICAoeyBfY2hhbmdlZE9wdGlvbnMsIF9mb3JjZSB9LCB7IF9vYnNlcnZlcnNVcGRhdGVIaW50cywgX3N0cnVjdHVyZVVwZGF0ZUhpbnRzIH0pID0+IHtcclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgX3NpemVDaGFuZ2VkLFxyXG4gICAgICAgICAgICBfZGlyZWN0aW9uQ2hhbmdlZCxcclxuICAgICAgICAgICAgX2hlaWdodEludHJpbnNpY0NoYW5nZWQsXHJcbiAgICAgICAgICAgIF9jb250ZW50TXV0YXRpb24sXHJcbiAgICAgICAgICAgIF9ob3N0TXV0YXRpb24sXHJcbiAgICAgICAgICAgIF9hcHBlYXIsXHJcbiAgICAgICAgICB9ID0gX29ic2VydmVyc1VwZGF0ZUhpbnRzO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgX292ZXJmbG93RWRnZUNoYW5nZWQsXHJcbiAgICAgICAgICAgIF9vdmVyZmxvd0Ftb3VudENoYW5nZWQsXHJcbiAgICAgICAgICAgIF9vdmVyZmxvd1N0eWxlQ2hhbmdlZCxcclxuICAgICAgICAgICAgX3Njcm9sbENvb3JkaW5hdGVzQ2hhbmdlZCxcclxuICAgICAgICAgIH0gPSBfc3RydWN0dXJlVXBkYXRlSGludHM7XHJcblxyXG4gICAgICAgICAgdHJpZ2dlckV2ZW50KCd1cGRhdGVkJywgW1xyXG4gICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHVwZGF0ZUhpbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBzaXplQ2hhbmdlZDogISFfc2l6ZUNoYW5nZWQsXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25DaGFuZ2VkOiAhIV9kaXJlY3Rpb25DaGFuZ2VkLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0SW50cmluc2ljQ2hhbmdlZDogISFfaGVpZ2h0SW50cmluc2ljQ2hhbmdlZCxcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93RWRnZUNoYW5nZWQ6ICEhX292ZXJmbG93RWRnZUNoYW5nZWQsXHJcbiAgICAgICAgICAgICAgICBvdmVyZmxvd0Ftb3VudENoYW5nZWQ6ICEhX292ZXJmbG93QW1vdW50Q2hhbmdlZCxcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93U3R5bGVDaGFuZ2VkOiAhIV9vdmVyZmxvd1N0eWxlQ2hhbmdlZCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbENvb3JkaW5hdGVzQ2hhbmdlZDogISFfc2Nyb2xsQ29vcmRpbmF0ZXNDaGFuZ2VkLFxyXG4gICAgICAgICAgICAgICAgY29udGVudE11dGF0aW9uOiAhIV9jb250ZW50TXV0YXRpb24sXHJcbiAgICAgICAgICAgICAgICBob3N0TXV0YXRpb246ICEhX2hvc3RNdXRhdGlvbixcclxuICAgICAgICAgICAgICAgIGFwcGVhcjogISFfYXBwZWFyLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgY2hhbmdlZE9wdGlvbnM6IF9jaGFuZ2VkT3B0aW9ucyB8fCB7fSxcclxuICAgICAgICAgICAgICBmb3JjZTogISFfZm9yY2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAoc2Nyb2xsRXZlbnQpID0+IHRyaWdnZXJFdmVudCgnc2Nyb2xsJywgW2luc3RhbmNlLCBzY3JvbGxFdmVudF0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgY29uc3QgZGVzdHJveSA9IChjYW5jZWxlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICByZW1vdmVJbnN0YW5jZShpbnN0YW5jZVRhcmdldCk7XHJcbiAgICAgIHJ1bkVhY2hBbmRDbGVhcihkZXN0cm95Rm5zKTtcclxuXHJcbiAgICAgIGRlc3Ryb3llZCA9IHRydWU7XHJcblxyXG4gICAgICB0cmlnZ2VyRXZlbnQoJ2Rlc3Ryb3llZCcsIFtpbnN0YW5jZSwgY2FuY2VsZWRdKTtcclxuICAgICAgcmVtb3ZlUGx1Z2luRXZlbnRzKCk7XHJcbiAgICAgIHJlbW92ZUluc3RhbmNlRXZlbnRzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGluc3RhbmNlOiBPdmVybGF5U2Nyb2xsYmFycyA9IHtcclxuICAgICAgb3B0aW9ucyhuZXdPcHRpb25zPzogUGFydGlhbE9wdGlvbnMsIHB1cmU/OiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKG5ld09wdGlvbnMpIHtcclxuICAgICAgICAgIGNvbnN0IGJhc2UgPSBwdXJlID8gX2dldERlZmF1bHRPcHRpb25zKCkgOiB7fTtcclxuICAgICAgICAgIGNvbnN0IGNoYW5nZWRPcHRpb25zID0gZ2V0T3B0aW9uc0RpZmYoXHJcbiAgICAgICAgICAgIGN1cnJlbnRPcHRpb25zLFxyXG4gICAgICAgICAgICBhc3NpZ25EZWVwKGJhc2UsIHZhbGlkYXRlT3B0aW9ucyhuZXdPcHRpb25zKSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QoY2hhbmdlZE9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGFzc2lnbkRlZXAoY3VycmVudE9wdGlvbnMsIGNoYW5nZWRPcHRpb25zKTtcclxuICAgICAgICAgICAgc2V0dXBzVXBkYXRlKHsgX2NoYW5nZWRPcHRpb25zOiBjaGFuZ2VkT3B0aW9ucyB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzc2lnbkRlZXAoe30sIGN1cnJlbnRPcHRpb25zKTtcclxuICAgICAgfSxcclxuICAgICAgb246IGFkZEluc3RhbmNlRXZlbnQsXHJcbiAgICAgIG9mZjogKG5hbWUsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKG5hbWUgJiYgbGlzdGVuZXIpIHtcclxuICAgICAgICAgIHJlbW92ZUluc3RhbmNlRXZlbnRzKG5hbWUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHN0YXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHsgX29ic2VydmVyc1NldHVwU3RhdGUsIF9zdHJ1Y3R1cmVTZXR1cFN0YXRlIH0gPSBzZXR1cHNTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHsgX2RpcmVjdGlvbklzUlRMIH0gPSBfb2JzZXJ2ZXJzU2V0dXBTdGF0ZTtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBfb3ZlcmZsb3dFZGdlLFxyXG4gICAgICAgICAgX292ZXJmbG93QW1vdW50LFxyXG4gICAgICAgICAgX292ZXJmbG93U3R5bGUsXHJcbiAgICAgICAgICBfaGFzT3ZlcmZsb3csXHJcbiAgICAgICAgICBfcGFkZGluZyxcclxuICAgICAgICAgIF9wYWRkaW5nQWJzb2x1dGUsXHJcbiAgICAgICAgICBfc2Nyb2xsQ29vcmRpbmF0ZXMsXHJcbiAgICAgICAgfSA9IF9zdHJ1Y3R1cmVTZXR1cFN0YXRlO1xyXG4gICAgICAgIHJldHVybiBhc3NpZ25EZWVwKFxyXG4gICAgICAgICAge30sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93RWRnZTogX292ZXJmbG93RWRnZSxcclxuICAgICAgICAgICAgb3ZlcmZsb3dBbW91bnQ6IF9vdmVyZmxvd0Ftb3VudCxcclxuICAgICAgICAgICAgb3ZlcmZsb3dTdHlsZTogX292ZXJmbG93U3R5bGUsXHJcbiAgICAgICAgICAgIGhhc092ZXJmbG93OiBfaGFzT3ZlcmZsb3csXHJcbiAgICAgICAgICAgIHNjcm9sbENvb3JkaW5hdGVzOiB7XHJcbiAgICAgICAgICAgICAgc3RhcnQ6IF9zY3JvbGxDb29yZGluYXRlcy5fc3RhcnQsXHJcbiAgICAgICAgICAgICAgZW5kOiBfc2Nyb2xsQ29vcmRpbmF0ZXMuX2VuZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFkZGluZzogX3BhZGRpbmcsXHJcbiAgICAgICAgICAgIHBhZGRpbmdBYnNvbHV0ZTogX3BhZGRpbmdBYnNvbHV0ZSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uUlRMOiBfZGlyZWN0aW9uSXNSVEwsXHJcbiAgICAgICAgICAgIGRlc3Ryb3llZCxcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAgICBlbGVtZW50cygpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBfdGFyZ2V0LFxyXG4gICAgICAgICAgX2hvc3QsXHJcbiAgICAgICAgICBfcGFkZGluZyxcclxuICAgICAgICAgIF92aWV3cG9ydCxcclxuICAgICAgICAgIF9jb250ZW50LFxyXG4gICAgICAgICAgX3Njcm9sbE9mZnNldEVsZW1lbnQsXHJcbiAgICAgICAgICBfc2Nyb2xsRXZlbnRFbGVtZW50LFxyXG4gICAgICAgIH0gPSBzZXR1cHNFbGVtZW50cy5fc3RydWN0dXJlU2V0dXBFbGVtZW50cztcclxuICAgICAgICBjb25zdCB7IF9ob3Jpem9udGFsLCBfdmVydGljYWwgfSA9IHNldHVwc0VsZW1lbnRzLl9zY3JvbGxiYXJzU2V0dXBFbGVtZW50cztcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGVTY3JvbGxiYXJTdHJ1Y3R1cmUgPSAoXHJcbiAgICAgICAgICBzY3JvbGxiYXJTdHJ1Y3R1cmU6IFNjcm9sbGJhclN0cnVjdHVyZVxyXG4gICAgICAgICk6IFNjcm9sbGJhckVsZW1lbnRzID0+IHtcclxuICAgICAgICAgIGNvbnN0IHsgX2hhbmRsZSwgX3RyYWNrLCBfc2Nyb2xsYmFyIH0gPSBzY3JvbGxiYXJTdHJ1Y3R1cmU7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY3JvbGxiYXI6IF9zY3JvbGxiYXIsXHJcbiAgICAgICAgICAgIHRyYWNrOiBfdHJhY2ssXHJcbiAgICAgICAgICAgIGhhbmRsZTogX2hhbmRsZSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGVTY3JvbGxiYXJzU2V0dXBFbGVtZW50ID0gKFxyXG4gICAgICAgICAgc2Nyb2xsYmFyc1NldHVwRWxlbWVudDogU2Nyb2xsYmFyc1NldHVwRWxlbWVudFxyXG4gICAgICAgICk6IENsb25lYWJsZVNjcm9sbGJhckVsZW1lbnRzID0+IHtcclxuICAgICAgICAgIGNvbnN0IHsgX3Njcm9sbGJhclN0cnVjdHVyZXMsIF9jbG9uZSB9ID0gc2Nyb2xsYmFyc1NldHVwRWxlbWVudDtcclxuICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRTdHJ1Y3R1cmUgPSB0cmFuc2xhdGVTY3JvbGxiYXJTdHJ1Y3R1cmUoX3Njcm9sbGJhclN0cnVjdHVyZXNbMF0pO1xyXG5cclxuICAgICAgICAgIHJldHVybiBhc3NpZ25EZWVwKHt9LCB0cmFuc2xhdGVkU3RydWN0dXJlLCB7XHJcbiAgICAgICAgICAgIGNsb25lOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlU2Nyb2xsYmFyU3RydWN0dXJlKF9jbG9uZSgpKTtcclxuICAgICAgICAgICAgICBzZXR1cHNVcGRhdGUoeyBfY2xvbmVTY3JvbGxiYXI6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGFzc2lnbkRlZXAoXHJcbiAgICAgICAgICB7fSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdGFyZ2V0OiBfdGFyZ2V0LFxyXG4gICAgICAgICAgICBob3N0OiBfaG9zdCxcclxuICAgICAgICAgICAgcGFkZGluZzogX3BhZGRpbmcgfHwgX3ZpZXdwb3J0LFxyXG4gICAgICAgICAgICB2aWV3cG9ydDogX3ZpZXdwb3J0LFxyXG4gICAgICAgICAgICBjb250ZW50OiBfY29udGVudCB8fCBfdmlld3BvcnQsXHJcbiAgICAgICAgICAgIHNjcm9sbE9mZnNldEVsZW1lbnQ6IF9zY3JvbGxPZmZzZXRFbGVtZW50LFxyXG4gICAgICAgICAgICBzY3JvbGxFdmVudEVsZW1lbnQ6IF9zY3JvbGxFdmVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgIHNjcm9sbGJhckhvcml6b250YWw6IHRyYW5zbGF0ZVNjcm9sbGJhcnNTZXR1cEVsZW1lbnQoX2hvcml6b250YWwpLFxyXG4gICAgICAgICAgICBzY3JvbGxiYXJWZXJ0aWNhbDogdHJhbnNsYXRlU2Nyb2xsYmFyc1NldHVwRWxlbWVudChfdmVydGljYWwpLFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHVwZGF0ZTogKF9mb3JjZT86IGJvb2xlYW4pID0+IHNldHVwc1VwZGF0ZSh7IF9mb3JjZSwgX3Rha2VSZWNvcmRzOiB0cnVlIH0pLFxyXG4gICAgICBkZXN0cm95OiBiaW5kKGRlc3Ryb3ksIGZhbHNlKSxcclxuICAgICAgcGx1Z2luOiA8UCBleHRlbmRzIEluc3RhbmNlUGx1Z2luPihwbHVnaW46IFApID0+XHJcbiAgICAgICAgaW5zdGFuY2VQbHVnaW5Nb2R1bGVJbnN0YW5jZXNba2V5cyhwbHVnaW4pWzBdXSBhc1xyXG4gICAgICAgICAgfCBJbmZlckluc3RhbmNlUGx1Z2luTW9kdWxlSW5zdGFuY2U8UD5cclxuICAgICAgICAgIHwgdW5kZWZpbmVkLFxyXG4gICAgfTtcclxuXHJcbiAgICBwdXNoKGRlc3Ryb3lGbnMsIFtzZXR1cHNDYW5jZWxlZF0pO1xyXG5cclxuICAgIC8vIHZhbGlkIGluc2lkZSBwbHVnaW5zXHJcbiAgICBhZGRJbnN0YW5jZShpbnN0YW5jZVRhcmdldCwgaW5zdGFuY2UpO1xyXG5cclxuICAgIC8vIGluaXQgcGx1Z2luc1xyXG4gICAgcmVnaXN0ZXJQbHVnaW5Nb2R1bGVJbnN0YW5jZXMocGx1Z2luTW9kdWxlcywgT3ZlcmxheVNjcm9sbGJhcnMsIFtcclxuICAgICAgaW5zdGFuY2UsXHJcbiAgICAgIGFkZFBsdWdpbkV2ZW50LFxyXG4gICAgICBpbnN0YW5jZVBsdWdpbk1vZHVsZUluc3RhbmNlcyxcclxuICAgIF0pO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgY2FuY2VsSW5pdGlhbGl6YXRpb24oXHJcbiAgICAgICAgc2V0dXBzRWxlbWVudHMuX3N0cnVjdHVyZVNldHVwRWxlbWVudHMuX2lzQm9keSxcclxuICAgICAgICAhdGFyZ2V0SXNFbGVtZW50ICYmIHRhcmdldC5jYW5jZWxcclxuICAgICAgKVxyXG4gICAgKSB7XHJcbiAgICAgIGRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBwdXNoKGRlc3Ryb3lGbnMsIHNldHVwc0NvbnN0cnVjdCgpKTtcclxuXHJcbiAgICB0cmlnZ2VyRXZlbnQoJ2luaXRpYWxpemVkJywgW2luc3RhbmNlXSk7XHJcblxyXG4gICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH1cclxuICByZXR1cm4gcG90ZW50aWFsSW5zdGFuY2UhO1xyXG59O1xyXG5cclxuT3ZlcmxheVNjcm9sbGJhcnMucGx1Z2luID0gKHBsdWdpbnM6IFBsdWdpbiB8IFBsdWdpbltdKSA9PiB7XHJcbiAgY29uc3QgaXNBcnIgPSBpc0FycmF5KHBsdWdpbnMpO1xyXG4gIGNvbnN0IHBsdWdpbnNUb0FkZDogUGx1Z2luPHN0cmluZywgdm9pZCB8IFBsdWdpbk1vZHVsZUluc3RhbmNlLCB2b2lkIHwgUGx1Z2luTW9kdWxlSW5zdGFuY2U+W10gPVxyXG4gICAgaXNBcnIgPyBwbHVnaW5zIDogW3BsdWdpbnNdO1xyXG4gIGNvbnN0IHJlc3VsdCA9IHBsdWdpbnNUb0FkZC5tYXAoXHJcbiAgICAocGx1Z2luKSA9PiByZWdpc3RlclBsdWdpbk1vZHVsZUluc3RhbmNlcyhwbHVnaW4sIE92ZXJsYXlTY3JvbGxiYXJzKVswXVxyXG4gICk7XHJcbiAgYWRkUGx1Z2lucyhwbHVnaW5zVG9BZGQpO1xyXG4gIHJldHVybiBpc0FyciA/IHJlc3VsdCA6IChyZXN1bHRbMF0gYXMgYW55KTtcclxufTtcclxuT3ZlcmxheVNjcm9sbGJhcnMudmFsaWQgPSAob3NJbnN0YW5jZTogYW55KTogb3NJbnN0YW5jZSBpcyBPdmVybGF5U2Nyb2xsYmFycyA9PiB7XHJcbiAgY29uc3QgaGFzRWxtc0ZuID0gb3NJbnN0YW5jZSAmJiAob3NJbnN0YW5jZSBhcyBPdmVybGF5U2Nyb2xsYmFycykuZWxlbWVudHM7XHJcbiAgY29uc3QgZWxlbWVudHMgPSBpc0Z1bmN0aW9uKGhhc0VsbXNGbikgJiYgaGFzRWxtc0ZuKCk7XHJcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZWxlbWVudHMpICYmICEhZ2V0SW5zdGFuY2UoZWxlbWVudHMudGFyZ2V0KTtcclxufTtcclxuT3ZlcmxheVNjcm9sbGJhcnMuZW52ID0gKCkgPT4ge1xyXG4gIGNvbnN0IHtcclxuICAgIF9uYXRpdmVTY3JvbGxiYXJzU2l6ZSxcclxuICAgIF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQsXHJcbiAgICBfbmF0aXZlU2Nyb2xsYmFyc0hpZGluZyxcclxuICAgIF9zY3JvbGxUaW1lbGluZSxcclxuICAgIF9zdGF0aWNEZWZhdWx0SW5pdGlhbGl6YXRpb24sXHJcbiAgICBfc3RhdGljRGVmYXVsdE9wdGlvbnMsXHJcbiAgICBfZ2V0RGVmYXVsdEluaXRpYWxpemF0aW9uLFxyXG4gICAgX3NldERlZmF1bHRJbml0aWFsaXphdGlvbixcclxuICAgIF9nZXREZWZhdWx0T3B0aW9ucyxcclxuICAgIF9zZXREZWZhdWx0T3B0aW9ucyxcclxuICB9ID0gZ2V0RW52aXJvbm1lbnQoKTtcclxuICByZXR1cm4gYXNzaWduRGVlcChcclxuICAgIHt9LFxyXG4gICAge1xyXG4gICAgICBzY3JvbGxiYXJzU2l6ZTogX25hdGl2ZVNjcm9sbGJhcnNTaXplLFxyXG4gICAgICBzY3JvbGxiYXJzT3ZlcmxhaWQ6IF9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQsXHJcbiAgICAgIHNjcm9sbGJhcnNIaWRpbmc6IF9uYXRpdmVTY3JvbGxiYXJzSGlkaW5nLFxyXG4gICAgICBzY3JvbGxUaW1lbGluZTogX3Njcm9sbFRpbWVsaW5lLFxyXG4gICAgICBzdGF0aWNEZWZhdWx0SW5pdGlhbGl6YXRpb246IF9zdGF0aWNEZWZhdWx0SW5pdGlhbGl6YXRpb24sXHJcbiAgICAgIHN0YXRpY0RlZmF1bHRPcHRpb25zOiBfc3RhdGljRGVmYXVsdE9wdGlvbnMsXHJcblxyXG4gICAgICBnZXREZWZhdWx0SW5pdGlhbGl6YXRpb246IF9nZXREZWZhdWx0SW5pdGlhbGl6YXRpb24sXHJcbiAgICAgIHNldERlZmF1bHRJbml0aWFsaXphdGlvbjogX3NldERlZmF1bHRJbml0aWFsaXphdGlvbixcclxuICAgICAgZ2V0RGVmYXVsdE9wdGlvbnM6IF9nZXREZWZhdWx0T3B0aW9ucyxcclxuICAgICAgc2V0RGVmYXVsdE9wdGlvbnM6IF9zZXREZWZhdWx0T3B0aW9ucyxcclxuICAgIH1cclxuICApO1xyXG59O1xyXG5PdmVybGF5U2Nyb2xsYmFycy5ub25jZSA9IHNldE5vbmNlO1xyXG5PdmVybGF5U2Nyb2xsYmFycy50cnVzdGVkVHlwZVBvbGljeSA9IHNldFRydXN0ZWRUeXBlUG9saWN5O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2FjaGUiLCJvcHRpb25zIiwidXBkYXRlIiwibyIsIl9pbml0aWFsVmFsdWUiLCJpIiwiX2VxdWFsIiwidSIsIl9hbHdheXNVcGRhdGVWYWx1ZXMiLCJfdmFsdWUiLCJfcHJldmlvdXMiLCJjYWNoZVVwZGF0ZUNvbnRleHR1YWwiLCJuZXdWYWx1ZSIsImZvcmNlIiwiY3VyciIsIm5ld1ZhbCIsImNoYW5nZWQiLCJjYWNoZVVwZGF0ZUlzb2xhdGVkIiwiZ2V0Q3VycmVudENhY2hlIiwiaXNCcm93c2VyIiwiSFRNTEVsZW1lbnQiLCJ3aW5kb3ciLCJkb2N1bWVudCIsInduZCIsIm1hdGhNYXgiLCJNYXRoIiwibWF4IiwibWF0aE1pbiIsIm1pbiIsIm1hdGhSb3VuZCIsInJvdW5kIiwibWF0aEFicyIsImFicyIsIm1hdGhTaWduIiwic2lnbiIsImNBRiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwickFGIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VCIsInNldFRpbWVvdXQiLCJjbGVhclQiLCJjbGVhclRpbWVvdXQiLCJnZXRBcGkiLCJuYW1lIiwidW5kZWZpbmVkIiwiTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3RvciIsIlJlc2l6ZU9ic2VydmVyQ29uc3RydWN0b3IiLCJzY3JvbGxUIiwiaXNVbmRlZmluZWQiLCJvYmoiLCJpc051bGwiLCJpc051bWJlciIsImlzU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNGdW5jdGlvbiIsImlzQXJyYXkiLCJBcnJheSIsImlzT2JqZWN0IiwiaXNBcnJheUxpa2UiLCJsZW5ndGgiLCJsZW5ndGhDb3JyZWN0Rm9ybWF0IiwiaXNQbGFpbk9iamVjdCIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiaXNIVE1MRWxlbWVudCIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJhbmltYXRpb25DdXJyZW50VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiYW5pbWF0ZU51bWJlciIsImZyb20iLCJ0byIsImR1cmF0aW9uIiwib25GcmFtZSIsImVhc2luZyIsImFuaW1hdGlvbkZyYW1lSWQiLCJ0aW1lU3RhcnQiLCJmaW5hbER1cmF0aW9uIiwiZnJhbWUiLCJjb21wbGV0ZSIsInRpbWVOb3ciLCJ0aW1lRWxhcHNlZCIsInN0b3BBbmltYXRpb24iLCJwZXJjZW50IiwicHJvZ3Jlc3MiLCJhbmltYXRpb25Db21wbGV0ZWQiLCJlYWNoIiwic291cmNlIiwiY2FsbGJhY2siLCJrZXlzIiwia2V5IiwiaW5BcnJheSIsImFyciIsIml0ZW0iLCJpbmRleE9mIiwiY29uY2F0IiwiYSIsImIiLCJwdXNoIiwiYXJyYXkiLCJpdGVtcyIsImFycmF5SXNTaW5nbGVJdGVtIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjcmVhdGVPcktlZXBBcnJheSIsInZhbHVlIiwiaXNFbXB0eUFycmF5IiwiZGVkdXBsaWNhdGVBcnJheSIsIlNldCIsInJ1bkVhY2hBbmRDbGVhciIsImFyZ3MiLCJrZWVwIiwicnVuRm4iLCJmbiIsInN0clBhZGRpbmdUb3AiLCJzdHJQYWRkaW5nUmlnaHQiLCJzdHJQYWRkaW5nTGVmdCIsInN0clBhZGRpbmdCb3R0b20iLCJzdHJNYXJnaW5MZWZ0Iiwic3RyTWFyZ2luUmlnaHQiLCJzdHJNYXJnaW5Cb3R0b20iLCJzdHJPdmVyZmxvd1giLCJzdHJPdmVyZmxvd1kiLCJzdHJXaWR0aCIsInN0ckhlaWdodCIsInN0clZpc2libGUiLCJzdHJIaWRkZW4iLCJzdHJTY3JvbGwiLCJjYXBpdGFsaXplRmlyc3RMZXR0ZXIiLCJzdHIiLCJmaW5hbFN0ciIsIlN0cmluZyIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJlcXVhbCIsInByb3BzIiwicHJvcE11dGF0aW9uIiwicmVzdWx0IiwicHJvcCIsImNvbXBhcmVBIiwiY29tcGFyZUIiLCJlcXVhbFdIIiwiZXF1YWxYWSIsImVxdWFsVFJCTCIsImJpbmQiLCJzZWxmQ2xlYXJUaW1lb3V0IiwidGltZW91dCIsImlkIiwic2V0VEZuIiwiY2xlYXJURm4iLCJnZXREZWJvdW5jZXIiLCJkZWJvdW5jZVRpbWluZyIsImRlYm91bmNlVGltaW5nUmVzdWx0Iiwic2NoZWR1bGUiLCJjbGVhciIsInRhc2siLCJ0aW1lb3V0SWQiLCJfZGVib3VuY2VyIiwiZGVib3VuY2UiLCJmdW5jdGlvblRvRGVib3VuY2UiLCJfZGVib3VuY2VUaW1pbmciLCJfdGltZW91dCIsIl9tYXhEZWJvdW5jZVRpbWluZyIsIl9tYXhEZWxheSIsIlMiLCJfbGVhZGluZyIsIm0iLCJfbWVyZ2VQYXJhbXMiLCJjYW5jZWxNYXhUaW1lb3V0RGVib3VuY2VyIiwiY2FuY2VsVGltZW91dERlYm91bmRlciIsInByZXZBcmd1bWVudHMiLCJsZWFkaW5nSW52b2tlZCIsImludm9rZUZ1bmN0aW9uVG9EZWJvdW5jZSIsInRoaXMiLCJtZXJnZVBhcm1zIiwiZmx1c2giLCJkZWJvdW5jZWRGbiIsImFyZ3VtZW50cyIsInRpbWVvdXREZWJvdW5jZXIiLCJsZWFkaW5nIiwibWF4RGVsYXlEZWJvdW5jZXIiLCJtZXJnZVBhcmFtc1Jlc3VsdCIsImludm9rZWRBcmdzIiwiYm91bmRJbnZva2UiLCJfZmx1c2giLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhc3NpZ25EZWVwIiwidGFyZ2V0Iiwib2JqZWN0MSIsIm9iamVjdDIiLCJvYmplY3QzIiwib2JqZWN0NCIsIm9iamVjdDUiLCJvYmplY3Q2Iiwic291cmNlcyIsIl8iLCJjb3B5IiwiY29weUlzQXJyYXkiLCJzcmMiLCJjbG9uZSIsInJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMiLCJkZWVwIiwiaXNFbXB0eU9iamVjdCIsIm5vb3AiLCJjYXBOdW1iZXIiLCJudW1iZXIiLCJnZXREb21Ub2tlbnNBcnJheSIsInRva2VucyIsInNwbGl0IiwiZmlsdGVyIiwidG9rZW4iLCJnZXRBdHRyIiwiZWxtIiwiYXR0ck5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJoYXNBdHRyIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cnMiLCJhdHRyTmFtZXMiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRycyIsInJlbW92ZUF0dHJpYnV0ZSIsImRvbVRva2VuTGlzdEF0dHIiLCJpbml0aWFsQXJyIiwic2V0RWxtQXR0ciIsImRvbVRva2VuTGlzdE9wZXJhdGlvbiIsIm9wZXJhdGlvblRva2VucyIsIm9wZXJhdGlvbiIsImluaXRpYWxBcnJTZXQiLCJqb2luIiwiX3JlbW92ZSIsInJlbW92ZVRva2VucyIsIl9hZGQiLCJhZGRUb2tlbnMiLCJfaGFzIiwiaGFzVG9rZW5zIiwidG9rZW5TZXQiLCJyZWR1Y2UiLCJib29sZWFuIiwiaW5jbHVkZXMiLCJyZW1vdmVBdHRyQ2xhc3MiLCJhZGRBdHRyQ2xhc3MiLCJhZGRSZW1vdmVBdHRyQ2xhc3MiLCJhZGQiLCJoYXNBdHRyQ2xhc3MiLCJjcmVhdGVEb21Ub2tlbkxpc3RDbGFzcyIsInJlbW92ZUNsYXNzIiwiY2xhc3NOYW1lIiwiYWRkQ2xhc3MiLCJmaW5kIiwic2VsZWN0b3IiLCJyb290RWxtIiwicXVlcnlTZWxlY3RvckFsbCIsImZpbmRGaXJzdCIsInF1ZXJ5U2VsZWN0b3IiLCJpcyIsIm1hdGNoZXMiLCJpc0JvZHlFbGVtZW50IiwiY29udGVudHMiLCJjaGlsZE5vZGVzIiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsImNsb3Nlc3QiLCJnZXRGb2N1c2VkRWxlbWVudCIsImRvYyIsImFjdGl2ZUVsZW1lbnQiLCJsaWVzQmV0d2VlbiIsImhpZ2hCb3VuZGFyeVNlbGVjdG9yIiwiZGVlcEJvdW5kYXJ5U2VsZWN0b3IiLCJjbG9zZXN0SGlnaEJvdW5kYXJ5RWxtIiwiY2xvc2VzdERlZXBCb3VuZGFyeUVsbSIsImRlZXBCb3VuZGFyeUlzVmFsaWQiLCJyZW1vdmVFbGVtZW50cyIsIm5vZGVzIiwibm9kZSIsInBhcmVudEVsbSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGRyZW4iLCJjaGlsZHJlbiIsImNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJ0cnVzdGVkVHlwZVBvbGljeSIsImdldFRydXN0ZWRUeXBlUG9saWN5Iiwic2V0VHJ1c3RlZFR5cGVQb2xpY3kiLCJuZXdUcnVzdGVkVHlwZVBvbGljeSIsImNyZWF0ZURpdiIsImNsYXNzTmFtZXMiLCJkaXYiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRE9NIiwiaHRtbCIsImNyZWF0ZWREaXYiLCJ0cnVzdGVkVHlwZXNQb2xpY3kiLCJ0cmltbWVkSHRtbCIsInRyaW0iLCJpbm5lckhUTUwiLCJjcmVhdGVIVE1MIiwiZ2V0Q1NTVmFsIiwiY29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJ2YWxpZEZpbml0ZU51bWJlciIsIm5vdE5hTiIsImlzRmluaXRlIiwicGFyc2VUb1plcm9Pck51bWJlciIsInBhcnNlRmxvYXQiLCJyb3VuZENzc051bWJlciIsIm51bWJlclRvQ3NzUHgiLCJzZXRTdHlsZXMiLCJzdHlsZXMiLCJyYXdWYWx1ZSIsImVsbVN0eWxlIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsIl91bnVzZWQiLCJnZXRTdHlsZXMiLCJwc2V1ZG9FbG0iLCJnZXRTaW5nbGVTdHlsZSIsImdldFN0eWxlc1Jlc3VsdCIsImdldENvbXB1dGVkU3R5bGUiLCJ0b3BSaWdodEJvdHRvbUxlZnQiLCJwcm9wZXJ0eVByZWZpeCIsInByb3BlcnR5U3VmZml4IiwiZmluYWxQcmVmaXgiLCJmaW5hbFN1ZmZpeCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInQiLCJyIiwibCIsImdldFRyYXNmb3JtVHJhbnNsYXRlVmFsdWUiLCJpc0hvcml6b250YWwiLCJ4IiwieSIsImVsZW1lbnRIYXNEaW1lbnNpb25zIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJnZXRDbGllbnRSZWN0cyIsInplcm9PYmoiLCJ3IiwiaCIsImdldEVsbVdpZHRoSGVpZ2h0UHJvcGVydHkiLCJwcm9wZXJ0eSIsImdldFdpbmRvd1NpemUiLCJjdXN0b21XbmQiLCJnZXRPZmZzZXRTaXplIiwiZ2V0Q2xpZW50U2l6ZSIsImdldFNjcm9sbFNpemUiLCJnZXRGcmFjdGlvbmFsU2l6ZSIsImNzc1dpZHRoIiwiY3NzSGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFzRGltZW5zaW9ucyIsImRvbVJlY3RIYXNEaW1lbnNpb25zIiwicmVjdCIsImRvbVJlY3RBcHBlYXJlZCIsImN1cnJDb250ZW50UmVjdCIsInByZXZDb250ZW50UmVjdCIsInJlY3RIYXNEaW1lbnNpb25zIiwicmVjdEhhZERpbWVuc2lvbnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lcyIsImxpc3RlbmVyIiwiY2FwdHVyZSIsImV2ZW50TmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfcmVmIiwicGFzc2l2ZSIsIl9wYXNzaXZlIiwiX2NhcHR1cmUiLCJvbmNlIiwiX29uY2UiLCJuYXRpdmVPcHRpb25zIiwibWFwIiwiZmluYWxMaXN0ZW5lciIsImV2dCIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0Iiwic3RvcEFuZFByZXZlbnQiLCJzY3JvbGxFbGVtZW50VG8iLCJwb3NpdGlvbiIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJnZXRFbGVtZW50U2Nyb2xsIiwiZ2V0WmVyb1Njcm9sbENvb3JkaW5hdGVzIiwiX3N0YXJ0IiwiX2VuZCIsInNhbml0aXplU2Nyb2xsQ29vcmRpbmF0ZXMiLCJyYXdTY3JvbGxDb29yZGluYXRlcyIsIm92ZXJmbG93QW1vdW50IiwiRCIsIk0iLCJzYW5pdGl6ZUF4aXMiLCJzdGFydCIsImVuZCIsImFtb3VudCIsIm5ld1N0YXJ0IiwibmV3RW5kIiwic3RhcnRBYnMiLCJlbmRBYnMiLCJzdGFydFgiLCJlbmRYIiwic3RhcnRZIiwiZW5kWSIsImlzRGVmYXVsdERpcmVjdGlvblNjcm9sbENvb3JkaW5hdGVzIiwiZ2V0QXhpcyIsImdldFNjcm9sbENvb3JkaW5hdGVzUGVyY2VudCIsImN1cnJlbnRTY3JvbGwiLCJjdXJyZW50IiwiZm9jdXNFbGVtZW50IiwiZWxlbWVudCIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsImZvY3VzVmlzaWJsZSIsIm1hbmFnZUxpc3RlbmVyIiwiY3JlYXRlRXZlbnRMaXN0ZW5lckh1YiIsImluaXRpYWxFdmVudExpc3RlbmVycyIsImV2ZW50cyIsIk1hcCIsInJlbW92ZUV2ZW50IiwiZXZlbnRTZXQiLCJnZXQiLCJjdXJyTGlzdGVuZXIiLCJmb3JFYWNoIiwiYWRkRXZlbnQiLCJuYW1lT3JFdmVudExpc3RlbmVycyIsImxpc3RlbmVyT3JQdXJlIiwic2V0IiwiZXZlbnRMaXN0ZW5lcktleXMiLCJvZmZGbnMiLCJldmVudExpc3RlbmVyIiwidHJpZ2dlckV2ZW50IiwiZXZlbnQiLCJwbHVnaW5Nb2R1bGVzIiwic3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2VzIiwiYWRkUGx1Z2lucyIsImFkZGVkUGx1Z2luIiwicGx1Z2luIiwicmVnaXN0ZXJQbHVnaW5Nb2R1bGVJbnN0YW5jZXMiLCJzdGF0aWNPYmoiLCJpbnN0YW5jZUluZm8iLCJzdGF0aWMiLCJvc1N0YXRpYyIsImluc3RhbmNlIiwib3NJbnN0YW5jZSIsImluc3RhbmNlT2JqIiwiaW5zdGFuY2VQbHVnaW5NYXAiLCJjdG9yIiwiZ2V0U3RhdGljUGx1Z2luTW9kdWxlSW5zdGFuY2UiLCJwbHVnaW5Nb2R1bGVOYW1lIiwib3B0aW9uc1ZhbGlkYXRpb25QbHVnaW5Nb2R1bGVOYW1lIiwiZGF0YUF0dHJpYnV0ZVByZWZpeCIsImNsYXNzTmFtZUVudmlyb25tZW50IiwiY2xhc3NOYW1lRW52aXJvbm1lbnRTY3JvbGxiYXJIaWRkZW4iLCJkYXRhQXR0cmlidXRlSW5pdGlhbGl6ZSIsImRhdGFWYWx1ZU5vQ2xpcHBpbmciLCJkYXRhQXR0cmlidXRlSHRtbEJvZHkiLCJkYXRhQXR0cmlidXRlSG9zdCIsImRhdGFWYWx1ZUhvc3RJc0hvc3QiLCJkYXRhQXR0cmlidXRlVmlld3BvcnQiLCJkYXRhVmFsdWVWaWV3cG9ydE92ZXJmbG93WFByZWZpeCIsImRhdGFWYWx1ZVZpZXdwb3J0T3ZlcmZsb3dZUHJlZml4IiwiZGF0YVZhbHVlVmlld3BvcnRBcnJhbmdlIiwiZGF0YVZhbHVlVmlld3BvcnRNZWFzdXJpbmciLCJkYXRhVmFsdWVWaWV3cG9ydFNjcm9sbGluZyIsImRhdGFWYWx1ZVZpZXdwb3J0U2Nyb2xsYmFySGlkZGVuIiwiZGF0YVZhbHVlVmlld3BvcnROb0NvbnRlbnQiLCJkYXRhQXR0cmlidXRlUGFkZGluZyIsImRhdGFBdHRyaWJ1dGVDb250ZW50IiwiY2xhc3NOYW1lU2l6ZU9ic2VydmVyIiwiY2xhc3NOYW1lU2l6ZU9ic2VydmVyQXBwZWFyIiwiY2xhc3NOYW1lU2l6ZU9ic2VydmVyTGlzdGVuZXIiLCJjbGFzc05hbWVTaXplT2JzZXJ2ZXJMaXN0ZW5lclNjcm9sbCIsImNsYXNzTmFtZVNpemVPYnNlcnZlckxpc3RlbmVySXRlbSIsImNsYXNzTmFtZVNpemVPYnNlcnZlckxpc3RlbmVySXRlbUZpbmFsIiwiY2xhc3NOYW1lVHJpbnNpY09ic2VydmVyIiwiY2xhc3NOYW1lU2Nyb2xsYmFyVGhlbWVOb25lIiwiY2xhc3NOYW1lU2Nyb2xsYmFyIiwiY2xhc3NOYW1lU2Nyb2xsYmFyUnRsIiwiY2xhc3NOYW1lU2Nyb2xsYmFySG9yaXpvbnRhbCIsImNsYXNzTmFtZVNjcm9sbGJhclZlcnRpY2FsIiwiY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2siLCJjbGFzc05hbWVTY3JvbGxiYXJIYW5kbGUiLCJjbGFzc05hbWVTY3JvbGxiYXJWaXNpYmxlIiwiY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVybGVzcyIsImNsYXNzTmFtZVNjcm9sbGJhckludGVyYWN0aW9uIiwiY2xhc3NOYW1lU2Nyb2xsYmFyVW51c2FibGUiLCJjbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZSIsImNsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRlSGlkZGVuIiwiY2xhc3NOYW1lU2Nyb2xsYmFyV2hlZWwiLCJjbGFzc05hbWVTY3JvbGxiYXJUcmFja0ludGVyYWN0aXZlIiwiY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlSW50ZXJhY3RpdmUiLCJzaXplT2JzZXJ2ZXJQbHVnaW5OYW1lIiwiU2l6ZU9ic2VydmVyUGx1Z2luIiwibGlzdGVuZXJFbGVtZW50Iiwib25TaXplQ2hhbmdlZENhbGxiYWNrIiwib2JzZXJ2ZUFwcGVhckNoYW5nZSIsInNjcm9sbEFtb3VudCIsInNjcm9sbEV2ZW50TmFtZSIsIm9ic2VydmVyRWxlbWVudENoaWxkcmVuIiwib2JzZXJ2ZXJFbGVtZW50Q2hpbGRyZW5Sb290Iiwic2hyaW5rRWxlbWVudCIsImxhc3RDaGlsZCIsImV4cGFuZEVsZW1lbnQiLCJmaXJzdENoaWxkIiwiZXhwYW5kRWxlbWVudENoaWxkIiwiY2FjaGVTaXplIiwiY3VyclNpemUiLCJpc0RpcnR5IiwickFGSWQiLCJyZXNldCIsIm9uUmVzaXplZCIsImFwcGVhciIsIm9uU2Nyb2xsIiwic2Nyb2xsRXZlbnQiLCJkZXN0cm95Rm5zIiwiZ2V0U2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFycyIsImNoZWNrT3B0aW9uIiwiZW52IiwiayIsIl9uYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQiLCJzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzT3B0aW9uIiwic2hvd05hdGl2ZU92ZXJsYWlkU2Nyb2xsYmFyc0NoYW5nZWQiLCJvdmVyZmxvd0lzVmlzaWJsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dCZWhhdmlvclRvT3ZlcmZsb3dTdHlsZSIsIm92ZXJmbG93QmVoYXZpb3IiLCJyZXBsYWNlIiwib3ZlcmZsb3dDc3NWYWx1ZVRvT3ZlcmZsb3dTdHlsZSIsImNzc1ZhbHVlIiwiaGFzT3ZlcmZsb3ciLCJmaW5hbENzc1ZhbHVlIiwiZ2V0RWxlbWVudE92ZXJmbG93U3R5bGUiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJzY3JvbGxiYXJzSGlkaW5nUGx1Z2luTmFtZSIsIlNjcm9sbGJhcnNIaWRpbmdQbHVnaW4iLCJfdmlld3BvcnRBcnJhbmdlbWVudCIsInN0cnVjdHVyZVNldHVwRWxlbWVudHMiLCJzdHJ1Y3R1cmVTZXR1cFN0YXRlIiwib2JzZXJ2ZXJzU2V0dXBTdGF0ZSIsImNoZWNrT3B0aW9ucyIsIlYiLCJfdmlld3BvcnRJc1RhcmdldCIsIkwiLCJfdmlld3BvcnQiLCJVIiwiX25hdGl2ZVNjcm9sbGJhcnNIaWRpbmciLCJQIiwiX25hdGl2ZVNjcm9sbGJhcnNTaXplIiwiZG9WaWV3cG9ydEFycmFuZ2UiLCJzaG93TmF0aXZlT3ZlcmxhaWRTY3JvbGxiYXJzIiwiX2dldFZpZXdwb3J0T3ZlcmZsb3dIaWRlT2Zmc2V0Iiwidmlld3BvcnRPdmVyZmxvd1N0eWxlIiwiYXJyYW5nZUhpZGVPZmZzZXQiLCJnZXRIaWRlT2Zmc2V0UGVyQXhpcyIsImlzT3ZlcmxhaWQiLCJvdmVyZmxvd1Njcm9sbCIsIm5hdGl2ZVNjcm9sbGJhclNpemUiLCJub25TY3JvbGxiYXJTdHlsaW5nSGlkZU9mZnNldCIsInNjcm9sbGJhcnNIaWRlT2Zmc2V0Iiwic2Nyb2xsYmFyc0hpZGVPZmZzZXRBcnJhbmdlIiwieFNjcm9sbGJhcnNIaWRlT2Zmc2V0IiwieFNjcm9sbGJhcnNIaWRlT2Zmc2V0QXJyYW5nZSIsInlTY3JvbGxiYXJzSGlkZU9mZnNldCIsInlTY3JvbGxiYXJzSGlkZU9mZnNldEFycmFuZ2UiLCJfc2Nyb2xsYmFyc0hpZGVPZmZzZXQiLCJfc2Nyb2xsYmFyc0hpZGVPZmZzZXRBcnJhbmdlIiwiX2hpZGVOYXRpdmVTY3JvbGxiYXJzIiwiQiIsIl9kaXJlY3Rpb25Jc1JUTCIsInZpZXdwb3J0U3R5bGVPYmoiLCJOIiwicSIsImFycmFuZ2VYIiwiYXJyYW5nZVkiLCJoaWRlT2Zmc2V0WCIsImhpZGVPZmZzZXRZIiwiRiIsIl92aWV3cG9ydFBhZGRpbmdTdHlsZSIsImhvcml6b250YWxNYXJnaW5LZXkiLCJ2aWV3cG9ydEhvcml6b250YWxQYWRkaW5nS2V5IiwiaG9yaXpvbnRhbE1hcmdpblZhbHVlIiwidmVydGljYWxNYXJnaW5WYWx1ZSIsImhvcml6b250YWxQYWRkaW5nVmFsdWUiLCJ2ZXJ0aWNhbFBhZGRpbmdWYWx1ZSIsIl9hcnJhbmdlVmlld3BvcnQiLCJ2aWV3cG9ydFNjcm9sbFNpemUiLCJzaXplRnJhY3Rpb24iLCJ2aWV3cG9ydEFycmFuZ2VIb3Jpem9udGFsUGFkZGluZ0tleSIsInZpZXdwb3J0QXJyYW5nZUhvcml6b250YWxQYWRkaW5nVmFsdWUiLCJ2aWV3cG9ydEFycmFuZ2VWZXJ0aWNhbFBhZGRpbmdWYWx1ZSIsInBhZGRpbmdUb3AiLCJmcmFjdGlvbmFsQ29udGVudFdpZHRoIiwiZnJhY3Rpb25hbENvbnRlbkhlaWdodCIsImFycmFuZ2VTaXplIiwiX3VuZG9WaWV3cG9ydEFycmFuZ2UiLCJqIiwiX2hhc092ZXJmbG93Iiwidmlld3BvcnRQYWRkaW5nU3R5bGUiLCJmaW5hbFBhZGRpbmdTdHlsZSIsImFzc2lnblByb3BzIiwicHJldlN0eWxlIiwiYWRkQXJyYW5nZSIsImNsaWNrU2Nyb2xsUGx1Z2luTW9kdWxlTmFtZSIsIkNsaWNrU2Nyb2xsUGx1Z2luIiwibW92ZUhhbmRsZVJlbGF0aXZlIiwidGFyZ2V0T2Zmc2V0IiwiaGFuZGxlTGVuZ3RoIiwib25DbGlja1Njcm9sbENvbXBsZXRlZCIsInN0b3BwZWQiLCJzdG9wUHJlc3NBbmltYXRpb24iLCJsaW5lYXJTY3JvbGxNcyIsImVhc2VkU2Nyb2xsTXMiLCJzZXRQcmVzc0FuaW1hdGlvblRpbWVvdXQiLCJjbGVhclByZXNzQW5pbWF0aW9uVGltZW91dCIsInRhcmdldE9mZnNldFNpZ24iLCJoYW5kbGVMZW5ndGhXaXRoVGFyZ2V0U2lnbiIsImhhbmRsZUxlbmd0aFdpdGhUYXJnZXRTaWduSGFsZiIsImVhc2VkRW5kUHJlc3NBbmltYXRpb24iLCJsaW5lYXJQcmVzc0FuaW1hdGlvbiIsImxpbmVhckZyb20iLCJtc0ZhY3RvciIsImNvbXBsZXRlZCIsInN0b3BDbGlja0FuaW1hdGlvbiIsImNsaWNrQW5pbWF0aW9uUHJvZ3Jlc3MiLCJjbGlja0FuaW1hdGlvbkNvbXBsZXRlZCIsInJlbWFpbmluZ1Njcm9sbERpc3RhbmNlIiwiY29udGludWVXaXRoUHJlc3MiLCJyZW1haW5pbmdMaW5lYXJTY3JvbGxEaXN0YW5jZSIsImxpbmVhckJyaWRnZSIsInN0b3BDbGljayIsIm9wc1N0cmluZ2lmeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2YWwiLCJnZXRQcm9wQnlQYXRoIiwicGF0aCIsImRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VNdXRhdGlvbiIsImRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VFdmVudCIsImRlZmF1bHRPcHRpb25zVXBkYXRlRGVib3VuY2VFbnYiLCJkZWZhdWx0T3B0aW9ucyIsInBhZGRpbmdBYnNvbHV0ZSIsImVsZW1lbnRFdmVudHMiLCJtdXRhdGlvbiIsInJlc2l6ZSIsImF0dHJpYnV0ZXMiLCJpZ25vcmVNdXRhdGlvbiIsImZsb3dEaXJlY3Rpb25TdHlsZXMiLCJzY3JvbGxiYXJzIiwidGhlbWUiLCJ2aXNpYmlsaXR5IiwiYXV0b0hpZGUiLCJhdXRvSGlkZURlbGF5IiwiYXV0b0hpZGVTdXNwZW5kIiwiZHJhZ1Njcm9sbCIsImNsaWNrU2Nyb2xsIiwicG9pbnRlcnMiLCJnZXRPcHRpb25zRGlmZiIsImN1cnJPcHRpb25zIiwibmV3T3B0aW9ucyIsImRpZmYiLCJvcHRpb25zS2V5cyIsIm9wdGlvbktleSIsImN1cnJPcHRpb25WYWx1ZSIsIm5ld09wdGlvblZhbHVlIiwiaXNEaWZmIiwiY3JlYXRlT3B0aW9uQ2hlY2siLCJjaGFuZ2VkT3B0aW9ucyIsIm5vbmNlIiwiZ2V0Tm9uY2UiLCJzZXROb25jZSIsIm5ld05vbmNlIiwiZW52aXJvbm1lbnRJbnN0YW5jZSIsImNyZWF0ZUVudmlyb25tZW50IiwiZ2V0TmF0aXZlU2Nyb2xsYmFyU2l6ZSIsIm1lYXN1cmVFbG0iLCJtZWFzdXJlRWxtQ2hpbGQiLCJib2R5IiwiY1NpemUiLCJvU2l6ZSIsImZTaXplIiwiZ2V0TmF0aXZlU2Nyb2xsYmFyc0hpZGluZyIsInRlc3RFbG0iLCJyZXZlcnRDbGFzcyIsImVudlN0eWxlIiwiZW52RE9NIiwiZW52RWxtIiwiZW52Q2hpbGRFbG0iLCJzdHlsZUVsbSIsInVwZGF0ZU5hdGl2ZVNjcm9sbGJhclNpemVDYWNoZSIsImdldE5hdGl2ZVNjcm9sbGJhclNpemVDYWNoZSIsIm5hdGl2ZVNjcm9sbGJhcnNTaXplIiwibmF0aXZlU2Nyb2xsYmFyc0hpZGluZyIsIm5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCIsInN0YXRpY0RlZmF1bHRJbml0aWFsaXphdGlvbiIsImVsZW1lbnRzIiwiaG9zdCIsInBhZGRpbmciLCJ2aWV3cG9ydCIsImNvbnRlbnQiLCJzbG90IiwiY2FuY2VsIiwic3RhdGljRGVmYXVsdE9wdGlvbnMiLCJnZXREZWZhdWx0T3B0aW9ucyIsImdldERlZmF1bHRJbml0aWFsaXphdGlvbiIsIl9zY3JvbGxUaW1lbGluZSIsIl9hZGRSZXNpemVMaXN0ZW5lciIsIl9nZXREZWZhdWx0SW5pdGlhbGl6YXRpb24iLCJfc2V0RGVmYXVsdEluaXRpYWxpemF0aW9uIiwibmV3SW5pdGlhbGl6YXRpb25TdHJhdGVneSIsIl9nZXREZWZhdWx0T3B0aW9ucyIsIl9zZXREZWZhdWx0T3B0aW9ucyIsIm5ld0RlZmF1bHRPcHRpb25zIiwiX3N0YXRpY0RlZmF1bHRJbml0aWFsaXphdGlvbiIsIl9zdGF0aWNEZWZhdWx0T3B0aW9ucyIsIm1hdGNoTWVkaWEiLCJhZGRab29tTGlzdGVuZXIiLCJvblpvb20iLCJtZWRpYSIsImRldmljZVBpeGVsUmF0aW8iLCJ1cGRhdGVkTmF0aXZlU2Nyb2xsYmFyU2l6ZSIsIm5hdGl2ZVNjcm9sbGJhclNpemVDaGFuZ2VkIiwiZ2V0RW52aXJvbm1lbnQiLCJjcmVhdGVFdmVudENvbnRlbnRDaGFuZ2UiLCJldmVudENvbnRlbnRDaGFuZ2UiLCJkZXN0cm95ZWQiLCJXZWFrTWFwIiwiZGVzdHJveSIsInVwZGF0ZUVsZW1lbnRzIiwiZ2V0RWxlbWVudHMiLCJldmVudEVsbUxpc3QiLCJlbnRyaWVzIiwiaXNUYXJnZXRDaGlsZCIsImNvbnRhaW5zIiwicmVtb3ZlTGlzdGVuZXIiLCJkZWxldGUiLCJjcmVhdGVET01PYnNlcnZlciIsImlzQ29udGVudE9ic2VydmVyIiwiaXNDb25uZWN0ZWQiLCJldCIsIl9hdHRyaWJ1dGVzIiwiY3QiLCJfc3R5bGVDaGFuZ2luZ0F0dHJpYnV0ZXMiLCJydCIsIl9ldmVudENvbnRlbnRDaGFuZ2UiLCJpdCIsIl9uZXN0ZWRUYXJnZXRTZWxlY3RvciIsImx0IiwiX2lnbm9yZVRhcmdldENoYW5nZSIsInV0IiwiX2lnbm9yZUNvbnRlbnRDaGFuZ2UiLCJkZXN0cm95RXZlbnRDb250ZW50Q2hhbmdlIiwidXBkYXRlRXZlbnRDb250ZW50Q2hhbmdlRWxlbWVudHMiLCJmaW5hbEF0dHJpYnV0ZXMiLCJmaW5hbFN0eWxlQ2hhbmdpbmdBdHRyaWJ1dGVzIiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwib2JzZXJ2ZXJDYWxsYmFjayIsImZyb21SZWNvcmRzIiwibXV0YXRpb25zIiwiaWdub3JlVGFyZ2V0Q2hhbmdlIiwiaWdub3JlQ29udGVudENoYW5nZSIsInRvdGFsQ2hhbmdlZE5vZGVzIiwidGFyZ2V0Q2hhbmdlZEF0dHJzIiwidGFyZ2V0U3R5bGVDaGFuZ2VkIiwiY29udGVudENoYW5nZWQiLCJhdHRyaWJ1dGVOYW1lIiwibXV0YXRpb25UYXJnZXQiLCJ0eXBlIiwib2xkVmFsdWUiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwiaXNBdHRyaWJ1dGVzVHlwZSIsImlzQ2hpbGRMaXN0VHlwZSIsInRhcmdldElzTXV0YXRpb25UYXJnZXQiLCJpc0F0dHJDaGFuZ2UiLCJhdHRyaWJ1dGVWYWx1ZSIsImF0dHJpYnV0ZUNoYW5nZWQiLCJzdHlsZUNoYW5naW5nQXR0ckNoYW5nZWQiLCJjb250ZW50QXR0ckNoYW5nZWQiLCJpc05lc3RlZFRhcmdldCIsImJhc2VBc3NlcnRpb24iLCJjb250ZW50RmluYWxDaGFuZ2VkIiwibXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJhdHRyaWJ1dGVPbGRWYWx1ZSIsImF0dHJpYnV0ZUZpbHRlciIsInN1YnRyZWUiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiZGlzY29ubmVjdCIsInRha2VSZWNvcmRzIiwicmVzaXplT2JzZXJ2ZXJCb3hTdXBwb3J0IiwiY3JlYXRlU2l6ZU9ic2VydmVyIiwiX2FwcGVhciIsInNpemVPYnNlcnZlclBsdWdpbiIsInVwZGF0ZVJlc2l6ZU9ic2VydmVyQ29udGVudFJlY3RDYWNoZSIsInBvbHlmaWxsRWxlbWVudHMiLCJwb2x5ZmlsbFJvb3RFbGVtZW50IiwicG9seWZpbGxUYXJnZXRFbGVtZW50Iiwib25TaXplQ2hhbmdlZENhbGxiYWNrUHJveHkiLCJzaXplQ2hhbmdlZENvbnRleHQiLCJpc1Jlc2l6ZU9ic2VydmVyQ2FsbCIsInNraXAiLCJyZXNpemVPYnNlcnZlckVudHJ5IiwiY29udGVudFJlY3QiLCJfc2l6ZUNoYW5nZWQiLCJkZXRlY3RTdXBwb3J0UmVzaXplT2JzZXJ2ZXIiLCJib3giLCJkZWJvdW5jZWRPblNpemVDaGFuZ2VkQ2FsbGJhY2tQcm94eSIsInJlc2l6ZU9ic2VydmVyQ2FsbGJhY2siLCJjb250ZW50Qm94UmVzaXplT2JzZXJ2ZXIiLCJib3JkZXJCb3hSZXNpemVPYnNlcnZlciIsInBsdWdpbkFwcGVhckNhbGxiYWNrIiwicGx1Z2luRGVzdHJveUZucyIsImNyZWF0ZVRyaW5zaWNPYnNlcnZlciIsIm9uVHJpbnNpY0NoYW5nZWRDYWxsYmFjayIsImludGVyc2VjdGlvbk9ic2VydmVySW5zdGFuY2UiLCJpc0hlaWdodEludHJpbnNpYyIsImlvRW50cnlPclNpemUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwidHJpbnNpY09ic2VydmVyIiwidXBkYXRlSGVpZ2h0SW50cmluc2ljQ2FjaGUiLCJ0cmlnZ2VyT25Ucmluc2ljQ2hhbmdlZENhbGxiYWNrIiwidXBkYXRlVmFsdWUiLCJoZWlnaHRJbnRyaW5zaWMiLCJoZWlnaHRJbnRyaW5zaWNDaGFuZ2VkIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayIsInBvcCIsInJvb3QiLCJvblNpemVDaGFuZ2VkIiwibmV3U2l6ZSIsImNyZWF0ZU9ic2VydmVyc1NldHVwIiwiZ2V0Q3VycmVudE9wdGlvbiIsIm9uT2JzZXJ2ZXJzVXBkYXRlZCIsImRlYm91bmNlTXV0YXRpb24iLCJkZWJvdW5jZVJlc2l6ZSIsImRlYm91bmNlRXZlbnQiLCJkZWJvdW5jZUVudiIsInVwZGF0ZUNvbnRlbnRNdXRhdGlvbk9ic2VydmVyIiwiZGVzdHJveUNvbnRlbnRNdXRhdGlvbk9ic2VydmVyIiwicHJldkRpcmVjdGlvbklzUlRMIiwiaG9zdFNlbGVjdG9yIiwidmlld3BvcnRTZWxlY3RvciIsImJhc2VTdHlsZUNoYW5naW5nQXR0cnMiLCJkdCIsIl90YXJnZXQiLCJ2dCIsIl9ob3N0IiwiZ3QiLCJfc2Nyb2xsT2Zmc2V0RWxlbWVudCIsImh0IiwiX2NvbnRlbnQiLCJidCIsIl9pc0JvZHkiLCJ3dCIsIl92aWV3cG9ydEhhc0NsYXNzIiwieXQiLCJfdmlld3BvcnRBZGRSZW1vdmVDbGFzcyIsIlN0IiwiX3JlbW92ZVNjcm9sbE9ic2N1cmluZ1N0eWxlcyIsImdldERpcmVjdGlvbklzUlRMIiwiY3JlYXRlRGVib3VuY2VkT2JzZXJ2ZXNVcGRhdGUiLCJjdXJyRGVib3VuY2VUaW1pbmciLCJjdXJyTWF4RGVib3VuY2VUaW1pbmciLCJjdXJyRGVib3VuY2VMZWFkaW5nIiwicHJldiIsInByZXZPYmoiLCJjdXJyT2JqIiwidXBkYXRlSGludHMiLCJkZWJvdW5jZU9wdGlvbiIsInRpbWluZyIsIm1heFRpbWluZyIsInN0YXRlIiwiX2hlaWdodEludHJpbnNpYyIsInNjcm9sbGJhcnNIaWRpbmdQbHVnaW4iLCJ1cGRhdGVDb250ZW50U2l6ZUNhY2hlIiwidW5kb1ZpZXdwb3J0QXJyYW5nZSIsInZpZXdwb3J0SXNUYXJnZXRCb2R5Iiwibm9DbGlwcGluZyIsImlzQXJyYW5nZWQiLCJzY3JvbGxPZmZzZXQiLCJyZXZlcnRTY3JvbGxPYnNjdXJpbmdTdHlsZXMiLCJyZXZlcnRNZWFzdXJpbmciLCJyZWRvVmlld3BvcnRBcnJhbmdlIiwidmlld3BvcnRTY3JvbGwiLCJmcmFjdGlvbmFsIiwib25PYnNlcnZlcnNVcGRhdGVkRGVib3VuY2VkIiwic2V0RGlyZWN0aW9uIiwibmV3RGlyZWN0aW9uSXNSVEwiLCJfZGlyZWN0aW9uQ2hhbmdlZCIsIm9uVHJpbnNpY0NoYW5nZWQiLCJoZWlnaHRJbnRyaW5zaWNDYWNoZSIsIl9oZWlnaHRJbnRyaW5zaWNDaGFuZ2VkIiwidXBkYXRlRm4iLCJvbkNvbnRlbnRNdXRhdGlvbiIsImNvbnRlbnRDaGFuZ2VkVGhyb3VnaEV2ZW50IiwiX2NvbnRlbnRNdXRhdGlvbiIsIm9uSG9zdE11dGF0aW9uIiwiX2hvc3RNdXRhdGlvbiIsImNvbnN0cnVjdFRyaW5zaWNPYnNlcnZlciIsInVwZGF0ZVRyaW5zaWNPYnNlcnZlciIsImNvbnN0cnVjdFNpemVPYnNlcnZlciIsImNvbnN0cnVjdEhvc3RNdXRhdGlvbk9ic2VydmVyIiwidXBkYXRlSG9zdE11dGF0aW9uT2JzZXJ2ZXIiLCJ2aWV3cG9ydElzVGFyZ2V0UmVzaXplT2JzZXJ2ZXIiLCJkZXN0cm95U2l6ZU9ic2VydmVyIiwiZGVzdHJveVRyaW5zaWNPYnNlcnZlciIsImRlc3Ryb3lIb3N0TXV0YXRpb25PYnNlcnZlciIsInJlbW92ZVJlc2l6ZUxpc3RlbmVyIiwiX3Njcm9sbGJhclNpemVDaGFuZ2VkIiwiX2NoZWNrT3B0aW9uIiwiX3Rha2VSZWNvcmRzIiwiX2ZvcmNlIiwiYXR0cmlidXRlc0NoYW5nZWQiLCJlbGVtZW50RXZlbnRzQ2hhbmdlZCIsImRlYm91bmNlVmFsdWUiLCJkZWJvdW5jZUNoYW5nZWQiLCJjb250ZW50TXV0YXRpb25PYnNlcnZlckNoYW5nZWQiLCJpZ25vcmVNdXRhdGlvbkZyb21PcHRpb25zIiwiY29uc3RydWN0IiwiaWdub3JlIiwiaG9zdFVwZGF0ZVJlc3VsdCIsInRyaW5zaWNVcGRhdGVSZXN1bHQiLCJjb250ZW50VXBkYXRlUmVzdWx0IiwicmVzb2x2ZUluaXRpYWxpemF0aW9uIiwic3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50IiwiZmFsbGJhY2tTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnQiLCJkZWZhdWx0U3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50Iiwic3RhdGljSW5pdGlhbGl6YXRpb25FbGVtZW50VmFsdWUiLCJzdGF0aWNJbml0aWFsaXphdGlvbiIsInJlc29sdmVkSW5pdGlhbGl6YXRpb24iLCJkeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50IiwiZmFsbGJhY2tEeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50IiwiZGVmYXVsdER5bmFtaWNJbml0aWFsaXphdGlvbkVsZW1lbnQiLCJkeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50VmFsdWUiLCJkeW5hbWljSW5pdGlhbGl6YXRpb24iLCJjYW5jZWxJbml0aWFsaXphdGlvbiIsImlzQm9keSIsImNhbmNlbEluaXRpYWxpemF0aW9uVmFsdWUiLCJLIiwiZGVmYXVsdE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCIsImRlZmF1bHRib2R5IiwicmVzb2x2ZWROYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQiLCJyZXNvbHZlZERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCIsImZpbmFsTmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkIiwiZmluYWxEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQiLCJjcmVhdGVTY3JvbGxiYXJzU2V0dXBFbGVtZW50cyIsInNjcm9sbGJhcnNTZXR1cEV2ZW50cyIsImNzc0N1c3RvbVByb3BWaWV3cG9ydFBlcmNlbnQiLCJjc3NDdXN0b21Qcm9wU2Nyb2xsUGVyY2VudCIsImNzc0N1c3RvbVByb3BTY3JvbGxEaXJlY3Rpb24iLCJkZWZhdWx0SW5pdFNjcm9sbGJhcnMiLCJkZWZhdWx0SW5pdFNjcm9sbGJhcnNTbG90IiwiVHQiLCJfdGFyZ2V0SXNFbG0iLCJzY3JvbGxiYXJzSW5pdCIsImluaXRTY3JvbGxiYXJzU2xvdCIsImhvcml6b250YWxTY3JvbGxiYXJzIiwidmVydGljYWxTY3JvbGxiYXJzIiwiZXZhbHVhdGVkU2Nyb2xsYmFyU2xvdCIsImdlbmVyYWxEeW5hbWljSW5pdGlhbGl6YXRpb25FbGVtZW50IiwiaW5pdFNjcm9sbFRpbWVsaW5lIiwiYXhpcyIsImN1cnJBbmltYXRpb24iLCJjdXJyQW5pbWF0aW9uVHJhbnNmb3JtIiwidGltZWxpbmUiLCJjYW5jZWxBbmltYXRpb24iLCJfc2V0U2Nyb2xsUGVyY2VudEFuaW1hdGlvbiIsInN0cnVjdHVyZSIsIkR0IiwiX3Njcm9sbENvb3JkaW5hdGVzIiwiZGVmYXVsdERpcmVjdGlvblNjcm9sbCIsInRyYW5zZm9ybUFycmF5IiwidHJhbnNmb3JtIiwicmV2ZXJzZSIsIl9oYW5kbGUiLCJhbmltYXRlIiwic2Nyb2xsVGltZWxpbmUiLCJnZXRWaWV3cG9ydFBlcmNlbnQiLCJSdCIsIl9vdmVyZmxvd0Ftb3VudCIsIlZ0IiwiX292ZXJmbG93RWRnZSIsImdldEF4aXNWYWx1ZSIsImF4aXNWaWV3cG9ydFNpemUiLCJheGlzT3ZlcmZsb3dBbW91bnQiLCJzY3JvbGxiYXJTdHJ1Y3R1cmVBZGRSZW1vdmVDbGFzcyIsInNjcm9sbGJhclN0cnVjdHVyZXMiLCJhY3Rpb24iLCJzY3JvbGxiYXJTdHJ1Y3R1cmUiLCJfc2Nyb2xsYmFyIiwic2Nyb2xsYmFyU3R5bGUiLCJzY3JvbGxiYXJzQWRkUmVtb3ZlQ2xhc3MiLCJvbmx5SG9yaXpvbnRhbCIsInNpbmdsZUF4aXMiLCJydW5Ib3Jpem9udGFsIiwicnVuVmVydGljYWwiLCJyZWZyZXNoU2Nyb2xsYmFyc0hhbmRsZUxlbmd0aCIsInZpZXdwb3J0UGVyY2VudCIsImNyZWF0ZVNjcm9sbGJhclN0eWxlRm4iLCJheGlzVmlld3BvcnRQZXJjZW50IiwicmVmcmVzaFNjcm9sbGJhcnNIYW5kbGVPZmZzZXQiLCJzY3JvbGxQZXJjZW50IiwiYXhpc1Njcm9sbFBlcmNlbnQiLCJyZWZyZXNoU2Nyb2xsYmFyc1Njcm9sbENvb3JkaW5hdGVzIiwiYXhpc0lzRGVmYXVsdERpcmVjdGlvblNjcm9sbENvb3JkaW5hdGVzIiwicmVmcmVzaFNjcm9sbGJhcnNTY3JvbGxiYXJPZmZzZXQiLCJpc0RlZmF1bHREaXJlY3Rpb25TY3JvbGwiLCJzdHlsZVNjcm9sbGJhclBvc2l0aW9uIiwiTHQiLCJnZXRUcmFuc2xhdGVWYWx1ZSIsImF4aXNJc0RlZmF1bHRDb29yZGluYXRlcyIsInB4IiwiZ2VuZXJhdGVTY3JvbGxiYXJET00iLCJ4eUtleSIsInNjcm9sbGJhckNsYXNzTmFtZSIsInNjcm9sbGJhciIsInRyYWNrIiwiaGFuZGxlIiwiX3RyYWNrIiwiZ2VuZXJhdGVIb3Jpem9udGFsU2Nyb2xsYmFyU3RydWN0dXJlIiwiZ2VuZXJhdGVWZXJ0aWNhbFNjcm9sbGJhclN0cnVjdHVyZSIsImFwcGVuZEVsZW1lbnRzIiwiX3JlZnJlc2hTY3JvbGxiYXJzSGFuZGxlTGVuZ3RoIiwiX3JlZnJlc2hTY3JvbGxiYXJzSGFuZGxlT2Zmc2V0IiwiX3JlZnJlc2hTY3JvbGxiYXJzU2Nyb2xsQ29vcmRpbmF0ZXMiLCJfcmVmcmVzaFNjcm9sbGJhcnNTY3JvbGxiYXJPZmZzZXQiLCJfc2Nyb2xsYmFyc0FkZFJlbW92ZUNsYXNzIiwiX2hvcml6b250YWwiLCJfc2Nyb2xsYmFyU3RydWN0dXJlcyIsIl9jbG9uZSIsIl9zdHlsZSIsIl92ZXJ0aWNhbCIsImNyZWF0ZVNjcm9sbGJhcnNTZXR1cEV2ZW50cyIsInNjcm9sbGJhckhhbmRsZVBvaW50ZXJJbnRlcmFjdGlvbiIsIkd0IiwiX2RvY3VtZW50RWxtIiwiVXQiLCJNdCIsIndoZWVsVGltZW91dCIsImNsZWFyV2hlZWxUaW1lb3V0Iiwic2Nyb2xsU25hcFNjcm9sbFRyYW5zaXRpb25UaW1lb3V0IiwiY2xlYXJTY3JvbGxTbmFwU2Nyb2xsVHJhbnNpdGlvblRpbWVvdXQiLCJzY3JvbGxPZmZzZXRFbGVtZW50U2Nyb2xsQnkiLCJjb29yZGluYXRlcyIsInNjcm9sbEJ5IiwiYmVoYXZpb3IiLCJjcmVhdGVJbnRlcmFjdGl2ZVNjcm9sbEV2ZW50cyIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZUV2ZW50cyIsImNsaWVudFhZS2V5Iiwid2lkdGhIZWlnaHRLZXkiLCJsZWZ0VG9wS2V5Iiwid2hLZXkiLCJjcmVhdGVSZWxhdGl2ZUhhbmRsZU1vdmUiLCJtb3VzZURvd25TY3JvbGwiLCJpbnZlcnRlZFNjYWxlIiwiZGVsdGFNb3ZlbWVudCIsImhhbmRsZVRyYWNrRGlmZiIsInNjcm9sbERlbHRhUGVyY2VudCIsInNjcm9sbERlbHRhIiwicG9pbnRlcmRvd25DbGVhbnVwRm5zIiwicG9pbnRlckRvd25FdmVudCIsImlzRHJhZ1Njcm9sbCIsInBvaW50ZXJDYXB0dXJlRWxlbWVudCIsInNjcm9sbGJhck9wdGlvbnMiLCJkcmFnQ2xpY2tTY3JvbGxPcHRpb24iLCJidXR0b24iLCJpc1ByaW1hcnkiLCJwb2ludGVyVHlwZSIsImNvbnRpbnVlUG9pbnRlckRvd24iLCJpbnN0YW50Q2xpY2tTY3JvbGwiLCJzaGlmdEtleSIsImdldEhhbmRsZVJlY3QiLCJnZXRUcmFja1JlY3QiLCJnZXRIYW5kbGVPZmZzZXQiLCJoYW5kbGVSZWN0IiwidHJhY2tSZWN0IiwiYXhpc1NjYWxlIiwicG9pbnRlckRvd25PZmZzZXQiLCJoYW5kbGVDZW50ZXIiLCJyZWxhdGl2ZVRyYWNrUG9pbnRlck9mZnNldCIsInN0YXJ0T2Zmc2V0IiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwicG9pbnRlclVwRXZlbnQiLCJwb2ludGVydXBDbGVhbnVwRm5zIiwicG9pbnRlcklkIiwibm9uQW5pbWF0ZWRTY3JvbGwiLCJwb2ludGVyTW92ZUV2ZW50Iiwid2l0aG91dFNuYXBTY3JvbGxPZmZzZXQiLCJ3aXRoU25hcFNjcm9sbE9mZnNldCIsInNuYXBTY3JvbGxEaWZmIiwic2V0UG9pbnRlckNhcHR1cmUiLCJhbmltYXRlQ2xpY2tTY3JvbGwiLCJzdG9wQ2xpY2tTY3JvbGxBbmltYXRpb24iLCJ3aGVlbFNjcm9sbEJ5IiwiZm9jdXNlZEVsZW1lbnQiLCJ3aGVlbEV2ZW50IiwiZGVsdGFYIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwicmVtb3ZlQ2xpY2tFdmVudCIsImNsaWNrRXZlbnQiLCJyZW1vdmVQb2ludGVyRXZlbnRzIiwiY3JlYXRlU2Nyb2xsYmFyc1NldHVwIiwibW91c2VJbkhvc3QiLCJhdXRvSGlkZUlzTW92ZSIsImF1dG9IaWRlSXNMZWF2ZSIsImF1dG9IaWRlSXNOZXZlciIsInByZXZUaGVtZSIsImluc3RhbmNlQXV0b0hpZGVTdXNwZW5kU2Nyb2xsRGVzdHJveUZuIiwiaW5zdGFuY2VBdXRvSGlkZURlbGF5IiwiaG92ZXJhYmxlUG9pbnRlclR5cGVzIiwiaXNIb3ZlcmFibGVQb2ludGVyVHlwZSIsInJlcXVlc3RTY3JvbGxBbmltYXRpb25GcmFtZSIsImNhbmNlbFNjcm9sbEFuaW1hdGlvbkZyYW1lIiwiYXV0b0hpZGVJbnN0YW50SW50ZXJhY3Rpb25UaW1lb3V0IiwiY2xlYXJBdXRvSGlkZUluc3RhbnRJbnRlcmFjdGlvblRpbWVvdXQiLCJhdXRvSGlkZVN1c3BlbmRUaW1lb3V0IiwiY2xlYXJBdXRvSGlkZVN1c3BlbmRUaW1lb3V0IiwiYXVvdEhpZGVUaW1lb3V0IiwiY2xlYXJBdXRvSGlkZVRpbWVvdXQiLCJtYW5hZ2VTY3JvbGxiYXJzQXV0b0hpZGVJbnN0YW50SW50ZXJhY3Rpb24iLCJLdCIsIl9zY3JvbGxFdmVudEVsZW1lbnQiLCJGdCIsIlB0IiwiTnQiLCJxdCIsIkJ0IiwibWFuYWdlU2Nyb2xsYmFyc0F1dG9IaWRlIiwicmVtb3ZlQXV0b0hpZGUiLCJkZWxheWxlc3MiLCJoaWRlIiwibWFuYWdlQXV0b0hpZGVTdXNwZW5zaW9uIiwib25Ib3N0TW91c2VFbnRlciIsIl9vYnNlcnZlcnNVcGRhdGVIaW50cyIsIl9zdHJ1Y3R1cmVVcGRhdGVIaW50cyIsInRuIiwiX292ZXJmbG93RWRnZUNoYW5nZWQiLCJubiIsIl9vdmVyZmxvd0Ftb3VudENoYW5nZWQiLCJzbiIsIl9vdmVyZmxvd1N0eWxlQ2hhbmdlZCIsImVuIiwiX3Njcm9sbENvb3JkaW5hdGVzQ2hhbmdlZCIsIkN0IiwiZnQiLCJjbiIsIl9vdmVyZmxvd1N0eWxlIiwidGhlbWVDaGFuZ2VkIiwidmlzaWJpbGl0eUNoYW5nZWQiLCJhdXRvSGlkZUNoYW5nZWQiLCJhdXRvSGlkZVN1c3BlbmRDaGFuZ2VkIiwiZHJhZ1Njcm9sbENoYW5nZWQiLCJjbGlja1Njcm9sbENoYW5nZWQiLCJvdmVyZmxvd0NoYW5nZWQiLCJ0cnVseUFwcGVhcmVkIiwidXBkYXRlU2Nyb2xsYmFycyIsInVwZGF0ZVZpc2liaWxpdHkiLCJjYW50SGlkZVNjcm9sbGJhcnMiLCJzaG93TmF0aXZlU2Nyb2xsYmFycyIsInNldFNjcm9sbGJhclZpc2liaWxpdHkiLCJvdmVyZmxvd1N0eWxlIiwiaXNWaXNpYmxlIiwieFZpc2libGUiLCJ5VmlzaWJsZSIsImhhc0Nvcm5lciIsImNyZWF0ZVN0cnVjdHVyZVNldHVwRWxlbWVudHMiLCJkZWZhdWx0SW5pdEVsZW1lbnRzIiwiZGVmYXVsdFBhZGRpbmdJbml0aWFsaXphdGlvbiIsImRlZmF1bHRWaWV3cG9ydEluaXRpYWxpemF0aW9uIiwiZGVmYXVsdENvbnRlbnRJbml0aWFsaXphdGlvbiIsInRhcmdldElzRWxtIiwidGFyZ2V0U3RydWN0dXJlSW5pdGlhbGl6YXRpb24iLCJpbml0RWxlbWVudHMiLCJwYWRkaW5nSW5pdGlhbGl6YXRpb24iLCJ2aWV3cG9ydEluaXRpYWxpemF0aW9uIiwiY29udGVudEluaXRpYWxpemF0aW9uIiwidGFyZ2V0RWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJkb2NFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0RG9jdW1lbnRXaW5kb3ciLCJkZWZhdWx0VmlldyIsImdlbmVyYWxTdGF0aWNJbml0aWFsaXphdGlvbkVsZW1lbnQiLCJjcmVhdGVOZXdEaXYiLCJnZW5lcmF0ZVZpZXdwb3J0RWxlbWVudCIsImdlbmVyYXRlQ29udGVudEVsZW1lbnQiLCJlbGVtZW50SGFzT3ZlcmZsb3ciLCJvZmZzZXRTaXplIiwic2Nyb2xsU2l6ZSIsInBvc3NpYmxlVmlld3BvcnRFbGVtZW50Iiwidmlld3BvcnRJc1RhcmdldCIsInBvc3NpYmxlQ29udGVudEVsZW1lbnQiLCJ2aWV3cG9ydElzQ29udGVudCIsInZpZXdwb3J0RWxlbWVudCIsImhvc3RFbGVtZW50IiwicGFkZGluZ0VsZW1lbnQiLCJjb250ZW50RWxlbWVudCIsImdlbmVyYXRlZEVsZW1lbnRzIiwiZWxlbWVudElzR2VuZXJhdGVkIiwib3JpZ2luYWxOb25Cb2R5U2Nyb2xsT2Zmc2V0RWxlbWVudCIsInNjcm9sbE9mZnNldEVsZW1lbnQiLCJzY3JvbGxFdmVudEVsZW1lbnQiLCJldmFsdWF0ZWRUYXJnZXRPYmoiLCJfcGFkZGluZyIsIl9vcmlnaW5hbFNjcm9sbE9mZnNldEVsZW1lbnQiLCJfd2luZG93RWxtIiwidmlld3BvcnRBdHRyaWJ1dGVDbGFzc05hbWUiLCJybiIsInRhcmdldENvbnRlbnRzIiwiY29udGVudFNsb3QiLCJkb2NXbmQiLCJpbml0QWN0aXZlRWxtIiwidW53cmFwIiwicHJlcGFyZVdyYXBVbndyYXBGb2N1cyIsInRhYkluZGV4U3RyIiwib3JpZ2luYWxWaWV3cG9ydFRhYkluZGV4IiwidW5kb0luaXRXcmFwVW5kd3JhcEZvY3VzIiwiZGVzdHJveUFjdGl2ZUVsbSIsInZpZXdwb3J0SXNHZW5lcmF0ZWQiLCJkZXN0cm95Rm9jdXNFbGVtZW50IiwidW5kb0Rlc3Ryb3lXcmFwVW5kd3JhcEZvY3VzIiwiY3JlYXRlVHJpbnNpY1VwZGF0ZVNlZ21lbnQiLCJfb2JzZXJ2ZXJzU3RhdGUiLCIkdCIsIk90IiwiY3JlYXRlUGFkZGluZ1VwZGF0ZVNlZ21lbnQiLCJ1cGRhdGVQYWRkaW5nQ2FjaGUiLCJjdXJyZW50UGFkZGluZ0NhY2hlIiwicGFkZGluZ0NoYW5nZWQiLCJfdCIsInh0IiwicGFkZGluZ0Fic29sdXRlQ2hhbmdlZCIsImNvbnRlbnRNdXRhdGlvbiIsInBhZGRpbmdTdHlsZUNoYW5nZWQiLCJwYWRkaW5nUmVsYXRpdmUiLCJwYWRkaW5nSG9yaXpvbnRhbCIsInBhZGRpbmdWZXJ0aWNhbCIsInBhZGRpbmdTdHlsZSIsInZpZXdwb3J0U3R5bGUiLCJfcGFkZGluZ0Fic29sdXRlIiwiX3BhZGRpbmdTdHlsZUNoYW5nZWQiLCJjcmVhdGVPdmVyZmxvd1VwZGF0ZVNlZ21lbnQiLCJhbiIsIm1heDAiLCJmbG93RGlyZWN0aW9uQ2FuQmVOb25EZWZhdWx0TWFwIiwiZGlzcGxheSIsImRpcmVjdGlvbiIsImRpcmVjdGlvblN0eWxlIiwiZmxleERpcmVjdGlvbiIsImZsZXhEaXJlY3Rpb25TdHlsZSIsImVuZHNXaXRoIiwid3JpdGluZ01vZGUiLCJ3cml0aW5nTW9kZVN0eWxlIiwiZmxvd0RpcmVjdGlvblN0eWxlQXJyIiwid2hDYWNoZU9wdGlvbnMiLCJwYXJ0aWFsWFlPcHRpb25zIiwic2V0TWVhc3VyaW5nTW9kZSIsImFjdGl2ZSIsImdldEZsb3dEaXJlY3Rpb25TdHlsZXMiLCJnZXRNZWFzdXJlZFNjcm9sbENvb3JkaW5hdGVzIiwiZmxvd0RpcmVjdGlvblN0eWxlc0lzRm9yZWlnbiIsInNraXBOb25EZWZhdWx0U2Nyb2xsQ29vcmRpbmF0ZXNDaGVjayIsImZsb3dEaXJlY3Rpb25TdHlsZXNJbmRpY2F0ZU5vbkRlZmF1bHRGbG93RGlyZWN0aW9uIiwic29tZSIsInN0eWxlTmFtZSIsInN0eWxlVmFsdWUiLCJmbG93RGlyZWN0aW9uSXNEZWZhdWx0Iiwib3JpZ2luYWxTY3JvbGxPZmZzZXQiLCJyZW1vdmVOb0NvbnRlbnQiLCJyZW1vdmVTY3JvbGxCbG9jayIsInNjcm9sbEV2ZW50U2Nyb2xsT2Zmc2V0IiwiaXNUcnVzdGVkIiwicG9zaXRpdmVTY3JvbGwiLCJwb3NpdGl2ZURpc3RhbmNlIiwibmVnYXRpdmVTY3JvbGwiLCJuZWdhdGl2ZURpc3RhbmNlIiwiZ2V0T3ZlcmZsb3dBbW91bnQiLCJ2aWV3cG9ydENsaWVudFNpemUiLCJ0b2xsZXJhbmNlIiwiZ2V0Vmlld3BvcnRPdmVyZmxvd1N0eWxlIiwiZ2V0QXhpc092ZXJmbG93U3R5bGUiLCJheGlzQmVoYXZpb3IiLCJheGlzSGFzT3ZlcmZsb3ciLCJwZXJwZW5kaWN1bGFyQmVoYXZpb3IiLCJwZXJwZW5kaWN1bGFyT3ZlcmZsb3ciLCJiZWhhdmlvclN0eWxlIiwiYXhpc092ZXJmbG93VmlzaWJsZSIsInBlcnBlbmRpY3VsYXJPdmVyZmxvd1Zpc2libGUiLCJub25QZXJwZW5kaWN1bGFyT3ZlcmZsb3ciLCJub25PdmVyZmxvdyIsInNldFZpZXdwb3J0T3ZlcmZsb3dTdHlsZSIsImNyZWF0ZUFsbE92ZXJmbG93U3R5bGVDbGFzc05hbWVzIiwiY3JlYXRlVmlld3BvcnRPdmVyZmxvd1N0eWxlQ2xhc3NOYW1lIiwiYWxsT3ZlcmZsb3dTdHlsZUNsYXNzTmFtZXMiLCJ1cGRhdGVTaXplRnJhY3Rpb24iLCJnZXRDdXJyZW50U2l6ZUZyYWN0aW9uIiwidXBkYXRlVmlld3BvcnRTY3JvbGxTaXplQ2FjaGUiLCJnZXRDdXJyZW50Vmlld3BvcnRTY3JvbGxTaXplQ2FjaGUiLCJ1cGRhdGVPdmVyZmxvd0Ftb3VudENhY2hlIiwiZ2V0Q3VycmVudE92ZXJmbG93QW1vdW50Q2FjaGUiLCJ1cGRhdGVIYXNPdmVyZmxvd0NhY2hlIiwidXBkYXRlT3ZlcmZsb3dFZGdlIiwiZ2V0Q3VycmVudE92ZXJmbG93RWRnZUNhY2hlIiwidXBkYXRlT3ZlcmZsb3dTdHlsZUNhY2hlIiwidXBkYXRlTm9uRGVmYXVsdEZsb3dEaXJlY3Rpb25TdHlsZXMiLCJjdXJyVmFsIiwidXBkYXRlTWVhc3VyZWRTY3JvbGxDb29yZGluYXRlcyIsImdldEN1cnJlbnRNZWFzdXJlZFNjcm9sbENvb3JkaW5hdGVzIiwicHJlZml4IiwiSHQiLCJFdCIsInNjcm9sbGJhcnNIaWRpbmdQbHVnaW5WaWV3cG9ydEFycmFuZ2VtZW50IiwiWCIsIlkiLCJXIiwib3ZlcmZsb3dYVmlzaWJsZSIsIm92ZXJmbG93WVZpc2libGUiLCJ2aWV3cG9ydENoYW5nZWQiLCJzaXplRnJhY3Rpb25DYWNoZSIsInZpZXdwb3J0U2Nyb2xsU2l6ZUNhY2hlIiwib3ZlcmZsb3dBbXVudENhY2hlIiwib3ZlcmZsb3dFZGdlQ2FjaGUiLCJ3aW5kb3dJbm5lclNpemUiLCJvdmVyZmxvd0Ftb3VudFNjcm9sbFNpemUiLCJvdmVyZmxvd0Ftb3VudENsaWVudFNpemUiLCJvdmVyZmxvd0VkZ2UiLCJvdmVyZmxvd0VkZ2VDaGFuZ2VkIiwib3ZlcmZsb3dBbW91bnRDaGFuZ2VkIiwidmlld3BvcnRTY3JvbGxTaXplQ2hhbmdlZCIsInNpemVGcmFjdGlvbkNoYW5nZWQiLCJoYXNPdmVyZmxvd0NoYW5nZWQiLCJyZW1vdmVDbGlwcGluZyIsImFkanVzdFZpZXdwb3J0U3R5bGUiLCJmbG93RGlyZWN0aW9uU3R5bGVzT3B0aW9uIiwiZmxvd0RpcmVjdGlvblN0eWxlc0NoYW5nZWQiLCJhZGp1c3RNZWFzdXJlZFNjcm9sbENvb3JkaW5hdGVzIiwic2Nyb2xsQ29vcmRpbmF0ZXMiLCJzY3JvbGxDb29yZGluYXRlc0NoYW5nZWQiLCJvdmVyZmxvd1N0eWxlQ2hhbmdlZCIsImNyZWF0ZVN0cnVjdHVyZVNldHVwIiwiYXBwZW5kU3RydWN0dXJlRWxlbWVudHMiLCJjYW5jZWxlZCIsInVwZGF0ZVNlZ21lbnRzIiwidXBkYXRlSW5mbyIsImFkanVzdFNjcm9sbE9mZnNldCIsInVwZGF0ZVNlZ21lbnQiLCJjcmVhdGVTZXR1cHMiLCJpc0Rlc3Ryb3llZCIsIm9uVXBkYXRlZCIsImNhY2hlQW5kT3B0aW9uc0luaXRpYWxpemVkIiwic3RydWN0dXJlU2V0dXBDcmVhdGUiLCJzdHJ1Y3R1cmVTZXR1cFVwZGF0ZSIsInN0cnVjdHVyZVNldHVwQ2FuY2VsZWQiLCJvYnNlcnZlcnNTZXR1cENyZWF0ZSIsIm9ic2VydmVyc1NldHVwVXBkYXRlIiwib2JzZXJ2ZXJzVXBkYXRlSGludHMiLCJzY3JvbGxiYXJzU2V0dXBDcmVhdGUiLCJzY3JvbGxiYXJzU2V0dXBVcGRhdGUiLCJzY3JvbGxiYXJzU2V0dXBFbGVtZW50cyIsInVwZGF0ZUhpbnRzQXJlVHJ1dGh5IiwiaGludHMiLCJvYnNlcnZlclVwZGF0ZUhpbnRzIiwiX2NoYW5nZWRPcHRpb25zIiwicmF3Q2hhbmdlZE9wdGlvbnMiLCJyYXdGb3JjZSIsIkl0IiwicG4iLCJfY2xvbmVTY3JvbGxiYXIiLCJiYXNlVXBkYXRlSW5mb09iaiIsIm9ic2VydmVyc0hpbnRzIiwic3RydWN0dXJlSGludHMiLCJ0cnV0aHlPYnNlcnZlcnNIaW50cyIsInRydXRoeVN0cnVjdHVyZUhpbnRzIiwibG4iLCJpbml0aWFsU2Nyb2xsIiwiX29ic2VydmVyc1NldHVwU3RhdGUiLCJfc3RydWN0dXJlU2V0dXBTdGF0ZSIsIl9zdHJ1Y3R1cmVTZXR1cEVsZW1lbnRzIiwiX3Njcm9sbGJhcnNTZXR1cEVsZW1lbnRzIiwidGFyZ2V0SW5zdGFuY2VNYXAiLCJhZGRJbnN0YW5jZSIsInJlbW92ZUluc3RhbmNlIiwiZ2V0SW5zdGFuY2UiLCJPdmVybGF5U2Nyb2xsYmFycyIsImV2ZW50TGlzdGVuZXJzIiwidHQiLCJ0YXJnZXRJc0VsZW1lbnQiLCJpbnN0YW5jZVRhcmdldCIsInBvdGVudGlhbEluc3RhbmNlIiwiaW5zdGFuY2VQbHVnaW5Nb2R1bGVJbnN0YW5jZXMiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJuZXdPcHRpb25zV2l0aG91dFVuZGVmaW5lZCIsInBsdWdpblZhbGlkYXRlIiwiY3VycmVudE9wdGlvbnMiLCJhZGRQbHVnaW5FdmVudCIsInJlbW92ZVBsdWdpbkV2ZW50cyIsInRyaWdnZXJQbHVnaW5FdmVudCIsImFkZEluc3RhbmNlRXZlbnQiLCJyZW1vdmVJbnN0YW5jZUV2ZW50cyIsInRyaWdnZXJJbnN0YW5jZUV2ZW50Iiwic2V0dXBzQ29uc3RydWN0Iiwic2V0dXBzVXBkYXRlIiwic2V0dXBzU3RhdGUiLCJzZXR1cHNFbGVtZW50cyIsInNldHVwc0NhbmNlbGVkIiwic2l6ZUNoYW5nZWQiLCJkaXJlY3Rpb25DaGFuZ2VkIiwiaG9zdE11dGF0aW9uIiwicHVyZSIsImJhc2UiLCJvbiIsIm9mZiIsInZuIiwiZ24iLCJkaXJlY3Rpb25SVEwiLCJqdCIsIkp0IiwidHJhbnNsYXRlU2Nyb2xsYmFyU3RydWN0dXJlIiwidHJhbnNsYXRlU2Nyb2xsYmFyc1NldHVwRWxlbWVudCIsInNjcm9sbGJhcnNTZXR1cEVsZW1lbnQiLCJYdCIsIll0IiwidHJhbnNsYXRlZFN0cnVjdHVyZSIsInNjcm9sbGJhckhvcml6b250YWwiLCJzY3JvbGxiYXJWZXJ0aWNhbCIsInBsdWdpbnMiLCJpc0FyciIsInBsdWdpbnNUb0FkZCIsInZhbGlkIiwiaGFzRWxtc0ZuIiwiSiIsIm90Iiwic3QiLCJaIiwibnQiLCJzY3JvbGxiYXJzU2l6ZSIsInNjcm9sbGJhcnNPdmVybGFpZCIsInNjcm9sbGJhcnNIaWRpbmciLCJzZXREZWZhdWx0SW5pdGlhbGl6YXRpb24iLCJzZXREZWZhdWx0T3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../packages/overlayscrollbars/dist/overlayscrollbars.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Ccomponents%5C%5COverlayScrollbarsClientComponent.tsx%22%2C%22ids%22%3A%5B%22*%22%2C%22OverlayScrollbarsClientComponent%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CGithub%5C%5COverlayScrollbars%5C%5Cwebsite%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);